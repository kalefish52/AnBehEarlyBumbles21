---
title: "CleanData"
output:
  pdf_document: default
  html_document:
    df_print: paged
    code_folding: "hide"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Load Packages
```{r}
library(tidyverse)# piping, subset and filtering
library(plyr)
library(dplyr)    # subset, summarize, and filter
library(ggplot2)  # graphs
library(vegan)    # shannon diversity function
```

#.

# Load Raw Data
THIS ASSUMES YOUR DEFAULT WORKING DIRECTORY IS WHERE THIS DOCUMENT LIVES (MANUSCRIPT_ANALYSES)

We have to manually download each project file from Boris. Each project is a single aggregated data file and represents one nest (ex. QF01). To download Boris files into a directory for data cleaning, do the following:
1) Open project file in BORIS
2) Observations -> Export Events -> Aggregated events
3) Press select all and then ok 
4) Select all subjects then all behaviors, press ok 
5) Group selected events into one file 
6) Save file as nest name eg. "QF01" as a .csv file in the BORISfiles directory 
*Note: all state events must be paired to export as an aggregated file 
*Note: these files do not include observations that did not contain scored behaviors and do not include bees with no observed behaviors 

To download information about all videos watched (including those without any observed behaviors), we have to download an additional file for each project from Boris. To do this:
1) Open project file in BORIS
2) Analysis -> Synthetic time budget
3) Press select all and then ok
4) Press ok
5) Save file as nest name eg. "QF01" as a .csv file in the allBORISfiles directory
6) Click okay without selecting any additional behaviors to subtract from total time

import the BORIS observation datafiles and combine them into a single df called obs_data. this contains all the behavioral observations
```{r}
# function to return list of filenames in BORISfiles folder
# # use pattern="*.csv", when getting files from google drive stream, there is an extra non-.csv file 
# # use full.names=TRUE so that it reads in files using absolute file path 
getBORISfilenames <- function(gitfilepath) {
  filenames <- list.files(gitfilepath,
                          pattern = "*.csv",
                          full.names = TRUE)
  return(filenames)
}

# make the list of filenames
BORISfilenames <- getBORISfilenames("../Data/rawData/BORISfiles")

# loop over the files in the list and import all of them into a single dataframe. rename column names to remove "." and make shorter
obs_data <- do.call(rbind, lapply(BORISfilenames, 
                                    function(i) {
                                      read.csv(i, header = TRUE,
                                               col.names = c("obsID",
                                                             "obsDate",
                                                             "filename",
                                                             "totalLen",
                                                             "fps",
                                                             "beeID",
                                                             "behav", 
                                                             "cat",
                                                             "mod",
                                                             "behavType",
                                                             "start",
                                                             "stop",
                                                             "dur",
                                                             "comStart",
                                                             "comStop"))
                     }
))

# remove unwanted columns
obs_data <- subset(obs_data, select = -c(filename, fps, cat, mod, behavType, comStart, comStop))

# look at the data
obs_data

# check the number of total observations (total number of unfiltered behaviors recorded)
init_obs <- nrow(obs_data)
print(paste("There are", init_obs, "observations in the initial obs_data dataframe.", sep = " "))

```
import BORIS synthetic time budget datasheets and merge them into a single df called videos_data
```{r}
# function to return list of filenames in BORISfiles folder
# # use pattern="*.csv", when getting files from google drive stream, there is an extra non-.csv file 
# # use full.names=TRUE so that it reads in files using absolute file path 
getBORISfilenames <- function(gitfilepath) {
  filenames <- list.files(gitfilepath,
                          pattern = "*.csv",
                          full.names = TRUE)
  return(filenames)
}

# make the list of filenames
BORISfilenames <- getBORISfilenames("../Data/rawData/allBORISfiles")
BORISfilenames
# loop over the files in the list and import all of them into a single dataframe. skip first 3 lines of column headers and only import first 2 columns (obsID and totLen)
videos_data <- do.call(rbind, lapply(BORISfilenames, 
                                    function(i) {
                                      read.csv(i, skip = 3, header = FALSE)[,1:2]
                     }
))

# rename column headers to be descriptive
names(videos_data)[1] <- "obsID"
names(videos_data)[2] <- "totalLen"

# look at the data
videos_data
# check how many total videos in unfiltered data we watched
init_videos <- nrow(videos_data)
print(paste("There are", init_videos, "videos in the initial videos_data dataframe.", sep = " "))
```
import the master datasheets and combine them into a single df called master_data. this contains beeIDs and natal colony for each nest. this will enable us to include the bees that we did not have observed behaviors for in our analyses
```{r}
# do the same for the master datasheets that contain bee ID numbers
getMasterfilenames <- function(gitfilepath) {
  filenames <- list.files(gitfilepath,
                          pattern = "*.csv",
                          full.names = TRUE)
  return(filenames)
}

# make the list of filenames
masterfilenames <- getMasterfilenames("../Data/rawData/MasterDatasheets")

# loop over the files and import all of them. rename column names to remove "." and make shorter
master_data <- do.call(rbind, lapply(masterfilenames, 
                                    function(i) {
                                      read.csv(i, 
                                               header = FALSE, 
                                               skip = 1,
                                               na.strings=c("", " ", "NA", "na", "x", "X", "xp", "-", "#VALUE!", 
                                                            "Died", "died", "died ", "died prior to freezing", "all died"),
                                               col.names = c("nestID",
                                                             "Qnatal",
                                                             "Qpulled",
                                                             "QID",
                                                             "Gas1",
                                                             "Gas2",
                                                             "Wnatal", 
                                                             "Wpulled",
                                                             "WID1",
                                                             "WID2",
                                                             "WID3",
                                                             "WID4",
                                                             "WID5",
                                                             "WIDrep1",
                                                             "WIDrep2",
                                                             "Eggs",
                                                             "DaysToEggs",
                                                             "LarvDate",
                                                             "FreezeDate",
                                                             "EggsToEclosion",
                                                             "TotalNestTime",
                                                             "Video1",
                                                             "Video2",
                                                             "Notes",
                                                             "MadeBorisFile"))
                     }
))

# look at the data
master_data

# check how many total, unfiltered nests there are
init_master <- nrow(master_data)
print(paste("There are", init_master, "nests accounted for in the initial master_data dataframe.", sep = " "))
```
import dead and replacement bee datasheets
```{r}
deadReplac_data <- read.csv("../Data/rawData/deadReplacementBees.csv", na.strings = c("na", " ", ""))
```
import egg laying datasheets
```{r}
egglaying_data <- read.csv("../Data/rawData/Egg_laying_Events.csv", 
                           col.names = c("nestID", "dateLaid", "beeID", "caste", "timeLaid", "viewer", "notes"))
```
import body size datasheets
```{r}
size_data <- read.csv("../Data/rawData/bodysizeworkers.csv", 
                      col.names = c("beeID", "nestID", "date", "wing1", "wing2", "size"), na.strings = "na")
```
import ovary development datasheets
```{r}
ovary_data <- read.csv("../Data/rawData/Ovarydata.csv", 
                       col.names = c("nestID", "beeID", "fb", "ov", "l1", "s1", "l2", "s2", "notes", "x", "xx"))
```
 




# Clean Data

## remove bad data
split obsID column from obs_data and videos_data into its component parts to enable manipulation by camera/colony/time/date
remove nests that died or otherwise are unusable
```{r}
# convert columns to character to enable manipulation with strsplit() and subset(startsWith())
obs_data$obsID <- as.character(obs_data$obsID)
videos_data$obsID <- as.character(videos_data$obsID)

# edit incorrect obsID information
# remove Kate from front of obsID name
obs_data[obs_data$obsID == "Kate\tfor\tNF02\t20180703\t13", 1] <- "for\tNF02\t20180703\t13"
videos_data[videos_data$obsID == "Kate\tfor\tNF02\t20180703\t13", 1] <- "for\tNF02\t20180703\t13"
# remove spaces in front of for in or nest
obs_data[startsWith(obs_data$obsID, " for"), 1] <- sub(".", "", obs_data[startsWith(obs_data$obsID, " for"), 1])
videos_data[startsWith(videos_data$obsID, " for"), 1] <- sub(".", "", videos_data[startsWith(videos_data$obsID, " for"), 1])
obs_data[startsWith(obs_data$obsID, " nest"), 1] <- sub(".", "", obs_data[startsWith(obs_data$obsID, " nest"), 1])
videos_data[startsWith(videos_data$obsID, " nest"), 1] <- sub(".", "", videos_data[startsWith(videos_data$obsID, " nest"), 1])

# add "non" to beginning of obsID for entries that are missing nest or for info
for (i in 1:nrow(obs_data)){
  if (startsWith(obs_data$obsID[i], "for") | startsWith(obs_data$obsID[i], "nest")) {}
  else {
    obs_data$obsID[i] <- paste("non", obs_data$obsID[i], sep = "\t")
    }
}
for (i in 1:nrow(videos_data)){
  if (startsWith(videos_data$obsID[i], "for") | startsWith(videos_data$obsID[i], "nest")) {}
  else {
    videos_data$obsID[i] <- paste("non", videos_data$obsID[i], sep = "\t")
    }
}

# split out obsID into camID, nestID, dateID and hourID (split based on the tab (\t) between elements)
# element 1 is camID
obs_data$camID <- sapply(strsplit(obs_data$obsID, "\t"), 
                          function(x){
                            x[1]
                            } )
videos_data$camID <- sapply(strsplit(videos_data$obsID, "\t"), 
                          function(x){
                            x[1]
                            } )
# element 2 is nestID
obs_data$nestID <- sapply(strsplit(obs_data$obsID, "\t"), 
                          function(x){
                            x[2]
                            } )
videos_data$nestID <- sapply(strsplit(videos_data$obsID, "\t"), 
                          function(x){
                            x[2]
                            } )
# element 3 is dateID
obs_data$dateID <- sapply(strsplit(obs_data$obsID, "\t"), 
                          function(x){ 
                            x[3]
                            } )
videos_data$dateID <- sapply(strsplit(videos_data$obsID, "\t"), 
                          function(x){ 
                            x[3]
                            } )
# element 4 is hourID
obs_data$hourID <- sapply(strsplit(obs_data$obsID, "\t"), 
                          function(x){ 
                            x[4]
                            } )
videos_data$hourID <- sapply(strsplit(videos_data$obsID, "\t"), 
                          function(x){ 
                            x[4]
                            } )
```
subset data to only include nests and behaviors of interest for analyses
```{r}
# remove unusable nests from master_data first, then subset other dataframes to include only those nests we want to keep

# make nestID character to enable startsWith 
master_data$nestID <- as.character(master_data$nestID)

# remove colonies that were not frozen from master_data (these colonies died before males eclosed)
master_data <- master_data[!is.na(master_data$FreezeDate),]

# remove QF01 (it was frozen and males eclosed, but all adults died)
master_data <- master_data[!master_data$nestID == "QF01",]

# remove QF08 & NT07 (missing workers)
master_data <- master_data[!master_data$nestID == "QF08",]
master_data <- master_data[!master_data$nestID == "NT07",]

# remove QT07 (queen died)
master_data <- master_data[!master_data$nestID == "QT07",]

# remove QA groups and bees (data for a different experiment)
master_data <- master_data[!startsWith(master_data$nestID, "QA"),]

# subset observations and videos to only include the filtered nests
obs_data <- subset(obs_data, nestID %in% master_data$nestID)
videos_data <- subset(videos_data, nestID %in% master_data$nestID)

# subset observations to include only the behaviors we're interested in
obs_data <- obs_data[(obs_data$behav == "feedsbrood" | obs_data$behav == "nectarforaging" | obs_data$behav == "pollenforaging") ,]

# check how many remaining observations we have after filtering
clean_obs <- nrow(obs_data)
clean_videos <- nrow(videos_data)
clean_master <- nrow(master_data)
print(paste("There are", clean_obs, "out of", init_obs, "remaining observations in the cleaned obs_data", sep = " "))
print(paste("There are", clean_videos, "out of", init_videos, "remaining observations in cleaned videos_data", sep = " "))
print(paste("There are", clean_master, "out of", init_master, "remaining observations in cleaned master_data", sep = " ")) 

# check how many nests are contained in each dataframe (they should be equal!)
if(length(unique(master_data$nestID)) == length(unique(obs_data$nestID)) && length(unique(master_data$nestID)) == length(unique(videos_data$nestID))) {
  print("All nests are accounted for in the video, obs, and master dataframes!")
} else { print("Some nests are not accounted for in one or more of the video, obs, or master dataframes") }
```
## format all dfs the same way with the same information
pull out caste information and ID number from beeIDs, name unidentified observations as "unknown" bee, pull out nestTYPE information
```{r}
# format the master_data in the same way as the obs_data
# gather the master_data so each worker and queen has their own row
masterBees <- master_data %>%
  gather(QID, WID1, WID2, WID3, WID4, WID5, WIDrep1, WIDrep2,  
         key = "beeType", 
         value = "beeID")

# pull out caste info from masterBees
masterBees$caste <- sapply(strsplit(masterBees$beeType, ""), 
                          function(x){
                            x[1]
                          })
# pull out caste info from obs_data
obs_data$beeID <- as.character(obs_data$beeID)
obs_data$caste <- sapply(strsplit(obs_data$beeID, ""), 
                          function(x){
                            x[1]
                          })
# make caste "N" and "U" (from unidentified bees with unidentified caste) worker -- if it were a queen we would be able to tell by size
obs_data[obs_data$caste == "U", "caste"] <- "W"
obs_data[obs_data$caste == "N", "caste"] <- "W"

# reformat caste info from egglaying_data to match
egglaying_data[egglaying_data$caste == "worker", "caste"] <- "W"
egglaying_data[egglaying_data$caste == "queen", "caste"] <- "Q"

# pull out ID number from beeID column in obs_data (instead of "Worker 5 (76)" or "Queen (43)" etc)
obs_data$beeID <- sapply(strsplit(obs_data$beeID, ")"),
                        function(x){
                          x[1]
                        })
obs_data$beeID <- sapply(strsplit(obs_data$beeID, "\\("),
                        function(x){
                          x[2]
                        })

# rename masterBees beeTypes to be only two categories (original or replacement bee)
masterBees[masterBees$beeType == "QID", "beeType"] <- "orig"
masterBees[masterBees$beeType == "WID1", "beeType"] <- "orig"
masterBees[masterBees$beeType == "WID2", "beeType"] <- "orig"
masterBees[masterBees$beeType == "WID3", "beeType"] <- "orig"
masterBees[masterBees$beeType == "WID4", "beeType"] <- "orig"
masterBees[masterBees$beeType == "WID5", "beeType"] <- "orig"
masterBees[masterBees$beeType == "WIDrep1", "beeType"] <- "replac"
masterBees[masterBees$beeType == "WIDrep2", "beeType"] <- "replac"

# rename unidentified workers from the video data
obs_data[, "beeID"][is.na(obs_data[, "beeID"])] <- "unknown"
# rename "6 or 9" bee to 6
obs_data[obs_data$beeID == "6 or 9", "beeID"] <- 6

# remove masterBees without an ID number (these are blank spaces on the datasheet that do not represent bees)
masterBees <- masterBees[!is.na(masterBees$beeID),]

# combine beeID and nestID so that each bee has a unique identifier (some numbers are duplicated across nests)
masterBees$beeID <- paste0(masterBees$nestID, masterBees$beeID)
obs_data$beeID <- paste0(obs_data$nestID, obs_data$beeID)
deadReplac_data$beeID <- paste0(deadReplac_data$nestID, deadReplac_data$beeID)
egglaying_data$beeID <- paste0(egglaying_data$nestID, egglaying_data$beeID)
ovary_data$beeID <- paste0(ovary_data$nestID, ovary_data$beeID)
size_data$beeID <- paste0(size_data$nestID, size_data$beeID)

# pull out nestTYPE as a separate column
obs_data$nestTYPE <- substr(obs_data$nestID, start = 1, stop = 2)
videos_data$nestTYPE <- substr(videos_data$nestID, start = 1, stop = 2)
masterBees$nestTYPE <- substr(masterBees$nestID, start = 1, stop = 2)
egglaying_data$nestTYPE <- substr(egglaying_data$nestID, start = 1, stop = 2)
ovary_data$nestTYPE <- substr(ovary_data$nestID, start = 1, stop = 2)
size_data$nestTYPE <- substr(size_data$nestID, start = 1, stop = 2)
```
## remove bad observations
remove foraging events less than 10 seconds long (poop trips) and remove nest video data after first 5 minutes (errors)
```{r}
# remove all nectar foraging events under 10 seconds long
beforeNectRemov <- nrow(obs_data)
obs_data <- obs_data[!(obs_data$behav == "nectarforaging" & obs_data$dur < 10),]

# remove all pollen foraging events under 10 seconds long
beforePollRemov <- nrow(obs_data)
obs_data <- obs_data[!(obs_data$behav == "pollenforaging" & obs_data$dur < 10),]

# check how many foraging observations were removed that were under 10 seconds long
NectPollRemov <- nrow(obs_data)
print(paste(beforeNectRemov - beforePollRemov, "nectar foraging observations were removed because they were under 10 seconds long.", sep = " "))
print(paste(beforePollRemov - NectPollRemov, "pollen foraging observations were removed because they were under 10 seconds long.", sep = " "))

# remove all but the first five minutes of nest videos

# make time variables numeric
obs_data$start <- as.numeric(obs_data$start)
obs_data$stop <- as.numeric(obs_data$stop)
obs_data$totalLen <- as.numeric(obs_data$totalLen)
videos_data$totalLen <- as.numeric(videos_data$totalLen)

# remove nest behaviors that start after 5 minute mark
obs_data <- obs_data[!(obs_data$camID == "nest" & obs_data$start > 300),]

# check how many were removed that started after 5 minutes
fiveMinRemov_obs <- nrow(obs_data)
print(paste(NectPollRemov - fiveMinRemov_obs, "nest observations were removed because they started after the five minute mark.", sep = " "))

# cut down nest videos to only look at first 5 minutes (300 seconds), and make all behaviors stop by 5 minutes
for (i in 1:nrow(obs_data)) {                                             # for every row in the dataframe
  if ((obs_data$camID[i] == "nest") & (obs_data$totalLen[i] > 300)) {     # if it's a nest video and it is over 300 seconds long
    obs_data$totalLen[i] <- 300                                           # make the total length of the video 300 seconds (5 minutes)
    if (obs_data$stop[i] > 300) {                                         # of those nest videos, if a behavior ends past 300 seconds
      obs_data$stop[i] <- 300                                             # set the stop time to 300 seconds
      obs_data$dur[i] <- obs_data$stop[i] - obs_data$start[i]             # and recalculate the duration of that behavior to end at 300s
    }
  }
}

for (i in 1:nrow(videos_data)) {                                             # for every row in the dataframe
  if ((videos_data$camID[i] == "nest") & (videos_data$totalLen[i] > 300)) {  # if it's a nest video and it is over 300 seconds long
    videos_data$totalLen[i] <- 300                                           # make the total length of the video 300 seconds (5 minutes)
  }
}

# make duration of all brood feeding events 1 second duration to enable duration comparisons
for (i in 1:nrow(obs_data)) {
  if (!is.na(obs_data$behav[i]) && obs_data$behav[i] == "feedsbrood") {
    obs_data$dur[i] <- 1
  }
}

# check how many observations remain after all cleaning has been completed
clean_obs <- nrow(obs_data)
clean_videos <- nrow(videos_data)
print(paste("There are now", clean_obs, "observations remaining in the fully cleaned obs_data.", init_obs - clean_obs, "observations fewer than the initial observations, because", beforeNectRemov - beforePollRemov + beforePollRemov - NectPollRemov + NectPollRemov - fiveMinRemov_obs, "were removed above.",  sep = " "))
print(paste("There are now", clean_videos, "out of", init_videos, "remaining videos in fully cleaned videos_data", sep = " "))
```


#.

# Combine Data

## combine masterBees and obs_data
merge obs_data to masterBees to add bees who did not carry out any recorded behaviors (ie missing from initial obs_data file)
```{r}
# make a list of all the bees we do have records for
recordedBees <- subset(masterBees, (beeID %in% obs_data$beeID))

# make a list of all bees we do not have observations for
missingBees <- subset(masterBees, !(beeID %in% obs_data$beeID))

# print how many total bees we have
print(paste("There are", nrow(masterBees), "total bees across all colonies in the master datasheet.", sep = " "))

# print how many bees we don't have records for
print(paste("There are", nrow(missingBees), "bees for which we do not have any recorded behaviors.", sep = " "))
  
# add missing bees to obs_data file
# # add rows to obs_data, filled with NA values, number of rows equal to number of missingBees
emptydf <- data.frame(matrix(NA, nrow = nrow(missingBees), ncol = ncol(obs_data)))
# # make column names the same
names(emptydf) <- names(obs_data)
# # rbind the data. emptydf is at the tail of obs_data
obs_data <- rbind(obs_data, emptydf)  
# # fill the empty rows just added to obs_data with the missing bee nestID, nestTYPE, beeID, and caste
for (i in 0:(nrow(missingBees) - 1)) {
  obs_data$nestID[nrow(obs_data) - i] <- missingBees$nestID[i+1]
  obs_data$beeID[nrow(obs_data) - i] <- missingBees$beeID[i+1]
  obs_data$caste[nrow(obs_data) - i] <- missingBees$caste[i+1]
  obs_data$nestTYPE[nrow(obs_data) - i] <- missingBees$nestTYPE[i+1]}

# add beeType and natal colony info from masterBees to obs_data
obs_data$natal <- NA
obs_data$beeType <- NA
for (i in 1:nrow(obs_data)) {
  for (j in 1:nrow(masterBees)) {
    if (obs_data$beeID[i] == masterBees$beeID[j]) {
      obs_data$beeType[i] <- masterBees$beeType[j]
      if (obs_data$caste[i] == "W") {
        obs_data$natal[i] <- masterBees$Wnatal[j] 
      }
      if (obs_data$caste[i] == "Q") {
        obs_data$natal[i] <- masterBees$Qnatal[j] 
      }
    }
  }
}

# add random number column to make table compatible with pivot_wider in future steps. needs a unique identifier for each individual
obs_data$rand <- NA
for (i in 1:(nrow(obs_data))) {
  obs_data$rand[i] <- runif(1)
}

# check how many bees we have in the new obs_data. should equal the number of bees in the master_data
# select only relevant information
allBees <- dplyr::select(obs_data, nestID, nestTYPE, beeID, caste, natal, beeType)
# remove duplicates
allBees <- unique(allBees[c("nestID", "nestTYPE", "beeID", "caste", "natal", "beeType")])
unknownBees <- allBees[is.na(allBees$natal),]

# check how many bees are now included in obs_data
print(paste("There are", nrow(allBees), "bees total to be included in the analyses, including", nrow(unknownBees), "unidentified for bees.", sep = " "))
if (nrow(allBees) - nrow(unknownBees) == nrow(masterBees)) {
  print("All bees from the master datasheets are accounted for!")
} else {
  print(paste("ERROR! There are", nrow(allBees) - nrow(unknownBees), "identified bees accounted for, but the master datasheet has", nrow(masterBees), "bees. If there are only a few more bees than expected from the master datasheet, it is likely because of replacement bees. If there is a large difference here, something is wrong.", sep = " "))
}
```
## add dead bee info
merge obs_data to deadReplac_data to take dead and replacement bees into account,
remove bees that died prior to observations
```{r}
# merge obs_data with deadReplac_data 

# add columns to obs_data
obs_data$addDate <- NA
obs_data$diedDate <- NA
# fill those columns with data from deadReplac_data
for (i in 1:nrow(obs_data)) {
  for (j in 1:nrow(deadReplac_data)) {
    if (obs_data$beeID[i] == deadReplac_data$beeID[j]) {
      if (!is.na(deadReplac_data$addDate[j])) {
        obs_data$addDate[i] <- deadReplac_data$addDate[j] 
      }
      if (!is.na(deadReplac_data$diedDate[j])) {
        obs_data$diedDate[i] <- deadReplac_data$diedDate[j]
      }
    }
  }
}

# make a list of bees that died prior to observations starting
diedEarly <- c("NF0328", "QT0240", "QT022")
# remove those bees from obs_data - they will not be included an any analyses
obs_data <- obs_data[!obs_data$beeID %in% diedEarly,]


# rename dead and replacement bees with the same number to ad a and b

# make dateID an integer to enable comparisons among dates
obs_data$dateID <- as.integer(obs_data$dateID)

# go through every observation in obs_data. if the bee has both a died and added date (indicating it was replaced with the same number tag):
# if the died date is after the observation, add an "a" to the ID number. 
# if the was replaced before before the observation, add a "b" to the ID number
for (i in 1:nrow(obs_data)) {
  if (!is.na(obs_data$diedDate[i]) && !is.na(obs_data$addDate[i]) && !is.na(obs_data$dateID[i])) {
    if (obs_data$diedDate[i] > obs_data$dateID[i]) {
      obs_data$beeID[i] <- paste0(obs_data$beeID[i], "a")
      obs_data$beeType[i] <- "orig"
      obs_data$addDate[i] <- NA
    }
    if (obs_data$addDate[i] < obs_data$dateID[i]) {
      obs_data$beeType[i] <- "replac"
      obs_data$diedDate[i] <- NA
    }
  }
  
}
```

## make count_data df with counts of each behavior observed for each bee
output df with each bee as a single row, behaviors as columns, count of frequency of each behavior per bee as values - all bees
```{r}
# collapse the dataframe to count the number of instances doing each behavior
  # this outputs a new dataframe with columns nestID, nestTYPE, beeID, caste, natal, nectarforaging, feedsbrood, pollenforaging 
  # (and any other behaviors recorded), with counts for each behavior in as values
  # assumes rand number is not duplicated across individuals. 

# rename to count_data for clarity 
count_data <- obs_data
# add a column with value 1 that counts the behavioral observations this makes each behavior a count of 1 
count_data$count <- 1  
# condense data frame into relevant columns, each row is a single observation for an individual
count_data <- count_data %>%
  pivot_wider(id_cols = c("nestID", "nestTYPE", "beeID", "caste", "natal", "beeType", "addDate", "diedDate", "behav"),
              names_from = rand, 
              values_from = count) 

# add column to fill with sum of counts for each behav
countCol1 <- 10 # firstcolumn containing counts
count_data$totCount <- rowSums(count_data[countCol1:ncol(count_data)], na.rm = TRUE)

# subset dataframe to remove random number generated columns (only want summary data)
count_data <- count_data %>%
  dplyr::select(nestID, nestTYPE, beeID, caste, natal, beeType, addDate, diedDate, behav, totCount)

# collapse dataframe so that each bee has one single row and behaviors are additional columns
count_data <- count_data %>%
  pivot_wider(id_cols = c("nestID", "nestTYPE", "beeID", "caste", "natal", "beeType", "addDate", "diedDate", "behav"),
              names_from = behav, 
              values_from = totCount)

# remove NA column
count_data <- count_data[ , !names(count_data) %in% c("NA")]

# replace NA values in behavioral count columns with 0
count_data[c("nectarforaging", "pollenforaging", "feedsbrood")] [is.na(count_data[c("nectarforaging", "pollenforaging", "feedsbrood")])] <- 0
count_data
```
## add egg laying data to count_data
```{r}
# make new column in count_data to include egglaying
count_data$egglaying <- 0

# go through count_data and egglaying_data -- for any matching beeIDs, add 1 to the egglaying column for that bee
for(i in 1:nrow(count_data)) {
  for (j in 1:nrow(egglaying_data)) {
    if (count_data$beeID[i] == egglaying_data$beeID[j]) {
      count_data$egglaying[i] <- count_data$egglaying[i] + 1
    }
  }
}

# sum counts of behaviors to see total number of behaviors carried out by each indiv
count_data$nBehavs <- rowSums(count_data[, c("feedsbrood", "nectarforaging", "pollenforaging", "egglaying")], na.rm = TRUE)

# print how many bees we have here. should equal masterdata
print(paste("There are", nrow(count_data), "bees accounted for."))
if (nrow(count_data) - nrow(unknownBees) == nrow(masterBees)) {
  print("All bees from the master datasheets are accounted for!")
} else {
  print(paste("All bees are not properly accounted for. There are", nrow(count_data), "bees accounted for, but the master datasheet has", nrow(masterBees), "bees", sep = " "))
}
```
## add body size data to count_data
```{r}
count_data$size <- NA
for (i in 1:nrow(count_data)) {
  for (j in 1:nrow(size_data)) {
    if (count_data$beeID[i] == size_data$beeID[j]) {
      count_data$size[i] <- size_data$size[j]
    }
  }
}
count_data
```
## add ovary development data to count_data (workers only)
```{r}
# OVARY LENGTH - missing lots of values

# add to ovary length count_data
count_data$ovL1 <- NA
count_data$ovL2 <- NA
for (i in 1:nrow(count_data)) {
  for (j in 1:nrow(ovary_data)) {
    if (count_data$beeID[i] == ovary_data$beeID[j]) {
      count_data$ovL1[i] <- ovary_data$l1[j]
      count_data$ovL2[i] <- ovary_data$l2[j]
    }
  }
}

# OOCYTE RESORPTION

# duplicate stage columns to input resorption status
ovary_data$r1 <- ovary_data$s1
ovary_data$r2 <- ovary_data$s2
ovary_data
# convert r1 to numbers
ovary_data[is.na(ovary_data$r1), "r1"] <- "N"
ovary_data[ovary_data$r1 == "I", "r1"] <- 0
ovary_data[ovary_data$r1 == "II", "r1"] <- 0
ovary_data[ovary_data$r1 == "III", "r1"] <- 0
ovary_data[ovary_data$r1 == "III+", "r1"] <- 0
ovary_data[ovary_data$r1 == "IV", "r1"] <- 0
ovary_data[ovary_data$r1 == "IV+", "r1"] <- 0
ovary_data[ovary_data$r1 == "R + II", "r1"] <- 1
ovary_data[ovary_data$r1 == "VI", "r1"] <- 0
ovary_data[ovary_data$r1 == "R", "r1"] <- 1
ovary_data[ovary_data$r1 == "N", "r1"] <- NA
ovary_data$r1 <- as.numeric(ovary_data$r1)

# convert r2 to numbers
ovary_data[is.na(ovary_data$r2), "r2"] <- "N"
ovary_data[ovary_data$r2 == "I", "r2"] <- 0
ovary_data[ovary_data$r2 == "II", "r2"] <- 0
ovary_data[ovary_data$r2 == "III", "r2"] <- 0
ovary_data[ovary_data$r2 == "III+", "r2"] <-
ovary_data[ovary_data$r2 == "IV", "r2"] <-0
ovary_data[ovary_data$r2 == "IV+", "r2"] <- 0
ovary_data[ovary_data$r2 == "R + II", "r2"] <- 1
ovary_data[ovary_data$r2 == "VI", "r2"] <- 0
ovary_data[ovary_data$r2 == "R", "r2"] <- 1
ovary_data[ovary_data$r2 == "N", "r2"] <- NA
ovary_data$r2 <- as.numeric(ovary_data$r2)

count_data$ovR1 <- NA
count_data$ovR2 <- NA

# add ovary_data to count_data df
for (i in 1:nrow(count_data)) {
  for (j in 1:nrow(ovary_data)) {
    if (count_data$beeID[i] == ovary_data$beeID[j]) {
      count_data$ovR1[i] <- ovary_data$r1[j]
      count_data$ovR2[i] <- ovary_data$r2[j]
    }
  }
}

# OVARY STAGE - includes converting resorbed oocytes to stage 4

# convert ovary 1 stage numerals to numbers
ovary_data[is.na(ovary_data$s1), "s1"] <- "N"
ovary_data[ovary_data$s1 == "I", "s1"] <- 1
ovary_data[ovary_data$s1 == "II", "s1"] <- 2
ovary_data[ovary_data$s1 == "III", "s1"] <- 3
ovary_data[ovary_data$s1 == "III+", "s1"] <- 3.5
ovary_data[ovary_data$s1 == "IV", "s1"] <- 4
ovary_data[ovary_data$s1 == "IV+", "s1"] <- 4
ovary_data[ovary_data$s1 == "R + II", "s1"] <- "R"
ovary_data[ovary_data$s1 == "VI", "s1"] <- 4
ovary_data[ovary_data$s1 == "R", "s1"] <- 4
ovary_data[ovary_data$s1 == "N", "s1"] <- NA
ovary_data$s1 <- as.numeric(ovary_data$s1)

# convert ovary 2 stage numerals to numbers
ovary_data[is.na(ovary_data$s2), "s2"] <- "N"
ovary_data[ovary_data$s2 == "I", "s2"] <- 1
ovary_data[ovary_data$s2 == "II", "s2"] <- 2
ovary_data[ovary_data$s2 == "III", "s2"] <- 3
ovary_data[ovary_data$s2 == "III+", "s2"] <- 3.5
ovary_data[ovary_data$s2 == "IV", "s2"] <- 4
ovary_data[ovary_data$s2 == "IV+", "s2"] <- 4
ovary_data[ovary_data$s2 == "R + II", "s2"] <- "R"
ovary_data[ovary_data$s2 == "VI", "s2"] <- 4
ovary_data[ovary_data$s2 == "R", "s2"] <- 4
ovary_data[ovary_data$s2 == "N", "s2"] <- NA
ovary_data$s2 <- as.numeric(ovary_data$s2)

# add ovary stage to count_data
count_data$ovS1 <- NA
count_data$ovS2 <- NA
for (i in 1:nrow(count_data)) {
  for (j in 1:nrow(ovary_data)) {
    if (count_data$beeID[i] == ovary_data$beeID[j]) {
      count_data$ovS1[i] <- ovary_data$s1[j]
      count_data$ovS2[i] <- ovary_data$s2[j]
    }
  }
}
```
# Visualize Data

## graph the number of observations per camera type per nest 
These files are updated as more video observations are done. Video observations are performed by many different observers. Check how many observations have been recorded for each project for foraging and nest, at the two different time points. 
```{r}
# summarize the data to look at the total number of observations per nest
data_sum<- obs_data %>% dplyr::select(camID, nestID, nestTYPE) %>% dplyr::arrange(nestID, camID)

sumsTOTAL<-data_sum %>% dplyr::group_by(nestID, camID) %>% dplyr::summarise(Observations=dplyr::n())
sumsTYPE<-data_sum %>% dplyr::group_by(nestTYPE, camID) %>% dplyr::summarise(Observations=dplyr::n())

#look at number of observations we have so far based on each colony 
ggplot(sumsTOTAL, aes(x=nestID, y=Observations, fill=camID)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90)) +
  ggtitle("number of observations for all filtered nests, regardless of video duration")

# look at number of observations we have so far based on each type of colony 
ggplot(sumsTYPE, aes(x=nestTYPE, y=Observations, fill=camID)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90)) +
  ggtitle("number of observations per nestTYPE for all filtered nests, regardless of video duration")


sumsTYPE
sumsTOTAL
```
## graph the number of observations per behavior per nest
```{r}
# graph the number of behaviors we have per nest
data_sum <- count_data %>% dplyr::select(nestID, nestTYPE, nectarforaging, pollenforaging, feedsbrood) %>% arrange(nestID)

sumsTYPE<-data_sum %>% group_by(nestTYPE) 

# look at data we have so far based on each nestID 
ggplot(data_sum, aes(x=nestID, y=feedsbrood, fill=nestTYPE)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90)) + 
  ggtitle("number of brood feeding observations for all filtered nests, regardless of video duration")

ggplot(data_sum, aes(x=nestID, y=nectarforaging, fill=nestTYPE)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90)) + 
  ggtitle("number of nectar foraging observations for all filtered nests, regardless of video duration")

ggplot(data_sum, aes(x=nestID, y=pollenforaging, fill=nestTYPE)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90)) + 
  ggtitle("number of pollen foraging observations for all filtered nests, regardless of video duration")

# look at data we have so far based on each nestTYPE 
ggplot(sumsTYPE, aes(x=nestTYPE, y=feedsbrood, fill=nestTYPE)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90)) + 
  ggtitle("number of brood feeding observations for all filtered nests, regardless of video duration")

ggplot(sumsTYPE, aes(x=nestTYPE, y=nectarforaging, fill=nestTYPE)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90)) + 
  ggtitle("number of nectar foraging observations for all filtered nests, regardless of video duration")

ggplot(sumsTYPE, aes(x=nestTYPE, y=pollenforaging, fill=nestTYPE)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90)) + 
  ggtitle("number of pollen foraging observations for all filtered nests, regardless of video duration")
```
## calculate and graph total duration of video watched per nest
```{r}
# select only the obsID, nestID, and totalLen columns
# subset to only the unique combinations (ie. remove duplicate videos so we don't count more time than we watched)
nVids <- nrow(videos_data)
totalLen_data <- videos_data %>%
  dplyr::select(obsID, camID, nestID, nestTYPE, dateID, hourID, totalLen) %>%
  unique()

# print how many videos were removed
print(paste("There were", nVids - nrow(totalLen_data), "duplicate videos removed.", sep = " "))

# verify we have the correct number of colonies and videos
print(paste("There are", nrow(totalLen_data), "videos out of", clean_videos, "fully cleaned videos accounted for in the totalLen_data dataframe."))

# create empty dataframe to put length into
camDur <- data.frame(nestID = NA,
                     nestTYPE = NA,
                     forLen = NA,
                     nestLen = NA,
                     totalLen = NA)

# for each unique nest, subset the data to look at one nest at a time. then split out foraging and nest videos
for (i in 1:length(unique(totalLen_data$nestID))) {
  sub_data <- subset(totalLen_data, nestID == unique(totalLen_data$nestID)[i]) # subset to look at a single nest
  for_data <- subset(sub_data, sub_data$camID == "for")                        # subset foraging video only into for_data
  nest_data <- subset(sub_data, sub_data$camID == "nest")                      # subset nest video only into nest_data
  forSum <- sum(for_data$totalLen)                                             # sum the video duration of all foraging videos
  nestSum <- sum(nest_data$totalLen)                                           # sum the video duration of all nest videos
  totalSum <- sum(sub_data$totalLen)                                           # sum the video duration of all videos
  camDur <- rbind(camDur, c(sub_data$nestID[1], sub_data$nestTYPE[1], forSum, nestSum, totalSum))    # add the sum totals to the camDur df
}
camDur

# remove NA row initially created
camDur <- camDur[2:nrow(camDur),]

# count to make sure all colonies are accounted for
print(paste("There are", nrow(camDur), "colonies accounted for in the camDur dataframe out of", nrow(master_data), "master colonies.", sep = " "))

# make columns numeric so i can calculate ratio in next step
camDur$totalLen <- as.numeric(camDur$totalLen)
camDur$forLen <- as.numeric(camDur$forLen)
camDur$nestLen <- as.numeric(camDur$nestLen)
camDur$nestID <- as.character(camDur$nestID)

## make new column with the ratio of foraging to nest video length. should be ~12 for each colony. if it's not, need to watch more videos
camDur$FNratio <- NA
for (i in 1:nrow(camDur)) {
  camDur$FNratio[i] <- camDur$forLen[i] / camDur$nestLen[i]
}

# check to see how much video was watched for each nest and for each treatment
# must be equal + ratio must be 1 to compare
camDur
camDur <- camDur[order(camDur$nestID),]

# graph total duration of video watched for each nestID

sumsTYPE<-camDur %>% group_by(nestTYPE)
ggplot(camDur, aes(x=nestID, y=forLen, fill = nestTYPE)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90)) + 
  ggtitle("duration of foraging video watched for all filtered nests, regardless of video duration threshold")

ggplot(camDur, aes(x=nestID, y=nestLen, fill = nestTYPE)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90)) + 
  ggtitle("duration of nest video watched for all filtered nests, regardless of video duration threshold")

# look at data we have so far based on each nestTYPE

ggplot(sumsTYPE, aes(x=nestTYPE, y=forLen, fill = nestTYPE)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90)) + 
  ggtitle("duration of foraging video watched for all filtered nests, regardless of video duration threshold")

ggplot(sumsTYPE, aes(x=nestTYPE, y=nestLen, fill = nestTYPE)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90)) + 
  ggtitle("duration of nest video watched for all filtered nests, regardless of video duration threshold")

# print number of seconds and hours of video watched

# summary of all videos
allNestH <- sum(camDur$nestLen)/60/60
allForH <- sum(camDur$forLen)/60/60
allVideosH <- sum(camDur$totalLen)/60/60
avgNestH <- mean(camDur$nestLen)/60/60
avgForH <- mean(camDur$forLen)/60/60
avgTotalH <- mean(camDur$totalLen)/60/60

# summary by nestTYPE
avgNFnestH <- mean(camDur$nestLen[camDur$nestTYPE == "NF"])/60/60
avgNTnestH <- mean(camDur$nestLen[camDur$nestTYPE == "NT"])/60/60
avgQFnestH <- mean(camDur$nestLen[camDur$nestTYPE == "QF"])/60/60
avgQTnestH <- mean(camDur$nestLen[camDur$nestTYPE == "QT"])/60/60

avgNFforH <- mean(camDur$forLen[camDur$nestTYPE == "NF"])/60/60
avgNTforH <- mean(camDur$forLen[camDur$nestTYPE == "NT"])/60/60
avgQFforH <- mean(camDur$forLen[camDur$nestTYPE == "QF"])/60/60
avgQTforH <- mean(camDur$forLen[camDur$nestTYPE == "QT"])/60/60

# print summaries
print(paste("We watched", round(allNestH, digits = 1), "hours of NEST videos overall, which is an average of", round(avgNestH, digits = 1), "hours per colony", sep = " "))
print(paste("We watched", round(allForH, digits = 1), "hours of FORAGING videos overall, which is an average of", round(avgForH, digits = 1), "hours per colony", sep = " "))
print(paste("We watched", round(allVideosH, digits = 1), "hours of ALL videos overall, which is an average of", round(avgTotalH, digits = 1), "hours per colony", sep = " "))

print(paste("NF COLONIES: we watched an average of", round(avgNFnestH, digits = 1), "hours of NEST and", round(avgNFforH, digits = 1), "hours of FOR", sep = " "))
print(paste("NT COLONIES: we watched an average of", round(avgNTnestH, digits = 1), "hours of NEST and", round(avgNTforH, digits = 1), "hours of FOR", sep = " "))
print(paste("QF COLONIES: we watched an average of", round(avgQFnestH, digits = 1), "hours of NEST and", round(avgQFforH, digits = 1), "hours of FOR", sep = " "))
print(paste("QT COLONIES: we watched an average of", round(avgQTnestH, digits = 1), "hours of NEST and", round(avgQTforH, digits = 1), "hours of FOR", sep = " "))

# summary by nestID 
for (i in 1:nrow(camDur)) {
  print(paste(camDur$nestID[i], ": we watched a total of", round(camDur$nestLen[i]/60/60, digits = 1), "hours of NEST and", round(camDur$forLen[i]/60/60, digits = 1), "hours of FOR", sep = " "))
}
```
## calculate and graph total duration of video watched at each of the two timepoints (late and early) per nest
```{r}
# rename it so i can manipulate from here
totalLen_time <- totalLen_data
totalLen_time

# format date as date to do math on it
totalLen_time$dateID <- as.Date(totalLen_time$dateID, "%Y%m%d")

# add column for timepoint filled with NA values
totalLen_time$timepoint <- NA

# sort by nestID, then dateID
totalLen_time <- totalLen_time[order(totalLen_time$dateID),]
totalLen_time <- totalLen_time[order(totalLen_time$nestID),]
totalLen_time

# make empty early df
early_data <- data.frame(matrix(NA, nrow = 0, ncol = ncol(totalLen_time)))
## make column names the same
names(early_data) <- names(totalLen_time)

# make empty late df
late_data <- data.frame(matrix(NA, nrow = 0, ncol = ncol(totalLen_time)))
## make column names the same
names(late_data) <- names(totalLen_time)

# for a given nestID
for(i in 1:length(unique(totalLen_time$nestID))) {
  # make a temporary dataframe containing info from only that nest
  nestid_data <- totalLen_time[totalLen_time$nestID == unique(totalLen_time$nestID)[i],]
  # add first row to early_data
  early_data <- rbind(early_data, nestid_data[1,])
  # for each dateID
  for(j in 2:nrow(nestid_data)) {
    # if dateID is less than or equal to previous dateID + 2
    if(nestid_data$dateID[j] <= nestid_data$dateID[1] + 2) {
      #   move that row to early_data df
      early_data <- rbind(early_data, nestid_data[j,])
    }
    # if dateID is more than or equal to previous dateID + 4
    else if(nestid_data$dateID[j] >= nestid_data$dateID[1] + 4) {
      #   move that row to late_data df
      late_data <- rbind(late_data, nestid_data[j,])
    }
  }
}

early_data$timepoint <- "early"
late_data$timepoint <- "late"
totalLen_time <- rbind(early_data, late_data)
totalLen_time
# create empty dataframe to put length into
camDurTime <- data.frame(nestID = NA,
                      nestTYPE = NA,
                      early_forSum = NA,
                      late_forSum = NA,
                      early_nestSum = NA,
                      late_nestSum = NA)
# for each unique nest, subset the data to look at one nest at a time. then split out foraging and nest videos
for (i in 1:length(unique(totalLen_time$nestID))) {
  sub_data <- subset(totalLen_time, nestID == unique(totalLen_time$nestID)[i])       # subset to look at a single nest
  for_data <- subset(sub_data, sub_data$camID == "for")                        # subset foraging video only into for_data
  early_for_data <- subset(for_data, for_data$timepoint == "early")            # subset early foraging videos into early_for_data
  late_for_data <- subset(for_data, for_data$timepoint == "late")              # subset late foraging videos into late_for_data
  nest_data <- subset(sub_data, sub_data$camID == "nest")                      # subset nest video only into nest_data
  early_nest_data <- subset(nest_data, nest_data$timepoint == "early")         # subset early nest videos into early_nest_data
  late_nest_data <- subset(nest_data, nest_data$timepoint == "late")           # subset late nest videos into late_nest_data
  forSum <- sum(for_data$totalLen)                                             # sum the video duration of all foraging videos
  early_forSum <- sum(early_for_data$totalLen)                                 # sum the video duration of all early foraging videos
  late_forSum <- sum(late_for_data$totalLen)                                   # sum the video duration of all late foraging videos
  nestSum <- sum(nest_data$totalLen)                                           # sum the video duration of all nest videos
  early_nestSum <- sum(early_nest_data$totalLen)                               # sum the video duration of all early nest videos
  late_nestSum <- sum(late_nest_data$totalLen)                                      # sum the video duration of all late nest videos
  camDurTime <- rbind(camDurTime, c(sub_data$nestID[1], sub_data$nestTYPE[1], early_forSum, late_forSum, early_nestSum, late_nestSum, totalSum)) # add the sum totals to the camDurTime df
}

# remove NA row initially created
camDurTime <- camDurTime[2:nrow(camDurTime),]
camDurTime

# combine with camDur df and save for future analyses
camDur$earlyLen <- NA
camDur$lateLen <- NA
camDur$earlyFor <- NA
camDur$earlyNest <- NA
camDur$lateFor <- NA
camDur$lateNest <- NA
camDurTime$early_nestSum <- as.numeric(camDurTime$early_nestSum)
camDurTime$early_forSum <- as.numeric(camDurTime$early_forSum)
camDurTime$late_forSum <- as.numeric(camDurTime$late_forSum)
camDurTime$late_nestSum <- as.numeric(camDurTime$late_nestSum)
for (i in (1:nrow(camDur))) {
  for (j in (1:nrow(camDurTime))) {
    if (camDur$nestID[i] == camDurTime$nestID[j]) {
      camDur$earlyLen[i] <- camDurTime$early_forSum[j] + camDurTime$early_nestSum[j]
      camDur$lateLen[i] <- camDurTime$late_forSum[j] + camDurTime$late_nestSum[j]
      camDur$earlyFor[i] <- camDurTime$early_forSum[j]
      camDur$earlyNest[i] <- camDurTime$early_nestSum[j]
      camDur$lateFor[i] <- camDurTime$late_forSum[j]
      camDur$lateNest[i] <- camDurTime$late_nestSum[j]
    }
  }
}

# gather sums into a single column to graph together
camDurTime <- camDurTime %>%
  gather(early_nestSum, late_nestSum, early_forSum, late_forSum, 
         key = "videoType", 
         value = "length")

camDurTime$videoType <- factor(camDurTime$videoType, levels = c("early_forSum", "late_forSum", "early_nestSum", "late_nestSum"))
camDurTime$length <- as.numeric(camDurTime$length)

# proportion of early to late for NF
sumsTOTAL <- camDurTime %>%  filter(nestTYPE=="NF")
sumsTOTAL %>% ggplot(aes(x=nestID, y=length, fill=videoType)) + 
              geom_bar(stat="identity", position = position_dodge()) + 
              scale_fill_manual(values = c("blue", "darkblue", "green", "darkgreen")) +
              theme(axis.text.x = element_text(angle = 90), legend.position="top") + 
  ggtitle("duration of video watched for all NF filtered nests, regardless of video duration threshold")

# proportion of early to late for NT
sumsTOTAL <- camDurTime %>%  filter(nestTYPE=="NT")
sumsTOTAL$length <- as.numeric(sumsTOTAL$length)
sumsTOTAL %>% ggplot(aes(x=nestID, y=length, fill=videoType)) + 
              geom_bar(stat="identity", position = position_dodge()) + 
              scale_fill_manual(values = c("blue", "darkblue", "green", "darkgreen")) +
              theme(axis.text.x = element_text(angle = 90), legend.position="top") + 
  ggtitle("duration of video watched for all NT filtered nests, regardless of video duration threshold")

# proportion of early to late for QT
sumsTOTAL <- camDurTime %>%  filter(nestTYPE=="QT")
sumsTOTAL %>% ggplot(aes(x=nestID, y=length, fill=videoType)) + 
              geom_bar(stat="identity", position = position_dodge()) + 
              scale_fill_manual(values = c("blue", "darkblue", "green", "darkgreen")) +
              theme(axis.text.x = element_text(angle = 90), legend.position="top") + 
  ggtitle("duration of video watched for all QT filtered nests, regardless of video duration threshold")

# proportion of early to late for QF
sumsTOTAL <- camDurTime %>%  filter(nestTYPE=="QF")
sumsTOTAL %>% ggplot(aes(x=nestID, y=length, fill=videoType)) + 
              geom_bar(stat="identity", position = position_dodge()) + 
              scale_fill_manual(values = c("blue", "darkblue", "green", "darkgreen")) +
              theme(axis.text.x = element_text(angle = 90), legend.position="top") + 
  ggtitle("duration of video watched for all QF filtered nests, regardless of video duration threshold")

# all nests individually
sumsTOTAL <- camDurTime %>% group_by(nestID, videoType)
ggplot(sumsTOTAL, aes(x = nestID, y = length, fill = videoType)) +
  geom_bar(stat ="identity") + 
  scale_fill_manual(values = c("blue", "darkblue", "green", "darkgreen")) +
  theme(axis.text.x = element_text(angle = 90), legend.position = "top") + 
  ggtitle("duration of video watched for all filtered nests, regardless of video duration threshold")

# all nests by group
sumsTYPE <- camDurTime %>% group_by(nestTYPE)
ggplot(sumsTYPE, aes(x=nestTYPE, y = length, fill = videoType)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  scale_fill_manual(values = c("blue", "darkblue", "green", "darkgreen")) +
  theme(axis.text.x = element_text(angle = 90), legend.position = "top") + 
  ggtitle("duration of video watched for all filtered nests, regardless of video duration threshold")
```


## split count data by timepoint
obs_time and count_time have same format as obs_data and count_data but data split out by timepoint (early/late), excluding egg laying data
```{r}
# rename to clarify that this will be time-related
obs_time <- obs_data

# format dateID as a date
obs_time$dateID <- as.character(obs_time$dateID)
obs_time$dateID <- as.Date(obs_time$dateID, "%Y%m%d")

# add column for timepoint filled with NA values
obs_time$timepoint <- NA

# sort by nestID, then dateID
obs_time <- obs_time[order(obs_time$dateID),]
obs_time <- obs_time[order(obs_time$nestID),]
obs_time <- obs_time[!is.na(obs_time$dateID),]

# make empty early df
obs_timeearly <- data.frame(matrix(NA, nrow = 0, ncol = ncol(obs_time)))
# make column names the same as obs_time
names(obs_timeearly) <- names(obs_time)

# make empty late df
obs_timelate <- data.frame(matrix(NA, nrow = 0, ncol = ncol(obs_time)))
# make column names the same as obs_time
names(obs_timelate) <- names(obs_time)

# for a given nestID
for(i in 1:length(unique(obs_time$nestID))) {
  # make a temporary dataframe containing info from only that nest
  NDnestid_data <- obs_time[obs_time$nestID == unique(obs_time$nestID)[i],]
  # add first row to early_data
  obs_timeearly <- rbind(obs_timeearly, NDnestid_data[1,])
  # for each dateID
  if(nrow(NDnestid_data) > 1) {
      for(j in 2:nrow(NDnestid_data)) {
        # if dateID is less than or equal to previous dateID + 2
        if(NDnestid_data$dateID[j] <= NDnestid_data$dateID[1] + 2) {
          # move that row to early_data df
          obs_timeearly <- rbind(obs_timeearly, NDnestid_data[j,])
        }
        # if dateID is more than or equal to previous dateID + 4
        else if(NDnestid_data$dateID[j] >= NDnestid_data$dateID[1] + 4) {
          # move that row to late_data df
          obs_timelate<- rbind(obs_timelate, NDnestid_data[j,])}
      }
  }
}

# check to make sure all observations were accounted for
if (nrow(obs_time) == nrow(obs_timeearly) + nrow(obs_timelate)) {
  print("All observations are accounted for!")
} else {print("ERROR: THERE ARE MISSING OR EXTRA OBSERVATIONS")}

# add the timepoint to the obs_time column
obs_timeearly$timepoint <- "early"
obs_timelate$timepoint <- "late"

# rewrite obs_time with the timepoints included
obs_time <- rbind(obs_timeearly, obs_timelate)

# format to same as count_data & add back in additional information from count_data (eg, body size, ovary dev, etc)

# SAME CODE COPIED FROM COUNT_DATA CHUNK -- ADDED TIMEPOINT TO PIVOT_WIDER & SUBSET
# collapse the dataframe to count the number of instances doing each behavior
  # this outputs a new dataframe with columns nestID, nestTYPE, beeID, caste, natal, nectarforaging, feedsbrood, pollenforaging 
  # (and any other behaviors recorded), with counts for each behavior in as values
  # assumes rand number is not duplicated across individuals. 

# rename to count_time to reflect new format about to put into
count_time <- obs_time
# add a column with value 1 that counts the behavioral observations this makes each behavior a count of 1 
count_time$count <- 1  
# condense data frame into relevant columns, each row is a single observation for an individual
count_time <- count_time %>%
  pivot_wider(id_cols = c("nestID", "nestTYPE", "beeID", "caste", "natal", "beeType", "addDate", "diedDate", "timepoint", "behav"),
              names_from = rand, 
              values_from = count) 
count_time
# add column to fill with sum of counts for each behav
countCol1 <- 11 # firstcolumn containing counts
count_time$totCount <- rowSums(count_time[countCol1:ncol(count_time)], na.rm = TRUE)

# subset dataframe to remove random number generated columns (only want summary data)
count_time <- count_time %>%
  dplyr::select(nestID, nestTYPE, beeID, caste, natal, beeType, addDate, diedDate, timepoint, behav, totCount, timepoint)

# collapse dataframe so that each bee has one single row and behaviors are additional columns
count_time <- count_time %>%
  pivot_wider(id_cols = c("nestID", "nestTYPE", "beeID", "caste", "natal", "beeType", "addDate", "diedDate", "timepoint", "behav"),
              names_from = behav, 
              values_from = totCount)

# remove NA column
count_time <- count_time[ , !names(count_time) %in% c("NA")]

# replace NA values in behavioral count columns with 0
count_time[c("nectarforaging", "pollenforaging", "feedsbrood")] [is.na(count_time[c("nectarforaging", "pollenforaging", "feedsbrood")])] <- 0

# sum number of behaviors per bee per timepoint into nBehav column
count_time$nBehavs <- rowSums(count_time[, c("feedsbrood", "nectarforaging", "pollenforaging")], na.rm = TRUE)

# add in body size and ovary data from count_data
count_time$size <- NA
count_time$ovL1 <- NA
count_time$ovL2 <- NA
count_time$ovR1 <- NA
count_time$ovR2 <- NA
count_time$ovS1 <- NA
count_time$ovS2 <- NA

for (i in 1:nrow(count_time)){
  for (j in 1:nrow(count_data)){
    if (count_time$beeID[i] == count_data$beeID[j]) {
      count_time$size[i] <- count_data$size[j]
      count_time$ovL1[i] <- count_data$ovL1[j]
      count_time$ovL2[i] <- count_data$ovL2[j]
      count_time$ovR1[i] <- count_data$ovR1[j]
      count_time$ovR2[i] <- count_data$ovR2[j]
      count_time$ovS1[i] <- count_data$ovS1[j]
      count_time$ovS2[i] <- count_data$ovS2[j]
    }
  }
}

# add back in bees with 0 observations to count_time

# subset count_time to look only at early timepoint
count_timeEarly <- count_time[count_time$timepoint == "early",]
count_timeEarly
# pull out bee info from count_data for those bees that do not have observatitons at the early timepoint (this will bring in observations from late timepoint, remove those below)
count_noObsBeesEarly <- count_data %>% subset(!beeID %in% count_timeEarly$beeID)
count_noObsBeesEarly
# set timepoint for these bees to early
count_noObsBeesEarly$timepoint <- "early"
# subset count_time to look at only late timepoint
count_timeLate <- count_time[count_time$timepoint == "late",]
# pull out bee info from count_data for those bees that do not have observations at the late timepoint (this will bring in observations from early timepoint, remove those below)
count_noObsBeesLate <- count_data %>% subset(!beeID %in% count_timeLate$beeID)
# set timepoint for these bees to early
count_noObsBeesLate$timepoint <- "late"
# bind together the early and late no obs bees
count_noObsBeesTime <- rbind(count_noObsBeesEarly, count_noObsBeesLate)
# remove egglaying from the df
count_noObsBeesTime <- subset(count_noObsBeesTime, select = -c(egglaying) )
# set number of obs to 0 (any numbers >0 in this df are observations from the wrong timepoint, so we want to remove those here)
count_noObsBeesTime$nectarforaging <- 0
count_noObsBeesTime$feedsbrood <- 0
count_noObsBeesTime$pollenforaging <- 0
count_noObsBeesTime$nBehavs <- 0
# bind no obs bees to count_time that has obs bees
count_time <- rbind(count_time, count_noObsBeesTime)

# check that you have all the bees accounted for
if (nrow(count_time) == 2*nrow(count_data)) {
  print("all bees are accounted for at both timepoints in the count_time df!")
} else {print("ERROR: not all bees are accounted for in the count_time df")}

# if video for a given nest at a given timepoint does not exist, remove the bees from that nest at that timepoint from the count_time df

# define nests with no video at early timepoint
noVidEarly <- camDur$nestID[camDur$earlyLen == 0]
# define nests with no video at late timepoint
noVidLate <- camDur$nestID[camDur$lateLen == 0]
# remove corresponding rows from count_time
count_time <- subset(count_time, !(nestID %in% noVidEarly && timepoint == "early"))
count_time <- subset(count_time, !(nestID %in% noVidLate && timepoint == "late"))

# count how many total observations at each timepoint
print(paste(sum(count_time[count_time$timepoint == "early", "nBehavs"]), "total early observations", sep = " "))
print(paste(sum(count_time[count_time$timepoint == "late", "nBehavs"]), "total late observations", sep = " "))
print(paste(sum(count_time[count_time$timepoint == "early", "nectarforaging"]), "early nectar foraging observations", sep = " "))
print(paste(sum(count_time[count_time$timepoint == "early", "pollenforaging"]), "early pollen foraging observations", sep = " "))
print(paste(sum(count_time[count_time$timepoint == "early", "feedsbrood"]), "early brood feeding observations", sep = " "))
print(paste(sum(count_time[count_time$timepoint == "late", "nectarforaging"]), "late nectar foraging observations", sep = " "))
print(paste(sum(count_time[count_time$timepoint == "late", "pollenforaging"]), "late pollen foraging observations", sep = " "))
print(paste(sum(count_time[count_time$timepoint == "late", "feedsbrood"]), "late brood feeding observations", sep = " "))

```

#.

# Filter Data

## filter all data based on nest with threshold duration of video watched
    filter to include only nests that have passed a threshold amount of video watched
```{r}
# set threshold for required seconds of foraging video watched
forThres <- 0
# set threshold for required seconds of nest video watched
nestThres <- 0

# filter camDur to include nests that pass both thresholds
camDur_filt <- camDur[camDur$forLen >= forThres, ]
# and a minimum of 2000 nest
camDur_filt <- camDur_filt[camDur_filt$nestLen >= nestThres, ]
camDur_filt
# check how many nests were removed
print(paste(nrow(camDur) - nrow(camDur_filt), "out of", nrow(camDur), "nests were removed due to insufficient video length, leaving", nrow(camDur_filt), "remaining nests for analyses", sep = " "))
```
### visualize and filter obs, count, and camDur data based on duration
write obs_data
write obs_time
*write count_data
*write count_time
write camDur
```{r}
# graph amount of video watched from only fitered nests
sumsTOTAL <- sumsTOTAL %>% subset(nestID %in% camDur_filt$nestID)
ggplot(sumsTOTAL, aes(x = nestID, y = length, fill = videoType)) +
  geom_bar(stat ="identity") + 
  scale_fill_manual(values = c("blue", "darkblue", "green", "darkgreen")) +
  theme(axis.text.x = element_text(angle = 90), legend.position = "top") + 
  ggtitle("duration of video watched for nests with video duration above threshold")

# FILTER

# filter obs_data and save for future analyses
obs_data <- obs_data %>% subset(nestID %in% camDur_filt$nestID)
write.csv(obs_data, "../Data/filtData/obs_data.csv")
# each observation is a single row
# every bee (including unknown and unobserved bees) is accounted for

# filter count_data and save for future analyses
count_data <- count_data %>% subset(nestID %in% camDur_filt$nestID)
# make nestTYPE a factor
count_data$nestTYPE <- ordered(count_data$nestTYPE, levels = c("NT", "NF", "QT", "QF"))

# filter count_time
count_time <- count_time %>% subset(nestID %in% camDur_filt$nestID)
count_time$nestTYPE <- ordered(count_time$nestTYPE, levels = c("NT", "NF", "QT", "QF"))

# filter obs_time
obs_time <- obs_time %>% subset(nestID %in% camDur_filt$nestID)
write.csv(obs_time, "../Data/filtData/obs_time.csv")
# obs_time split out by timepoint
# each bee has 0-many rows
# only includes bees with at least one observation (including unknown bees)
# columns same as obs_data

# save already filtered camDur for future analyses
write.csv(camDur_filt, "../Data/filtData/camDur.csv")
# each nest is a row
# columns include foraging length, nest length, total length, F:N ratio, and nestTYPE
```

## filter nest data based on number of observations
for nest-level analyses (eg., task specialization): filter out nests below threshold number of observations each of brood feeding and foraging behaviors, includes unknown worker observations
write obs_nests
write count_nests
```{r}
# first combine pollen and nectar foraging into a single value
count_data$allforaging <- count_data$nectarforaging + count_data$pollenforaging

# gather broodfeeding and foraging behaviors into a single column so we can summarize based on number of observations
counts_gathered <- count_data %>% gather("feedsbrood", "allforaging", key = "behav", value = "count")

# summarize the number of observations per nest to enable filtering
sumNest <- ddply(counts_gathered, 
                c("nestID", "behav"), 
                summarise,
                nObs = sum(count),
                mean = mean(count), 
                sd = sd(count),
                sem = sd(count)/sqrt(length(count)))

# remove nests with fewer than threshold number of observations of both foraging and brood feeding

# count how many nests we start with before filtering
initNests <- length(unique(sumNest$nestID))
# set the threshold below which we remove data
obsThres <- 3
# filter out nests with < threshold brood feeding or foraging
rmNests <- sumNest[sumNest$nObs < obsThres,]
count_nests <- count_data %>% filter(!nestID %in% rmNests$nestID)
# count and print how many nests we have after filtering
filtNests <- length(unique(count_nests$nestID))
print(paste("the following", initNests - filtNests, "nests were filtered out of the data because they have fewer than the threshold number of brood feeding or foraging behaviors recorded", sep = " "))
unique(rmNests$nestID)

# save for future analyses
write.csv(count_nests, "../Data/filtData/count_nests.csv")

# filter obs_data to obs_nests for future analyses
obs_nests <- obs_data %>% subset(nestID %in% count_nests$nestID)
write.csv(obs_nests, "../Data/filtData/obs_nests.csv")
```
### visualize filtered count_nests
```{r}
# gather all behaviors into a single column
countsFilt_gathered <- count_nests %>% gather("feedsbrood", "allforaging", key = "behav", value = "count")
countsFilt_gathered

# summarize and graph the total number behaviors observed across all individuals
statsBehavFilt <- ddply(countsFilt_gathered, 
                c("behav"), 
                summarise,
                nObs = sum(count),
                mean = mean(count), 
                sd = sd(count),
                sem = sd(count)/sqrt(length(count)))
ggplot(statsBehavFilt, aes(x = behav, y = nObs, fill = behav)) + geom_bar(stat = "identity")

# summarize and graph the total number behaviors observed for each filtered nest
statsNestFilt <- ddply(countsFilt_gathered, 
                c("nestID", "behav"), 
                summarise,
                nObs = sum(count),
                mean = mean(count), 
                sd = sd(count),
                sem = sd(count)/sqrt(length(count)))
statsNestFilt
ggplot(statsNestFilt, aes(x = nestID, y = nObs, fill = behav)) + 
  geom_bar(stat = "identity") + 
  theme(axis.text.x = element_text(angle = 90), legend.position = "top")
```
## filter nest data at early and late timepoints
nests with threshold number of observations at early OR late timepoints
write count_nestsTime
```{r}
# first combine pollen and nectar foraging into a single value
count_time$allforaging <- count_time$nectarforaging + count_time$pollenforaging

# gather broodfeeding and foraging behaviors into a single column so we can summarize based on number of observations
counts_gatheredTime <- count_time %>% gather("feedsbrood", "allforaging", key = "behav", value = "count")

# summarize the number of observations per nest to enable filtering
sumNestTime <- ddply(counts_gatheredTime, 
                c("nestID", "behav", "timepoint"), 
                summarise,
                nObs = sum(count),
                mean = mean(count), 
                sd = sd(count),
                sem = sd(count)/sqrt(length(count)))

# split into early and late
sumNestEarly <- sumNestTime[sumNestTime$timepoint == "early",]
sumNestLate <- sumNestTime[sumNestTime$timepoint == "late",]

# remove nests with fewer than threshold number of observations of both foraging and brood feeding

# count how many nests we start with before filtering
initNestsEarly <- length(unique(sumNestEarly$nestID))
initNestsLate <- length(unique(sumNestLate$nestID))
# set the threshold below which we remove data
obsThres <- 3
# subset which nests have < threshold brood feeding or foraging
rmNestsEarly <- sumNestEarly[sumNestEarly$nObs < obsThres,]
rmNestsLate <- sumNestLate[sumNestLate$nObs < obsThres,]
# filter out those nests with < threshold
count_nestsEarly <- count_time[count_time$timepoint == "early",] %>% filter(!nestID %in% rmNestsEarly$nestID)
count_nestsLate <- count_time[count_time$timepoint == "late",] %>% filter(!nestID %in% rmNestsLate$nestID)
# count and print how many nests we have after filtering
filtNestsEarly <- length(unique(count_nestsEarly$nestID))
filtNestsLate <- length(unique(count_nestsLate$nestID))
print(paste("the following", initNestsEarly - filtNestsEarly, "early nests were filtered out of the data because they have fewer than the threshold number of brood feeding or foraging behaviors recorded", sep = " "))
unique(rmNestsEarly$nestID)
print(paste("the following", initNestsLate - filtNestsLate, "late nests were filtered out of the data because they have fewer than the threshold number of brood feeding or foraging behaviors recorded", sep = " "))
unique(rmNestsLate$nestID)

# save for future analyses
count_nestsTime <- rbind(count_nestsEarly, count_nestsLate)
write.csv(count_nestsTime, "../Data/filtData/count_nestsTime.csv")
```

#.
#.
#.

# Calculate Shannon Indices

## bee shannon
add shannon column to count_data df for bees with > threshold number of behaviors
```{r}
# start with matrix where each row is an individual, and each column is a behavior
beeShan <- as.matrix(count_data[,c("nectarforaging", "feedsbrood", "pollenforaging", "egglaying")])

# make a column to enter shannon into dol df
count_data$shannon <- NA
# calculate shannon for each bee in the matrix and add to shannon column
count_data$shannon <- diversity(beeShan, index = "shannon") 

# make shannon NA for bees with less than threshold number of behaviors - we only want to include bees with above a threshold number in analyses
obsThres <- 3
count_data$shannon[count_data$nBehavs < obsThres] <- NA
# make shannon NA for unidentified bees - we don't want to inclue these in analyses
count_data[grepl("unknown", count_data$beeID), "shannon"] <- NA

# check how many bees have fewer than threshold number of observations and therefore will not be included in analyses
print(paste(nrow(count_data[is.na(count_data$shannon),]), "bees are unknown or have fewer than the threshold number of recorded behaviors and therefore have an NA shannon value", sep = " "))
print(paste(nrow(count_data[!is.na(count_data$shannon),]), "bees have equal or greater than the threshold number of recorded behaviors and will be included in shannon analyses"))

# plot density of shannons vs nestTYPE and as sum total together
ggplot(count_data, aes(shannon, fill = nestTYPE)) + 
  geom_density(alpha = 0.3)

ggplot(count_data, aes(shannon, fill = nestTYPE)) + 
  geom_histogram(color = "black", alpha = 0.4)

# plot nestTYPE vs. shannon scatterplot
ggplot(count_data, aes(shannon, nestTYPE, color = nestTYPE, shape = caste)) +
  geom_point(position = position_jitter(width=0.05, height=0.2), alpha = 0.5) +
  scale_shape_manual(values = c(21, 16)) +
  stat_summary(fun = mean, geom = "point", size = 5)
ggsave("../figures/shannon.jpg")

# plot number of behaviors vs. shannon scatterplot
ggplot(count_data, aes(shannon, nBehavs, color = nestTYPE, shape = caste)) +
  geom_point(position = position_jitter(width=0.05, height=1), alpha = 0.8, size = 2) +
  scale_shape_manual(values = c(21, 16))
ggsave("../figures/shannonVSnBehavs.jpg")

# separate out known bees to get summary data
count_known <- count_data[!grepl("unknown", count_data$beeID), ]

# print the number of bees that meet the shannon threshold as well as the bees that do not
print(paste(nrow(count_known[!is.na(count_known$shannon),]), "out of", nrow(count_known), "known bees have over the threshold number of behaviors and will therefore be included in shannon analyses", sep = " "))

print(paste(nrow(count_known[count_known$nBehav == 0,]), "out of", nrow(count_known), "known bees 0 recorded behaviors", sep = " "))

print(paste(nrow(count_known[count_known$nBehav == 1,]), "out of", nrow(count_known), "known bees 1 recorded behaviors", sep = " "))

print(paste(nrow(count_known[count_known$nBehav == 2,]), "out of", nrow(count_known), "known bees 2 recorded behaviors", sep = " "))

count_known[count_known$shannon > 1.24, ]
# print the max shannon value
print(paste("the max shannon value for all bees with over the threshold number of behaviors is", max(count_known$shannon, na.rm = TRUE), sep = " "))
count_known[count_known$shannon > 1.24, ]

# print the number of perfect specialists (shannon = 0)
print(paste("there are", nrow(count_known[count_known$shannon == 0, ]) - nrow(count_known[is.na(count_known$shannon),]), "perfectly specialized bees with a shannon value of 0 out of", nrow(count_known), "total bees", sep = " "))

count_known[count_known$shannon == 0,]
```
### bee shannon over time
add shannon and shanDist columns to count_time df for bees with > threshold number of behaviors
```{r}
count_time

# convert to matrix of behaviors to be used in shannon
beeShanTime <- as.matrix(count_time[,c("feedsbrood", "nectarforaging", "pollenforaging")])

# calculate shannon for each bee in the matrix
count_time$shannon <- diversity(beeShanTime, index = "shannon") 

# make shannon NA for bees with less than threshold number of behaviors - we only want to include bees with above a threshold number in analyses
# threshold defined in bee shannon chunk
count_time$shannon[count_time$nBehavs < obsThres] <- NA
# make shannon NA for unidentified bees - we don't want to inclue these in analyses
count_time[grepl("unknown", count_time$beeID), "shannon"] <- NA

# plot shannon values by timepoint
ggplot(count_time, aes(shannon, nestTYPE, shape = interaction(caste, timepoint), fill = nestTYPE, color = nestTYPE)) + 
  geom_point(position = position_jitter(width=0.15, height=0.2), alpha = 0.8) +
  scale_shape_manual(values = c(15, 17, 0, 6)) +
  stat_summary(fun = mean, geom = "point", size = 5)
ggsave("../figures/shannonTime.jpg")

# find change in shannon over time per bee

# add shanDist column to put distance into
count_time$shanDist <- NA

# check how many bees have fewer than threshold number of observations at each timepoint and therefore will not be included in analyses for that timepoint
# early timepoint
count_timeEarly <- count_time[count_time$timepoint == "early",]
count_timeLate <- count_time[count_time$timepoint == "late",]

print(paste(nrow(count_timeEarly[is.na(count_timeEarly$shannon),]), "early bees are unknown or have fewer than the threshold number of recorded behaviors and therefore have an NA shannon value", sep = " "))
print(paste(nrow(count_timeLate[is.na(count_timeLate$shannon),]), "late bees are unknown or have fewer than the threshold number of recorded behaviors and therefore have an NA shannon value", sep = " "))
print(paste(nrow(count_timeEarly[!is.na(count_timeEarly$shannon),]), "early bees have equal or greater than the threshold number of recorded behaviors and will be included in shannon analyses"))
print(paste(nrow(count_timeLate[!is.na(count_timeLate$shannon),]), "late bees have equal or greater than the threshold number of recorded behaviors and will be included in shannon analyses"))

# calculate change and add to shanDist column (this will only add the value to the late timepoint row for a given bee)
for (i in 1:nrow(count_time)) {                                                   # for each row in the dataset
  if(count_time$timepoint[i] == "late") {                                         # look at the the late bees only
    for (j in 1:nrow(count_time)) {                                               # then iterate back through the dataset
      if(count_time$timepoint[j] == "early" & count_time$beeID[j] == count_time$beeID[i]) {   # and find the early entry with the same bee ID
        count_time$shanDist[i] <- count_time$shannon[i] - count_time$shannon[j]               # calculate the difference in shannon index across time
      }
    }
  }
}

# plot the change in shannon from early to late
ggplot(count_time, aes(shanDist, fill = nestTYPE)) + 
  geom_density(alpha = 0.3)

avgShannDist <- count_time %>% dplyr::summarize(avg = mean(shanDist, na.rm = T)) %>% dplyr::pull(avg)

ggplot(count_time, aes(shanDist, nestTYPE, color = nestTYPE, shape = caste)) +
  geom_point(position = position_jitter(width=0.1, height=0.2), alpha = 0.5) +
  scale_shape_manual(values = c(21, 16)) +
  stat_summary(fun = mean, geom = "point", size = 5) +
  geom_vline(aes(xintercept = avgShannDist), color = "gray70", size = 0.6) +
  labs(x = "change in shannon index from early to late timepoint")
ggsave("../figures/shanDist.jpg")

# look at how many bees it's actually plotting here -- ~10 per nestTYPE
print(paste(nrow(count_time[!is.na(count_time$shanDist),]), "known bees have over the threshold number of behaviors at both the early and late timepoints, and will therefore be included in shannon distance analyses", sep = " "))

nonNA_time <- count_time[!is.na(count_time$shannon),] 
print(paste(nrow(nonNA_time[nonNA_time$timepoint == "early",]), "early bees that meet the shannon threshold", sep = " "))
print(paste(nrow(nonNA_time[nonNA_time$timepoint == "late",]), "late bees that meet the shannon threshold", sep = " "))

count_time[!is.na(count_time$shanDist),]
nonNA_time
```

## bee specialization
add specBehav and specProp columns to count_data df
count number of specialists per nest
write count_data
write nSpecialists
```{r}
# define shannon threshold under which represents a specialist
shannonSpecialist <- 0.6

# define number of columns before behaviors in the count_data df
skip <- 8
# make a column for behavioral specialization
count_data$specBehav <- NA
count_data$specProp <- NA

for (i in 1:nrow(count_data)) {
  # if the bee has fewer than threshold number of obs (shannon is NA)
  if (is.na(count_data$shannon[i])) {
    # name the behavior as lazy
    count_data$specBehav[i] <- "lazy"
    # kepp proportion as NA
    count_data$specProp[i] <- NA
  }
  # if the bee is a specialist (i.e. shannon <= threshold)
  else if (count_data$shannon[i] <= shannonSpecialist) {
    # name the behavior that each individual specialized in: column index of max number of behaviors + skip columns
    behavior <- names(count_data[skip + max.col(count_data[i, c("nectarforaging", "feedsbrood", "pollenforaging", "egglaying")])])
    # input that behavior into specBehav column
    count_data$specBehav[i] <- behavior
    # calculate proportion of total behaviors comprised by specialized behavior
    count_data$specProp[i] <- count_data[i, behavior] / count_data$nBehavs[i]
  }
  # if the bee is not a specialist (i.e. shannon < threshold)
  else if (count_data$shannon[i] > shannonSpecialist) {
    # name the behavior as generalist
    count_data$specBehav[i] <- "generalist"
    # keep proportion as NA
    count_data$specProp[i] <- NA
  }
}

# check the minimum proportion of behaviors carried out by specialists for this given shannon threshold
count_data$specProp <- as.numeric(count_data$specProp)
minSpecProp <- min(count_data$specProp, na.rm = TRUE)
print(paste0("With a shannon specialist cutoff of ", shannonSpecialist, ", the specialized behavior comprises ", minSpecProp, " to 100% of all behaviors carried out by a given individual."))

# save for future analyses
write.csv(count_data, "../Data/filtData/count_data.csv")


####

# count number of specialists in each category per nest
# make empty matrix to put number into
nSpec <- matrix(NA, ncol = 3, nrow = length(unique(count_data$nestID))*6)
# convert to df
nSpec <- as.data.frame(nSpec)
# name columns relevant info
colnames(nSpec) <- c("nestID", "specBehav", "nBeesPerNest")
# repeat the behaviors over in specBehav column
nSpec$specBehav <- c("nectarforaging", "feedsbrood", "pollenforaging", "egglaying", "generalist", "lazy")
# set number of specialists to 0
nSpec$nBeesPerNest <- 0
# fill nestID with 5x each nest id (one for each behavior)
for (i in 0:(length(unique(count_data$nestID))-1)) {
  nSpec$nestID[((i * 6) + 1):((i + 1) * 6)] <- unique(count_data$nestID)[i + 1]
}
# replace number of bees with accurate number
# first summarize 
nSpec_missing0 <- count_data %>% dplyr::group_by(nestID, nestTYPE, specBehav) %>% dplyr::summarise(nBeesPerNest = dplyr::n())
nSpec_missing0

# for each line in nSpec_missing0
for (i in 1:nrow(nSpec_missing0)) {
  # iterate through the nSpec df
  for (j in 1:nrow(nSpec)) {
    # until you find matching nestID and specBehav comb
    if (nSpec_missing0$nestID[i] == nSpec$nestID[j] && nSpec_missing0$specBehav[i] == nSpec$specBehav[j]) {
      # copy number of bees per nest into nSpec
      nSpec$nBeesPerNest[j] <- nSpec_missing0$nBeesPerNest[i]
      } else {}
  }
}
nSpec
nSpec$nestTYPE <- substr(nSpec$nestID, start = 1, stop = 2)
nSpec$nestTYPE <- ordered(nSpec$nestTYPE, levels = c("NT", "QT", "NF", "QF"))
nSpec$specBehav <- ordered(nSpec$specBehav, levels = c("lazy", "generalist", "pollenforaging", "nectarforaging", "feedsbrood", "egglaying"))


write.csv(nSpec, "../Data/filtData/nSpecialists.csv")

ggplot(nSpec, aes(nBeesPerNest, specBehav)) +
  geom_point(position = position_jitter(width=0.15, height=0.2), alpha = 0.9, aes(color = nestTYPE)) +
  stat_summary(fun = mean, geom = "point", size = 5)
ggsave("../figures/nSpecialists.jpg")
```
### bee specialization over time 
add specBehav and specProp columns to count_time df
write count_time
write nSpecialistsTime
```{r}
count_time

# define number of behaviors in the count_time df before behaviors
skip <- 9
# make a column for behavioral specialization
count_time$specBehav <- NA
count_time$specProp <- NA

for (i in 1:nrow(count_time)) {
   # if the bee has fewer than threshold number of obs (shannon is NA)
  if (is.na(count_time$shannon[i])) {
    # name the behavior as lazy
    count_time$specBehav[i] <- "lazy"
    # kepp proportion as NA
    count_time$specProp[i] <- NA
  }
  # if the bee is a specialist (i.e. shannon <= threshold)
  else if (count_time$shannon[i] <= shannonSpecialist) {
    # name the behavior that each individual specialized in: column index of max number of behaviors + skip columns
    behavior <- names(count_time[skip + max.col(count_time[i, c("nectarforaging", "feedsbrood", "pollenforaging")])])
    # input that behavior into specBehav column
    count_time$specBehav[i] <- behavior
    # calculate proportion of total behaviors comprised by specialized behavior
    count_time$specProp[i] <- count_time[i, behavior] / count_time$nBehavs[i]
  }
  # if the bee is not a specialist (i.e. shannon < threshold)
  else if (count_time$shannon[i] > shannonSpecialist) {
    # name the behavior as generalist
    count_time$specBehav[i] <- "generalist"
    # keep proportion as NA (do nothing)
  }
}

# check the minimum proportion of behaviors carried out by specialists for this given shannon threshold
count_time$specProp <- as.numeric(count_time$specProp)
minSpecProp <- min(count_time$specProp, na.rm = TRUE)
print(paste0("With a shannon specialist cutoff of ", shannonSpecialist, ", the specialized behavior comprises ", minSpecProp, " to 100% of all behaviors carried out by a given individual."))

# write for future analyses
write.csv(count_time, "../Data/filtData/count_time.csv")

####

# count number of specialists in each category per nest

# define number of behavioral specialist categories
nCat <- 5
# make empty matrix to put number into
nSpecTime <- matrix(NA, ncol = 5, nrow = length(unique(count_time$nestID))*2*nCat)
# convert to df
nSpecTime <- as.data.frame(nSpecTime)
# name columns relevant info
colnames(nSpecTime) <- c("nestID", "nestTYPE", "timepoint", "specBehav", "nBeesPerNest")
# repeat the behaviors over in specBehav column
nSpecTime$specBehav <- c("nectarforaging", "feedsbrood", "pollenforaging", "generalist", "lazy", "nectarforaging", "feedsbrood", "pollenforaging", "generalist", "lazy")
# repeat the timepoints over in timepoint column
nSpecTime$timepoint <- c("early", "early", "early", "early", "early", "late", "late", "late", "late", "late")
# set number of specialists to 0
nSpecTime$nBeesPerNest <- 0
# fill nestID with nCat x each nest id (one for each behavior)
for (i in 0:(length(unique(count_time$nestID))-1)) {
  nSpecTime$nestID[((i * 2 * nCat) + 1):((i + 1) * 2 * nCat)] <- unique(count_time$nestID)[i + 1]
}
# replace number of bees with accurate number
# first summarize 
nSpecTime_missing0 <- count_time %>% dplyr::group_by(nestID, nestTYPE, specBehav, timepoint) %>% dplyr::summarise(nBeesPerNest = dplyr::n())
nSpecTime_missing0

# for each line in nSpecTime_missing0
for (i in 1:nrow(nSpecTime_missing0)) {
  # iterate through the nSpecTime df
  for (j in 1:nrow(nSpecTime)) {
    # until you find matching nestID and specBehav comb
    if (nSpecTime_missing0$nestID[i] == nSpecTime$nestID[j] && nSpecTime_missing0$specBehav[i] == nSpecTime$specBehav[j] && nSpecTime_missing0$timepoint[i] == nSpecTime$timepoint[j]) {
      # copy number of bees per nest into nSpecTime
      nSpecTime$nBeesPerNest[j] <- nSpecTime_missing0$nBeesPerNest[i]
      } else {}
  }
}

nSpecTime$nestTYPE <- substr(nSpecTime$nestID, start = 1, stop = 2)
nSpecTime$nestTYPE <- ordered(nSpecTime$nestTYPE, levels = c("NT", "QT", "NF", "QF"))
nSpecTime$specBehav <- ordered(nSpecTime$specBehav, levels = c("lazy", "generalist", "pollenforaging", "nectarforaging", "feedsbrood", "egglaying"))
nSpecTime

write.csv(nSpecTime, "../Data/filtData/nSpecialistsTime.csv")

ggplot(nSpecTime, aes(nBeesPerNest, specBehav, shape = timepoint)) +
  geom_point(position = position_jitter(width=0.18, height=0.2), alpha = 0.7, aes(color = nestTYPE)) +
  scale_shape_manual(values = c(17, 25)) +
  stat_summary(fun = mean, geom = "point", size = 5)
ggsave("../figures/nSpecialistsTIME.jpg")
```

## task shannon
add shannon column to count_nests df
 ** do we need to include bees that did not carry out any behaviors here? with a 0 value for count?
write taskShan
```{r}
count_nests

# make df to put shannon values into
taskShan <- matrix(NA, ncol = 4)
taskShan <- as.data.frame(taskShan)
colnames(taskShan) <- c("nestID", "behav", "shannon", "nBehav")
taskShan$shannon <- NA

# make submatrix for each nest, transpose it so that behaviors are rows and individuals are columns, and calculate shannon for each behavior for each nest
for(index in 1:length(unique(count_nests$nestID))) {            # for each unique nestID in the dataset
  nest_df <- count_nests[count_nests$nestID == unique(count_nests$nestID)[index], ]   # subset to look only at that nestID
  nest_m <- as.matrix(nest_df[,c("feedsbrood", "nectarforaging", "pollenforaging", "egglaying")]) # convert to matrix of behaviors for that nest ID
  if (nrow(nest_df) < 2) {                                          # if there are less than 2 rows in the matrix (i.e. fewer than 2 individuals carrying out a given behavior)
    nest_m <- rbind(nest_m, c(0, 0, 0, 0))                          # add a row of zeros so that when you transpose it, it stays as a matrix with multiple columns
  }
  nest_m <- t(nest_m)                                               # transpose the matrix so that behaviors are now rows and individuals are columns
  nest_m <- nest_m[rowSums(nest_m) > 0,, drop = FALSE]              # remove behaviors without any observations
  nestShan <- matrix(NA, ncol = 4, nrow = nrow(nest_m))             # make a nest-specific matrix to put shannon values into
  nestShan <- as.data.frame(nestShan)                               # turn it into a df
  colnames(nestShan) <- colnames(taskShan)                          # name columns same as the taskShan df
  shannon <- diversity(nest_m, index = "shannon")                   # calculate shannon for each behavior in the nest
  nestShan$behav <- rownames(nest_m)                                # add the name of each behavior to the nestShan df
  nestShan$shannon <- shannon                                       # add the corresponding shannon score for each behavior
  nestShan$nBehav <- rowSums(nest_m)                                # sum the number of observations of each behavior
  nestShan$nestID <- unique(count_nests$nestID)[index]              # copy nestID into the nestShan df
  taskShan <- rbind(taskShan, nestShan)                             # add the nest-specific df to the overall task df
}

# add nestTYPE column
taskShan$nestTYPE <- substr(taskShan$nestID, start = 1, stop = 2)
# remove na row
taskShan <- taskShan[!is.na(taskShan$shannon),]
max(taskShan$shannon)
count_data[count_data$nestID == "QF06",]
#add natalcolony column 
nataladd<-count_nests %>% select(nestID, natal)
write.csv(nataladd, "../Data/nataladd.csv")
taskshanNatal<-left_join(taskShan, nataladd,  by="nestID")

# write the file for future analyses
write.csv(taskshanNatal, "../Data/filtData/taskShan.csv")

# plot it
ggplot(taskShan, aes(shannon, behav)) +
  geom_point(position = position_jitter(width=0.05, height=0.2), alpha = 0.9, aes(color = nestTYPE)) +
  stat_summary(fun = mean, geom = "point", size = 5)
ggsave("../figures/taskShan.jpg")

# plot degree of specialization against number of observations
ggplot(taskShan, aes(shannon, nBehav, color = behav, shape = nestTYPE)) +
  geom_point(position = position_jitter(width=0.1, height=0.1), alpha = 0.9, size = 1.8) +
  scale_shape_manual(values = c(16, 15, 21, 22))
ggsave("../figures/taskShanVSnBehavs.jpg")

# print the number of nests that meet the shannon threshold
print(paste(length(unique(taskShan$nestID)), "nests have over the threshold number of behaviors and will therefore be included in task shannon analyses", sep = " "))

# print the number of perfectly specialized tasks (shannon = 0)
print(paste("there are", nrow(taskShan[taskShan$shannon == 0, ]), "perfectly specialized tasks with a shannon value of 0 out of", nrow(taskShan), "total task-nest combinations", sep = " "))
taskShan
```
### task shannon over time
write taskShanTime
```{r}
count_nestsTime

# make df to put shannon values into
taskShanTime <- matrix(NA, ncol = 5)
taskShanTime <- as.data.frame(taskShanTime)
colnames(taskShanTime) <- c("nestID", "behav", "shannon", "nBehav", "timepoint")
taskShanTime$shannon <- NA

# make submatrix for each nest, transpose it so that behaviors are rows and individuals are columns, and calculate shannon for each behavior for each nest
for(index in 1:length(unique(count_nestsTime$nestID))) {            # for each unique nestID in the dataset
  nest_df <- count_nestsTime[count_nestsTime$nestID == unique(count_nestsTime$nestID)[index], ]   # subset to look only at that nestID
  nest_mE <- as.matrix(nest_df[nest_df$timepoint == "early", c("feedsbrood", "nectarforaging", "pollenforaging")]) # convert to matrix of early behaviors for that nest ID
  nest_mL <- as.matrix(nest_df[nest_df$timepoint == "late", c("feedsbrood", "nectarforaging", "pollenforaging")]) # convert to matrix of late behaviors for that nest ID
  # EARLY
  if (nrow(nest_mE) == 1) {                                         # if there is only 1 row in the matrix (i.e. only 1 individual carrying out a given behavior)
    nest_mE <- rbind(nest_mE, c(0, 0, 0, 0))                        # add a row of zeros so that when you transpose it, it stays as a matrix with multiple columns
  } 
  if (nrow(nest_mE) == 0) {                                         # if late timepoint doesn't exist, print that there are 0 early observations in that nest 
      print(paste("there are 0 early observations for nest", unique(taskShanTime$nestID)[index]))
  }
  if (nrow(nest_mE) > 1) {                                          # if early timepoint exists, do stuff
    nest_mE <- t(nest_mE)                                           # transpose the matrix so that behaviors are now rows and individuals are columns
    nest_mE <- nest_mE[rowSums(nest_mE) > 0,, drop = FALSE]         # remove behaviors without any observations
    nestShanE <- matrix(NA, ncol = 5, nrow = nrow(nest_mE))         # make a nest-specific matrix to put shannon values into
    nestShanE <- as.data.frame(nestShanE)                           # turn it into a df
    colnames(nestShanE) <- colnames(taskShanTime)                   # name columns same as the taskShanTime df
    shannon <- diversity(nest_mE, index = "shannon")                # calculate shannon for each behavior in the nest
    nestShanE$behav <- rownames(nest_mE)                            # add the name of each behavior to the nestShanE df
    nestShanE$shannon <- shannon                                    # add the corresponding shannon score for each behavior
    nestShanE$nBehav <- rowSums(nest_mE)                            # sum the number of observations of each behavior
    nestShanE$nestID <- unique(count_nestsTime$nestID)[index]       # copy nestID into the nestShanE df
    nestShanE$timepoint <- "early"                                  # add timepoint
    taskShanTime <- rbind(taskShanTime, nestShanE)                  # add the nest-specific df to the overall task df
  }
  # LATE
  if (nrow(nest_mL) == 1) {                                         # if there is only 1 row in the matrix (i.e. only 1 individual carrying out a given behavior)
    nest_mL <- rbind(nest_mL, c(0, 0, 0, 0))                        # add a row of zeros so that when you transpose it, it stays as a matrix with multiple columns
  } 
  if (nrow(nest_mL) == 0) {                                         # if late timepoint doesn't exist, print that there are 0 early observations in that nest 
    print(paste("there are 0 late observations for nest", unique(taskShanTime$nestID)[index]))
  }
  if (nrow(nest_mL) > 1) {                                          # if early timepoint exists, do stuff
    nest_mL <- t(nest_mL)                                           # transpose the matrix so that behaviors are now rows and individuals are columns
    nest_mL <- nest_mL[rowSums(nest_mL) > 0,, drop = FALSE]         # remove behaviors without any observations
    nestShanL <- matrix(NA, ncol = 5, nrow = nrow(nest_mL))         # make a nest-specific matrix to put shannon values into
    nestShanL <- as.data.frame(nestShanL)                           # turn it into a df
    colnames(nestShanL) <- colnames(taskShanTime)                   # name columns same as the taskShanTime df
    shannon <- diversity(nest_mL, index = "shannon")                # calculate shannon for each behavior in the nest
    nestShanL$behav <- rownames(nest_mL)                            # add the name of each behavior to the nestShanL df
    nestShanL$shannon <- shannon                                    # add the corresponding shannon score for each behavior
    nestShanL$nBehav <- rowSums(nest_mL)                            # sum the number of observations of each behavior
    nestShanL$nestID <- unique(count_nestsTime$nestID)[index]       # copy nestID into the nestShanL df
    nestShanL$timepoint <- "late"                                   # add timepoint
    taskShanTime <- rbind(taskShanTime, nestShanL)                  # add the nest-specific df to the overall task df
  }
}
taskShanTime

# add nestTYPE column
taskShanTime$nestTYPE <- substr(taskShanTime$nestID, start = 1, stop = 2)
# remove na row
taskShanTime <- taskShanTime[!is.na(taskShanTime$shannon),]

#add natalcolony column 
nataladd<-count_nests %>% select(nestID, natal)
taskShanTime<-left_join(taskShanTime, nataladd,  by="nestID")


# plot it
ggplot(taskShanTime, aes(shannon, behav, shape = timepoint)) +
  geom_point(position = position_jitter(width=0.05, height=0.2), alpha = 0.9, aes(color = nestTYPE)) +
  stat_summary(fun = mean, geom = "point", size = 5) +
  scale_shape_manual(values = c(17, 25))
ggsave("../figures/taskShanTime.jpg")

###########################################

# add column for shanDist
taskShanTime$shanDist <- NA
# calculate change in shannon over time and add to shanDist column
for (i in 1:nrow(taskShanTime)) {                                                   # for each row in the dataset
  if(taskShanTime$timepoint[i] == "late") {                                         # look at the the late bees only
    for (j in 1:nrow(taskShanTime)) {                                               # then iterate back through the dataset
      if(taskShanTime$timepoint[j] == "early" & taskShanTime$behav[j] == taskShanTime$behav[i]) {   # and find the early entry with the same behav
        taskShanTime$shanDist[i] <- taskShanTime$shannon[i] - taskShanTime$shannon[j]               # calculate the difference in shannon index across time
      }
    }
  }
}

# save the file for future analyses
write.csv(taskShanTime, "../Data/filtData/taskShanTime.csv")

# plot the change in shannon from early to late
avgShannDist <- taskShanTime %>% dplyr::summarize(avg = mean(shanDist, na.rm = T)) %>% dplyr::pull(avg)

ggplot(taskShanTime, aes(shanDist, behav)) +
  geom_point(position = position_jitter(width=0.1, height=0.2), alpha = 0.8, aes(color = nestTYPE)) +
  scale_shape_manual(values = c(17, 25)) +
  stat_summary(fun = mean, geom = "point", size = 5) +
  geom_vline(aes(xintercept = avgShannDist), color = "gray70", size = 0.6) +
  labs(x = "change in shannon index from early to late timepoint")
ggsave("../figures/shanDistBehav.jpg")
```

# .
# .
# .

# Calculate Proportions
## convert count_bees to proportions
write prop_bees
```{r}
# remove unidentified bees and bees with fewer than threshold number of observations (they have NA shannon values)
count_bees <- count_data[is.na(count_data$shannon),]

# rename to prop_bees to describe more accurately
prop_bees <- count_bees

# for each bee, rewrite the counts as the count of a given behavior divided by total number of behaviors carried out by that bee
for (i in 1:nrow(prop_bees)) {
  prop_bees$nectarforaging[i] <- prop_bees$nectarforaging[i] / prop_bees$nBehavs[i]
  prop_bees$pollenforaging[i] <- prop_bees$pollenforaging[i] / prop_bees$nBehavs[i]
  prop_bees$feedsbrood[i] <- prop_bees$feedsbrood[i] / prop_bees$nBehavs[i]
  prop_bees$egglaying[i] <- prop_bees$egglaying[i] / prop_bees$nBehavs[i]
  prop_bees$allforaging[i] <- prop_bees$allforaging[i] / prop_bees$nBehavs[i]
}

# save for later analyses
write.csv(prop_bees, "../Data/filtData/prop_bees.csv")
```
## convert count_beesTime to proportions
write prop_beesTime
```{r}
# remove unidentified bees and bees with fewer than threshold number of observations (they have NA shannon values)
count_beesTime <- count_time[is.na(count_time$shannon),]

# rename to prop_bees to describe more accurately
prop_beesTime <- count_beesTime

# for each bee, rewrite the counts as the count of a given behavior divided by total number of behaviors carried out by that bee
for (i in 1:nrow(prop_beesTime)) {
  prop_beesTime$nectarforaging[i] <- prop_beesTime$nectarforaging[i] / prop_beesTime$nBehavs[i]
  prop_beesTime$pollenforaging[i] <- prop_beesTime$pollenforaging[i] / prop_beesTime$nBehavs[i]
  prop_beesTime$feedsbrood[i] <- prop_beesTime$feedsbrood[i] / prop_beesTime$nBehavs[i]
  prop_beesTime$allforaging[i] <- prop_beesTime$allforaging[i] / prop_beesTime$allforaging[i]

}

# save for later analyses
write.csv(prop_beesTime, "../Data/filtData/prop_beesTime.csv")
```

