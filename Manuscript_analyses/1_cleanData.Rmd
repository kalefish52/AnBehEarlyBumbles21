---
title: "CleanData"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
 
  
  
  
# Load Packages
```{r}
library(tidyverse)
library(dplyr)
library(ggplot2)
```

We have to manually download each project file from Boris. Each project is a single aggregated data file and represents one nest (ex. QF01). To download Boris files into a directory for data cleaning, do the following: 
1) Open project file in BORIS
2) Observations -> Export Events -> Aggregated events
3) Press select all and then ok 
4) Select all subjects then all behaviors, press ok 
5) Group selected events into one file 
6) Save file as nest name eg. "QF01" as a .csv file in the BORISfiles directory 
*Note: all state events must be paired to export as an aggregated file 
*Note: these files do not include observations that did not contain scored behaviors and do not include bees with no observed behaviors 

To download information about all videos watched (including those without any observed behaviors), we have to download an additional file for each project from Boris. To do this:
1) Open project file in BORIS
2) Analysis -> Synthetic time budget
3) Press select all and then ok
4) Press ok
5) Save file as nest name eg. "QF01" as a .csv file in the allBORISfiles directory
6) Click okay without selecting any additional behaviors to subtract from total time




# Load Data
THIS ASSUMES YOUR DEFAULT WORKING DIRECTORY IS WHERE THIS DOCUMENT LIVES (MANUSCRIPT_ANALYSES)

import the BORIS observation datafiles and combine them into a single df called obs_data. this contains all the behavioral observations
```{r}
# function to return list of filenames in BORISfiles folder
# # use pattern="*.csv", when getting files from google drive stream, there is an extra non-.csv file 
# # use full.names=TRUE so that it reads in files using absolute file path 
getBORISfilenames <- function(gitfilepath) {
  filenames <- list.files(gitfilepath,
                          pattern = "*.csv",
                          full.names = TRUE)
  return(filenames)
}

# make the list of filenames
BORISfilenames <- getBORISfilenames("../Data/BORISfiles")

# loop over the files in the list and import all of them into a single dataframe. rename column names to remove "." and make shorter
obs_data <- do.call(rbind, lapply(BORISfilenames, 
                                    function(i) {
                                      read.csv(i, header = TRUE,
                                               col.names = c("obsID",
                                                             "obsDate",
                                                             "filename",
                                                             "totalLen",
                                                             "fps",
                                                             "beeID",
                                                             "behav", 
                                                             "cat",
                                                             "mod",
                                                             "behavType",
                                                             "start",
                                                             "stop",
                                                             "dur",
                                                             "comStart",
                                                             "comStop"))
                     }
))

# look at the data
obs_data

# check the number of total observations (total number of unfiltered behaviors recorded)
init_obs <- nrow(obs_data)
print(paste("There are", init_obs, "observations in the initial obs_data dataframe.", sep = " "))

```
import BORIS synthetic time budget datasheets and merge them into a single df called videos_data
```{r}
# function to return list of filenames in BORISfiles folder
# # use pattern="*.csv", when getting files from google drive stream, there is an extra non-.csv file 
# # use full.names=TRUE so that it reads in files using absolute file path 
getBORISfilenames <- function(gitfilepath) {
  filenames <- list.files(gitfilepath,
                          pattern = "*.csv",
                          full.names = TRUE)
  return(filenames)
}

# make the list of filenames
BORISfilenames <- getBORISfilenames("../Data/allBORISfiles")
BORISfilenames
# loop over the files in the list and import all of them into a single dataframe. skip first 3 lines of column headers and only import first 2 columns (obsID and totLen)
videos_data <- do.call(rbind, lapply(BORISfilenames, 
                                    function(i) {
                                      read.csv(i, skip = 3, header = FALSE)[,1:2]
                     }
))

# rename column headers to be descriptive
names(videos_data)[1] <- "obsID"
names(videos_data)[2] <- "totalLen"

# look at the data
videos_data
# check how many total videos in unfiltered data we watched
init_videos <- nrow(videos_data)
print(paste("There are", init_videos, "videos in the initial videos_data dataframe.", sep = " "))
```
import the master datasheets and combine them into a single df called master_data. this contains beeIDs and natal colony for each nest. this will enable us to include the bees that we did not have observed behaviors for in our analyses
```{r}
# do the same for the master datasheets that contain bee ID numbers
getMasterfilenames <- function(gitfilepath) {
  filenames <- list.files(gitfilepath,
                          pattern = "*.csv",
                          full.names = TRUE)
  return(filenames)
}

# make the list of filenames
masterfilenames <- getMasterfilenames("../Data/MasterDatasheets")

# loop over the files and import all of them. rename column names to remove "." and make shorter
master_data <- do.call(rbind, lapply(masterfilenames, 
                                    function(i) {
                                      read.csv(i, 
                                               header = FALSE, 
                                               skip = 1,
                                               na.strings=c("", " ", "NA", "na", "x", "X", "xp", "-", "#VALUE!", 
                                                            "Died", "died", "died ", "died prior to freezing", "all died"),
                                               col.names = c("nestID",
                                                             "Qnatal",
                                                             "Qpulled",
                                                             "QID",
                                                             "Gas1",
                                                             "Gas2",
                                                             "Wnatal", 
                                                             "Wpulled",
                                                             "WID1",
                                                             "WID2",
                                                             "WID3",
                                                             "WID4",
                                                             "WID5",
                                                             "WID6",
                                                             "Eggs",
                                                             "DaysToEggs",
                                                             "LarvDate",
                                                             "FreezeDate",
                                                             "EggsToEclosion",
                                                             "TotalNestTime",
                                                             "Video1",
                                                             "Video2",
                                                             "Notes",
                                                             "MadeBorisFile"))
                     }
))

# look at the data
master_data

# check how many total, unfiltered nests there are
init_master <- nrow(master_data)
print(paste("There are", init_master, "nests accounted for in the initial master_data dataframe.", sep = " "))
```
import egg laying datasheets
```{r}
egglaying_data <- read.csv("../Data/Egg_laying_Events.csv", 
                           col.names = c("nestID", "dateLaid", "beeID", "caste", "timeLaid", "viewer", "notes"))
```
import body size datasheets
```{r}
size_data <- read.csv("../Data/bodysizeworkers.csv", 
                      col.names = c("beeID", "nestID", "date", "wing1", "wing2", "size"), na.strings = "na")
```
import ovary development datasheets
```{r}
ovary_data <- read.csv("../Data/Ovarydata.csv", 
                       col.names = c("nestID", "beeID", "fb", "ov", "l1", "s1", "l2", "s2", "notes", "x", "xx"))
```


# Clean Data

## filter nests
split obsID column from obs_data and videos_data into its component parts to enable manipulation by camera/colony/time/date
```{r}
# convert columns to character to enable manipulation with strsplit() and subset(startsWith())
obs_data$obsID <- as.character(obs_data$obsID)
videos_data$obsID <- as.character(videos_data$obsID)

# edit incorrect obsID information
# remove Kate from front of obsID name
obs_data[obs_data$obsID == "Kate\tfor\tNF02\t20180703\t13", 1] <- "for\tNF02\t20180703\t13"
videos_data[videos_data$obsID == "Kate\tfor\tNF02\t20180703\t13", 1] <- "for\tNF02\t20180703\t13"
# remove spaces in front of for in or nest
obs_data[startsWith(obs_data$obsID, " for"), 1] <- sub(".", "", obs_data[startsWith(obs_data$obsID, " for"), 1])
videos_data[startsWith(videos_data$obsID, " for"), 1] <- sub(".", "", videos_data[startsWith(videos_data$obsID, " for"), 1])
obs_data[startsWith(obs_data$obsID, " nest"), 1] <- sub(".", "", obs_data[startsWith(obs_data$obsID, " nest"), 1])
videos_data[startsWith(videos_data$obsID, " nest"), 1] <- sub(".", "", videos_data[startsWith(videos_data$obsID, " nest"), 1])

# add "non" to beginning of obsID for entries that are missing nest or for info
for (i in 1:nrow(obs_data)){
  if (startsWith(obs_data$obsID[i], "for") | startsWith(obs_data$obsID[i], "nest")) {}
  else {
    obs_data$obsID[i] <- paste("non", obs_data$obsID[i], sep = "\t")
    }
}
for (i in 1:nrow(videos_data)){
  if (startsWith(videos_data$obsID[i], "for") | startsWith(videos_data$obsID[i], "nest")) {}
  else {
    videos_data$obsID[i] <- paste("non", videos_data$obsID[i], sep = "\t")
    }
}

# split out obsID into camID, nestID, dateID and hourID (split based on the tab (\t) between elements)
# element 1 is camID
obs_data$camID <- sapply(strsplit(obs_data$obsID, "\t"), 
                          function(x){
                            x[1]
                            } )
videos_data$camID <- sapply(strsplit(videos_data$obsID, "\t"), 
                          function(x){
                            x[1]
                            } )
# element 2 is nestID
obs_data$nestID <- sapply(strsplit(obs_data$obsID, "\t"), 
                          function(x){
                            x[2]
                            } )
videos_data$nestID <- sapply(strsplit(videos_data$obsID, "\t"), 
                          function(x){
                            x[2]
                            } )
# element 3 is dateID
obs_data$dateID <- sapply(strsplit(obs_data$obsID, "\t"), 
                          function(x){ 
                            x[3]
                            } )
videos_data$dateID <- sapply(strsplit(videos_data$obsID, "\t"), 
                          function(x){ 
                            x[3]
                            } )
# element 4 is hourID
obs_data$hourID <- sapply(strsplit(obs_data$obsID, "\t"), 
                          function(x){ 
                            x[4]
                            } )
videos_data$hourID <- sapply(strsplit(videos_data$obsID, "\t"), 
                          function(x){ 
                            x[4]
                            } )
```
subset data to only include nests and behaviors of interest for analyses
```{r}
# remove unusable nests from master_data first, then subset other dataframes to include only those nests we want to keep

# make nestID character to enable startsWith 
master_data$nestID <- as.character(master_data$nestID)

# remove colonies that were not frozen from master_data (these colonies died before males eclosed)
master_data <- master_data[!is.na(master_data$FreezeDate),]

# remove QF01 (it was frozen and males eclosed, but all adults died)
master_data <- master_data[!master_data$nestID == "QF01",]

# remove QF08 & NT07 (missing workers)
master_data <- master_data[!master_data$nestID == "QF08",]
master_data <- master_data[!master_data$nestID == "NT07",]

# remove QT07 (queen died)
master_data <- master_data[!master_data$nestID == "QT07",]

# write master_data with QA gropus for erica's analyses
write.csv(master_data, "../Data/cleanMasterData.csv")

# remove QA groups and bees (data for a different experiment)
master_data <- master_data[!startsWith(master_data$nestID, "QA"),]

# subset observations and videos to only include the filtered nests
obs_data <- subset(obs_data, nestID %in% master_data$nestID)
videos_data <- subset(videos_data, nestID %in% master_data$nestID)

# subset observations to include only the behaviors we're interested in
obs_data <- obs_data[(obs_data$behav == "feedsbrood" | obs_data$behav == "nectarforaging" | obs_data$behav == "pollenforaging") ,]

# check how many remaining observations we have after filtering
clean_obs <- nrow(obs_data)
clean_videos <- nrow(videos_data)
clean_master <- nrow(master_data)
print(paste("There are", clean_obs, "out of", init_obs, "remaining observations in the cleaned obs_data", sep = " "))
print(paste("There are", clean_videos, "out of", init_videos, "remaining observations in cleaned videos_data", sep = " "))
print(paste("There are", clean_master, "out of", init_master, "remaining observations in cleaned master_data", sep = " "))
```
## format all dfs the same way with the same information
pull out caste information and ID number from beeIDs, name unidentified observations as "unknown" bee, pull out nestTYPE information
```{r}
# format the master_data in the same way as the obs_data
# gather the master_data so each worker and queen has their own row
masterBees <- master_data %>%
  gather(QID, WID1, WID2, WID3, WID4, WID5, WID6,  
         key = "IDtype", 
         value = "beeID")

# pull out caste info from masterBees
masterBees$caste <- sapply(strsplit(masterBees$IDtype, ""), 
                          function(x){
                            x[1]
                          })
# pull out caste info from obs_data
obs_data$beeID <- as.character(obs_data$beeID)
obs_data$caste <- sapply(strsplit(obs_data$beeID, ""), 
                          function(x){
                            x[1]
                          })
# make caste "N" and "U" (from unidentified bees with unidentified caste) worker -- if it were a queen we would be able to tell by size
obs_data[obs_data$caste == "U", "caste"] <- "W"
obs_data[obs_data$caste == "N", "caste"] <- "W"

# reformat caste info from egglaying_data to match
egglaying_data[egglaying_data$caste == "worker", "caste"] <- "W"
egglaying_data[egglaying_data$caste == "queen", "caste"] <- "Q"


# pull out ID number from beeID column in obs_data (instead of "Worker 5 (76)" or "Queen (43)" etc)
obs_data$beeID <- sapply(strsplit(obs_data$beeID, ")"),
                        function(x){
                          x[1]
                        })
obs_data$beeID <- sapply(strsplit(obs_data$beeID, "\\("),
                        function(x){
                          x[2]
                        })

# rename unidentified workers from the video data
obs_data[, "beeID"][is.na(obs_data[, "beeID"])] <- "unknown"
# rename "6 or 9" bee to 6
obs_data[obs_data$beeID == "6 or 9", "beeID"] <- 6

# remove masterBees without an ID number (these are blank spaces on the datasheet that do not represent bees)
masterBees <- masterBees[!is.na(masterBees$beeID),]

# combine beeID and nestID so that each bee has a unique identifier (some numbers are duplicated across nests)
masterBees$beeID <- paste0(masterBees$nestID, masterBees$beeID)
obs_data$beeID <- paste0(obs_data$nestID, obs_data$beeID)
egglaying_data$beeID <- paste0(egglaying_data$nestID, egglaying_data$beeID)
ovary_data$beeID <- paste0(ovary_data$nestID, ovary_data$beeID)
size_data$beeID <- paste0(size_data$nestID, size_data$beeID)

# pull out nestTYPE as a separate column
obs_data$nestTYPE <- substr(obs_data$nestID, start = 1, stop = 2)
videos_data$nestTYPE <- substr(videos_data$nestID, start = 1, stop = 2)
masterBees$nestTYPE <- substr(masterBees$nestID, start = 1, stop = 2)
egglaying_data$nestTYPE <- substr(egglaying_data$nestID, start = 1, stop = 2)
ovary_data$nestTYPE <- substr(ovary_data$nestID, start = 1, stop = 2)
size_data$nestTYPE <- substr(size_data$nestID, start = 1, stop = 2)
```
## filter observations
remove foraging events less than 10 seconds long (poop trips) and remove nest video data after first 5 minutes (errors)
```{r}
# remove all nectar foraging events under 10 seconds long
beforeNectRemov <- nrow(obs_data)
obs_data <- obs_data[!(obs_data$behav == "nectarforaging" & obs_data$dur < 10),]

# remove all pollen foraging events under 10 seconds long
beforePollRemov <- nrow(obs_data)
obs_data <- obs_data[!(obs_data$behav == "pollenforaging" & obs_data$dur < 10),]

# check how many foraging observations were removed that were under 10 seconds long
NectPollRemov <- nrow(obs_data)
print(paste(beforeNectRemov - beforePollRemov, "nectar foraging observations were removed because they were under 10 seconds long.", sep = " "))
print(paste(beforePollRemov - NectPollRemov, "pollen foraging observations were removed because they were under 10 seconds long.", sep = " "))

# remove all but the first five minutes of nest videos

# make time variables numeric
obs_data$start <- as.numeric(obs_data$start)
obs_data$stop <- as.numeric(obs_data$stop)
obs_data$totalLen <- as.numeric(obs_data$totalLen)
videos_data$totalLen <- as.numeric(videos_data$totalLen)

# remove nest behaviors that start after 5 minute mark
obs_data <- obs_data[!(obs_data$camID == "nest" & obs_data$start > 300),]

# check how many were removed that started after 5 minutes
fiveMinRemov_obs <- nrow(obs_data)
print(paste(NectPollRemov - fiveMinRemov_obs, "nest observations were removed because they started after the five minute mark.", sep = " "))

# cut down nest videos to only look at first 5 minutes (300 seconds), and make all behaviors stop by 5 minutes
for (i in 1:nrow(obs_data)) {                                             # for every row in the dataframe
  if ((obs_data$camID[i] == "nest") & (obs_data$totalLen[i] > 300)) {     # if it's a nest video and it is over 300 seconds long
    obs_data$totalLen[i] <- 300                                           # make the total length of the video 300 seconds (5 minutes)
    if (obs_data$stop[i] > 300) {                                         # of those nest videos, if a behavior ends past 300 seconds
      obs_data$stop[i] <- 300                                             # set the stop time to 300 seconds
      obs_data$dur[i] <- obs_data$stop[i] - obs_data$start[i]             # and recalculate the duration of that behavior to end at 300s
    }
  }
}

for (i in 1:nrow(videos_data)) {                                             # for every row in the dataframe
  if ((videos_data$camID[i] == "nest") & (videos_data$totalLen[i] > 300)) {  # if it's a nest video and it is over 300 seconds long
    videos_data$totalLen[i] <- 300                                           # make the total length of the video 300 seconds (5 minutes)
  }
}

# make duration of all brood feeding events 1 second duration to enable duration comparisons
for (i in 1:nrow(obs_data)) {
  if (!is.na(obs_data$behav[i]) && obs_data$behav[i] == "feedsbrood") {
    obs_data$dur[i] <- 1
  }
}

# save cleaned obs_data for downstream analyses
write.csv(obs_data, "../Data/obs_data.csv")

# check how many observations remain after all cleaning has been completed
clean_obs <- nrow(obs_data)
clean_videos <- nrow(videos_data)
print(paste("There are now", clean_obs, "observations remaining in the fully cleaned obs_data.", init_obs - clean_obs, "observations fewer than the initial observations, because", beforeNectRemov - beforePollRemov + beforePollRemov - NectPollRemov + NectPollRemov - fiveMinRemov_obs, "were removed above.",  sep = " "))
print(paste("There are now", clean_videos, "out of", init_videos, "remaining videos in fully cleaned videos_data", sep = " "))
```




# Combine Data

## combine masterBees and obs_data
merge obs_data to masterBees to add bees who did not carry out any recorded behaviors (ie missing from initial obs_data file)
***Remove behaviors from all unidentified bees from future analyses --> i removed this b/c we want unidentified bees for certain analyses, i think.
```{r}
# make a list of all the bees we do have records for
recordedBees <- subset(masterBees, (beeID %in% obs_data$beeID))

# make a list of all bees we do not have observations for
missingBees <- subset(masterBees, !(beeID %in% obs_data$beeID))

# print how many total bees we have
print(paste("There are", nrow(masterBees), "total bees across all colonies in the master datasheet.", sep = " "))

# print how many bees we don't have records for
print(paste("There are", nrow(missingBees), "bees for which we do not have any recorded behaviors.", sep = " "))
  
# add missing bees to obs_data file
# # add rows to obs_data, filled with NA values, number of rows equal to number of missingBees
emptydf <- data.frame(matrix(NA, nrow = nrow(missingBees), ncol = ncol(obs_data)))
# # make column names the same
names(emptydf) <- names(obs_data)
# # rbind the data. emptydf is at the tail of obs_data
obs_data <- rbind(obs_data, emptydf)  
# # fill the empty rows just added to obs_data with the missing bee nestID, nestTYPE, beeID, and caste
for (i in 0:(nrow(missingBees) - 1)) {
  obs_data$nestID[nrow(obs_data) - i] <- missingBees$nestID[i+1]
  obs_data$beeID[nrow(obs_data) - i] <- missingBees$beeID[i+1]
  obs_data$caste[nrow(obs_data) - i] <- missingBees$caste[i+1]
  obs_data$nestTYPE[nrow(obs_data) - i] <- missingBees$nestTYPE[i+1]}

# add natal colony info from masterBees to obs_data
obs_data$natal <- NA
for (i in 1:nrow(obs_data)) {
  for (j in 1:nrow(masterBees)) {
    if (obs_data$beeID[i] == masterBees$beeID[j]) {
      if (obs_data$caste[i] == "W") {
        obs_data$natal[i] <- masterBees$Wnatal[j] 
      }
      if (obs_data$caste[i] == "Q") {
        obs_data$natal[i] <- masterBees$Qnatal[j] 
      }
    }
  }
}

# add random number column to make table compatible with pivot_wider in future steps. needs a unique identifier for each individual
obs_data$rand <- NA
for (i in 1:(nrow(obs_data))) {
  obs_data$rand[i] <- runif(1)
}

# # make NA values equal to 0
# obs_data[is.na(obs_data)] <- 0

# check how many bees we have in the new obs_data. should equal the number of bees in the master_data
# select only relevant information
allBees <- dplyr::select(obs_data, nestID, nestTYPE, beeID, caste, natal)
# remove duplicates
allBees <- unique(allBees[c("nestID", "nestTYPE", "beeID", "caste", "natal")])
unknownBees <- allBees[is.na(allBees$natal),]

# check how many bees are now included in obs_data
print(paste("There are", nrow(allBees), "bees total to be included in the analyses, including", nrow(unknownBees), "unidentified for bees.", sep = " "))
if (nrow(allBees) - nrow(unknownBees) == nrow(masterBees)) {
  print("All bees from the master datasheets are accounted for!")
} else {
  print(paste("ERROR! There are", nrow(allBees) - nrow(unknownBees), "identified bees accounted for, but the master datasheet has", nrow(masterBees), "bees. If there are only a few more bees than expected from the master datasheet, it is likely because of replacement bees. If there is a large difference here, something is wrong.", sep = " "))
}

# make new dataframe listing the bees without any recorded behaviors
noObsBees <- obs_data[is.na(obs_data$obsID), c("nestID", "nestTYPE", "beeID", "caste", "natal")]
noObsBees
write.csv(noObsBees, "../Data/noObsBees.csv")
write.csv(allBees, "../Data/allBees.csv")
```
## make nestDEV df with obs_data split out by timepoint
output same as obs_data but with column for timepoint (early/late)
```{r}
# rename so we don't interfere in upstream code
nestDEV <- obs_data
nestDEV
# format dateID as a date
nestDEV$dateID <- as.Date(nestDEV$dateID, "%Y%m%d")

# add column for timepoint filled with NA values
nestDEV$timepoint <- NA

# sort by nestID, then dateID
nestDEV <- nestDEV[order(nestDEV$dateID),]
nestDEV <- nestDEV[order(nestDEV$nestID),]
nestDEV <- nestDEV[!is.na(nestDEV$dateID),]

# make empty early df
nestDEVearly <- data.frame(matrix(NA, nrow = 0, ncol = ncol(nestDEV)))
# make column names the same as nestDEV
names(nestDEVearly) <- names(nestDEV)

# make empty late df
nestDEVlate <- data.frame(matrix(NA, nrow = 0, ncol = ncol(nestDEV)))
# make column names the same as nestDEV
names(nestDEVlate) <- names(nestDEV)

# for a given nestID
for(i in 1:length(unique(nestDEV$nestID))) {
  # make a temporary dataframe containing info from only that nest
  NDnestid_data <- nestDEV[nestDEV$nestID == unique(nestDEV$nestID)[i],]
  # add first row to early_data
  nestDEVearly <- rbind(nestDEVearly, NDnestid_data[1,])
  # for each dateID
  if(nrow(NDnestid_data) > 1) {
      for(j in 2:nrow(NDnestid_data)) {
      # if dateID is less than or equal to previous dateID + 2
        if(NDnestid_data$dateID[j] <= NDnestid_data$dateID[1] + 2) {
          # move that row to early_data df
          nestDEVearly <- rbind(nestDEVearly, NDnestid_data[j,])
        }
        # if dateID is more than or equal to previous dateID + 4
        else if(NDnestid_data$dateID[j] >= NDnestid_data$dateID[1] + 4) {
          # move that row to late_data df
          nestDEVlate<- rbind(nestDEVlate, NDnestid_data[j,])}
      }
  }
}

# check to make sure all observations were accounted for
if (nrow(nestDEV) == nrow(nestDEVearly) + nrow(nestDEVlate)) {
  print("All observations are accounted for!")
} else {print("ERROR: THERE ARE MISSING OR EXTRA OBSERVATIONS")}

# add the timepoint to the nestDEV column
nestDEVearly$timepoint <- "early"
nestDEVlate$timepoint <- "late"

# rewrite nestDEV with the timepoints included
nestDEV <- rbind(nestDEVearly, nestDEVlate)
nestDEV

# add back in additional information from count_data (eg, body size, ovary dev, natal colony, etc)
write.csv(nestDEV, "../Data/nestDEV.csv")
```
## make count_data df with counts of each behavior observed for each bee
output df with each bee as a single row, behaviors as columns, count of frequency of each behavior per bee as values
```{r}
# collapse the dataframe to count the number of instances doing each behavior
  # this outputs a new dataframe with columns nestID, nestTYPE, beeID, caste, natal, nectarforaging, feedsbrood, pollenforaging 
  # (and any other behaviors recorded), with counts for each behavior in as values
  # assumes rand number is not duplicated across individuals. 

# rename to count_data for clarity 
count_data <- obs_data
# add a column with value 1 that counts the behavioral observations this makes each behavior a count of 1 
count_data$count <- 1  
# condense data frame into relevant columns, each row is a single observation for an individual
count_data <- count_data %>%
  pivot_wider(id_cols = c("nestID", "nestTYPE", "beeID", "caste", "natal", "behav"), 
              names_from = rand, 
              values_from = count) 

# add column to fill with sum of counts for each behav
countCol1 <- 7 # firstcolumn containing counts
count_data$totCount <- rowSums(count_data[countCol1:ncol(count_data)], na.rm = TRUE)

# subset dataframe to remove random number generated columns (only want summary data)
count_data <- count_data %>%
  dplyr::select(nestID, nestTYPE, beeID, caste, natal, behav, totCount)

# collapse dataframe so that each bee has one single row and behaviors are additional columns
count_data <- count_data %>%
  pivot_wider(id_cols = c("nestID", "nestTYPE", "beeID", "caste", "natal"), 
              names_from = behav, 
              values_from = totCount)

# remove NA column
count_data <- count_data[ , !names(count_data) %in% c("NA")]

# replace NA values in count columns with 0 (don't change NA values in natal column)
count_data[!names(count_data) %in% c("natal")] [is.na(count_data[!names(count_data) %in% c("natal")])] <- 0
count_data
```
## add egg laying data to counts_data
```{r}
# make new column in count_data to include egglaying
count_data$egglaying <- 0

# go through count_data and egglaying_data -- for any matching beeIDs, add 1 to the egglaying column for that bee
for(i in 1:nrow(count_data)) {
  for (j in 1:nrow(egglaying_data)) {
    if (count_data$beeID[i] == egglaying_data$beeID[j]) {
      count_data$egglaying[i] <- count_data$egglaying[i] + 1
    }
  }
}

# sum counts of behaviors to see total number of behaviors carried out by each indiv
count_data$nBehavs <- rowSums(count_data[, c("feedsbrood", "nectarforaging", "pollenforaging", "egglaying")], na.rm = TRUE)

# print how many bees we have here. should equal masterdata
print(paste("There are", nrow(count_data), "bees accounted for."))
if (nrow(count_data) - nrow(unknownBees) == nrow(masterBees)) {
  print("All bees from the master datasheets are accounted for!")
} else {
  print(paste("All bees are not properly accounted for. There are", nrow(count_data), "bees accounted for, but the master datasheet has", nrow(masterBees), "bees", sep = " "))
}

# Save dataframe as .csv so it can be used in other downstream analyses 
write.csv(count_data, "../Data/tempData/count_data.csv")
count_data
```
## add body size data to count_data
```{r}
count_data$size <- NA
for (i in 1:nrow(count_data)) {
  for (j in 1:nrow(size_data)) {
    if (count_data$beeID[i] == size_data$beeID[j]) {
      count_data$size[i] <- size_data$size[j]
    }
  }
}
count_data
```
## add ovary development data to count_data (workers only)
```{r}
# OVARY LENGTH - missing lots of values

# add to ovary length count_data
count_data$ovL1 <- NA
count_data$ovL2 <- NA
for (i in 1:nrow(count_data)) {
  for (j in 1:nrow(ovary_data)) {
    if (count_data$beeID[i] == ovary_data$beeID[j]) {
      count_data$ovL1[i] <- ovary_data$l1[j]
      count_data$ovL2[i] <- ovary_data$l2[j]
    }
  }
}

# OOCYTE RESORPTION

# duplicate stage columns to input resorption status
ovary_data$r1 <- ovary_data$s1
ovary_data$r2 <- ovary_data$s2
ovary_data
# convert r1 to numbers
ovary_data[is.na(ovary_data$r1), "r1"] <- "N"
ovary_data[ovary_data$r1 == "I", "r1"] <- 0
ovary_data[ovary_data$r1 == "II", "r1"] <- 0
ovary_data[ovary_data$r1 == "III", "r1"] <- 0
ovary_data[ovary_data$r1 == "III+", "r1"] <- 0
ovary_data[ovary_data$r1 == "IV", "r1"] <- 0
ovary_data[ovary_data$r1 == "IV+", "r1"] <- 0
ovary_data[ovary_data$r1 == "R + II", "r1"] <- 1
ovary_data[ovary_data$r1 == "VI", "r1"] <- 0
ovary_data[ovary_data$r1 == "R", "r1"] <- 1
ovary_data[ovary_data$r1 == "N", "r1"] <- NA
ovary_data$r1 <- as.numeric(ovary_data$r1)

# convert r2 to numbers
ovary_data[is.na(ovary_data$r2), "r2"] <- "N"
ovary_data[ovary_data$r2 == "I", "r2"] <- 0
ovary_data[ovary_data$r2 == "II", "r2"] <- 0
ovary_data[ovary_data$r2 == "III", "r2"] <- 0
ovary_data[ovary_data$r2 == "III+", "r2"] <-
ovary_data[ovary_data$r2 == "IV", "r2"] <-0
ovary_data[ovary_data$r2 == "IV+", "r2"] <- 0
ovary_data[ovary_data$r2 == "R + II", "r2"] <- 1
ovary_data[ovary_data$r2 == "VI", "r2"] <- 0
ovary_data[ovary_data$r2 == "R", "r2"] <- 1
ovary_data[ovary_data$r2 == "N", "r2"] <- NA
ovary_data$r2 <- as.numeric(ovary_data$r2)

count_data$ovR1 <- NA
count_data$ovR2 <- NA

# add ovary_data to count_data df
for (i in 1:nrow(count_data)) {
  for (j in 1:nrow(ovary_data)) {
    if (count_data$beeID[i] == ovary_data$beeID[j]) {
      count_data$ovR1[i] <- ovary_data$r1[j]
      count_data$ovR2[i] <- ovary_data$r2[j]
    }
  }
}

# OVARY STAGE - includes converting resorbed oocytes to stage 4

# convert ovary 1 stage numerals to numbers
ovary_data[is.na(ovary_data$s1), "s1"] <- "N"
ovary_data[ovary_data$s1 == "I", "s1"] <- 1
ovary_data[ovary_data$s1 == "II", "s1"] <- 2
ovary_data[ovary_data$s1 == "III", "s1"] <- 3
ovary_data[ovary_data$s1 == "III+", "s1"] <- 3.5
ovary_data[ovary_data$s1 == "IV", "s1"] <- 4
ovary_data[ovary_data$s1 == "IV+", "s1"] <- 4
ovary_data[ovary_data$s1 == "R + II", "s1"] <- "R"
ovary_data[ovary_data$s1 == "VI", "s1"] <- 4
ovary_data[ovary_data$s1 == "R", "s1"] <- 4
ovary_data[ovary_data$s1 == "N", "s1"] <- NA
ovary_data$s1 <- as.numeric(ovary_data$s1)

# convert ovary 2 stage numerals to numbers
ovary_data[is.na(ovary_data$s2), "s2"] <- "N"
ovary_data[ovary_data$s2 == "I", "s2"] <- 1
ovary_data[ovary_data$s2 == "II", "s2"] <- 2
ovary_data[ovary_data$s2 == "III", "s2"] <- 3
ovary_data[ovary_data$s2 == "III+", "s2"] <- 3.5
ovary_data[ovary_data$s2 == "IV", "s2"] <- 4
ovary_data[ovary_data$s2 == "IV+", "s2"] <- 4
ovary_data[ovary_data$s2 == "R + II", "s2"] <- "R"
ovary_data[ovary_data$s2 == "VI", "s2"] <- 4
ovary_data[ovary_data$s2 == "R", "s2"] <- 4
ovary_data[ovary_data$s2 == "N", "s2"] <- NA
ovary_data$s2 <- as.numeric(ovary_data$s2)

# add ovary stage to count_data
count_data$ovS1 <- NA
count_data$ovS2 <- NA
for (i in 1:nrow(count_data)) {
  for (j in 1:nrow(ovary_data)) {
    if (count_data$beeID[i] == ovary_data$beeID[j]) {
      count_data$ovS1[i] <- ovary_data$s1[j]
      count_data$ovS2[i] <- ovary_data$s2[j]
    }
  }
}
```








# Visualize Data

## graph at the number of observations per camera type per nest 
These files are updated as more video observations are done. Video observations are performed by many different observers. Check how many observations have been recorded for each project for foraging and nest, at the two different time points. 
```{r}
# summarize the data to look at the total number of observations per nest
data_sum<- obs_data %>% dplyr::select(camID, nestID, nestTYPE) %>% dplyr::arrange(nestID, camID)

sumsTOTAL<-data_sum %>% dplyr::group_by(nestID, camID) %>% dplyr::summarise(Observations=dplyr::n())
sumsTYPE<-data_sum %>% dplyr::group_by(nestTYPE, camID) %>% dplyr::summarise(Observations=dplyr::n())

#look at number of observations we have so far based on each colony 
ggplot(sumsTOTAL, aes(x=nestID, y=Observations, fill=camID)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90))

# look at number of observations we have so far based on each type of colony 
ggplot(sumsTYPE, aes(x=nestTYPE, y=Observations, fill=camID)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90))

sumsTYPE
sumsTOTAL
```

## graph the number of observations per behavior per nest
```{r}
# graph the number of behaviors we have per nest
data_sum <- count_data %>% dplyr::select(nestID, nestTYPE, nectarforaging, pollenforaging, feedsbrood) %>% arrange(nestID)

sumsTYPE<-data_sum %>% group_by(nestTYPE) 

# look at data we have so far based on each nestID 
ggplot(data_sum, aes(x=nestID, y=feedsbrood, fill=nestTYPE)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90))

ggplot(data_sum, aes(x=nestID, y=nectarforaging, fill=nestTYPE)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90))

ggplot(data_sum, aes(x=nestID, y=pollenforaging, fill=nestTYPE)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90))

# look at data we have so far based on each nestTYPE 
ggplot(sumsTYPE, aes(x=nestTYPE, y=feedsbrood, fill=nestTYPE)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90))

ggplot(sumsTYPE, aes(x=nestTYPE, y=nectarforaging, fill=nestTYPE)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90))

ggplot(sumsTYPE, aes(x=nestTYPE, y=pollenforaging, fill=nestTYPE)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90))
```


















[[REMOVE AFTER COPIED]] make duration df with duration of each behavior for each bee 
<!-- output df with each bee as a single row, behaviors as columns, total duration of each behavior per bee as values. -->
<!-- this data includes unidentified bees -->
<!-- ```{r} -->
<!-- ## rename for clarity -->
<!-- dur_data <- obs_data -->

<!-- for (i in 1:nrow(dur_data)) { -->
<!--   if (!is.na(dur_data$behav[i]) && dur_data$behav[i] == "feedsbrood") { -->
<!--     dur_data$dur[i] <- 1 -->
<!--   } -->
<!-- } -->

<!-- ## collapse dataframe so that columns = nestID, beeID, behav, and stop times for each behavior.  -->
<!-- ## values = duration of each behav -->
<!-- dur_data <- dur_data %>% -->
<!--   pivot_wider(id_cols = c("nestID", "beeID", "behav", "caste"),  -->
<!--               names_from = rand,  -->
<!--               values_from = dur,  -->
<!--               names_repair = "minimal") -->

<!-- ## add column with the sum of durations for each behav -->
<!-- dur_data$totDur <- rowSums(dur_data[5:ncol(dur_data)], na.rm = TRUE) -->

<!-- ## subset dataframe so that all is left is nestID, beeID, behav, and totDur -->
<!-- dur_data <- dur_data %>% -->
<!--   select(nestID, beeID, behav, caste, totDur) -->

<!-- ## collapse dataframe so that each bee has one single row. cols = nestID, beeID, nectarforaging, *other behaviors -->
<!-- dur_data <- dur_data %>% -->
<!--   pivot_wider(id_cols = c("nestID", "beeID", "caste"),  -->
<!--               names_from = behav,  -->
<!--               values_from = totDur) -->

<!-- ## replace NA values with 0 -->
<!-- dur_data[is.na(dur_data)] <- 0 -->

<!-- ##save dataframe as .csv so it can be used in other downstream analyses  -->
<!-- write.csv(dur_data, "../Data/tempData/dur_data.csv") -->

<!-- ## count the number of bees with behaviors -->
<!-- print(paste("There are", nrow(dur_data), "bees accounted for in the duration data.")) -->
<!-- if (nrow(dur_data)==nrow(recordedBees)) { -->
<!--   print("All bees with recorded behaviors are accounted for!") -->
<!-- } else { -->
<!--   print(paste("There is a mismatch between identified bees and the number of bees in the duration dataframe. There are", nrow(dur_data), "bees accounted for in the duration dataframe, but the boris data has", nrow(recordedBees), "identified bees with recorded behaviors. Right now, duration df includes unidentified bees, which will make it larger than the identifed bees with recorded behaviors.", sep = " ")) -->
<!-- } -->

<!-- dur_data -->

<!-- ##graph the number of behaviors we have per nest -->
<!-- Queencharacter <- sapply(strsplit(count_data$nestID, ""),  -->
<!--                           function(x){ -->
<!--                             x[1] -->
<!--                           }) -->
<!-- Numbercharacter<-sapply(strsplit(count_data$nestID, ""), -->
<!--                         function(x){ -->
<!--                           x[2] -->
<!--                         })     -->

<!-- dur_data$nestTYPE<-paste0(Queencharacter, Numbercharacter) -->

<!-- ## remove data from nest types other than the ones we want (remove bad data) -->
<!-- dur_data <- subset(dur_data, subset = (dur_data$nestTYPE == "NT" | dur_data$nestTYPE == "NF" | dur_data$nestTYPE == "QT" | dur_data$nestTYPE == "QF")) -->

<!-- data_sum <- dur_data %>% select(nestID, nestTYPE, nectarforaging, pollenforaging, feedsbrood, fillshoneypot, laysegg) %>% arrange(nestID) -->

<!-- sumsTYPE<-data_sum %>% group_by(nestTYPE)  -->

<!-- ##look at data we have so far based on each colony  -->

<!-- ggplot(data_sum, aes(x=nestID, y=feedsbrood, fill=nestTYPE)) + -->
<!--   geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90)) -->

<!-- ggplot(data_sum, aes(x=nestID, y=nectarforaging, fill=nestTYPE)) + -->
<!--   geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90)) -->

<!-- ggplot(data_sum, aes(x=nestID, y=pollenforaging, fill=nestTYPE)) + -->
<!--   geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90)) -->

<!-- ## look at data we have so far based on each type of colony  -->
<!-- ggplot(sumsTYPE, aes(x=nestTYPE, y=feedsbrood, fill=nestTYPE)) + -->
<!--   geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90)) -->

<!-- ggplot(sumsTYPE, aes(x=nestTYPE, y=nectarforaging, fill=nestTYPE)) + -->
<!--   geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90)) -->

<!-- ggplot(sumsTYPE, aes(x=nestTYPE, y=pollenforaging, fill=nestTYPE)) + -->
<!--   geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90)) -->
<!-- ``` -->





# Count duration of video watched for each nest
output df with total duration of video watched per colony. columns = nestID and totalLen
```{r}
## select only the obsID, nestID, and totalLen columns
## subset to only the unique combinations (ie. remove duplicate videos so we don't count more time than we watched)
nVids <- nrow(videos_data)
totalLen_data <- videos_data %>%
  dplyr::select(obsID, nestID, totalLen) %>%
  unique()
totalLen_data
## print how many videos were removed
print(paste("There were", nVids - nrow(totalLen_data), "duplicate videos removed.", sep = " "))

## split out obsID into camID, dateID and hourID (split based on the tab (\t) between elements)
## element 1 is camID
totalLen_data$camID <- sapply(strsplit(totalLen_data$obsID, "\t"), 
                          function(x){
                            x[1]
                            } )
## element 3 is dateID
totalLen_data$dateID <- sapply(strsplit(totalLen_data$obsID, "\t"), 
                          function(x){ 
                            x[3]
                            } )
## element 4 is hourID
totalLen_data$hourID <- sapply(strsplit(totalLen_data$obsID, "\t"), 
                          function(x){ 
                            x[4]
                            } )
## combine date and hour into a single column called timeID
totalLen_data$timeID <- paste(totalLen_data$dateID, totalLen_data$hourID)
## subset the df to remove the obs, hour, and date columns
totalLen_data <- totalLen_data %>%
  dplyr::select(camID, timeID, nestID, totalLen)

totalLen_data
## verify we have the correct number of colonies and videos
print(paste("There are", nrow(totalLen_data), "videos out of", clean_videos, "fully cleaned videos accounted for in the totalLen_data dataframe."))

## create empty dataframe to put length into
camDur <- data.frame(nestID = NA,
                     forLen = NA,
                     nestLen = NA,
                     totalLen = NA)

## for each unique nest, subset the data to look at one nest at a time. then split out foraging and nest videos
for (i in 1:length(unique(totalLen_data$nestID))) {
  sub_data <- subset(totalLen_data, nestID == unique(totalLen_data$nestID)[i]) # subset to look at a single nest
  for_data <- subset(sub_data, sub_data$camID == "for")                        # subset foraging video only into for_data
  nest_data <- subset(sub_data, sub_data$camID == "nest")                      # subset nest video only into nest_data
  forSum <- sum(for_data$totalLen)                                             # sum the video duration of all foraging videos
  nestSum <- sum(nest_data$totalLen)                                           # sum the video duration of all nest videos
  totalSum <- sum(sub_data$totalLen)                                           # sum the video duration of all videos
  camDur <- rbind(camDur, c(sub_data$nestID[1], forSum, nestSum, totalSum))    # add the sum totals to the camDur df
}
## remove NA row initially created
camDur <- camDur[2:nrow(camDur),]

## count to make sure all colonies are accounted for
print(paste("There are", nrow(camDur), "colonies accounted for in the camDur dataframe out of", nrow(master_data), "master colonies.", sep = " "))

## make columns numeric so i can calculate ratio in next step
camDur$totalLen <- as.numeric(camDur$totalLen)
camDur$forLen <- as.numeric(camDur$forLen)
camDur$nestLen <- as.numeric(camDur$nestLen)
camDur$nestID <- as.character(camDur$nestID)

## make new column with the ratio of foraging to nest video length. should be ~12 for each colony. if it's not, need to watch more videos
camDur$FNratio <- NA
for (i in 1:nrow(camDur)) {
  camDur$FNratio[i] <- camDur$forLen[i] / camDur$nestLen[i]
}

##Save dataframe as .csv so it can be used in other downstrea analyses 
write.csv(camDur, "../Data/tempData/camDur.csv")

## check to see how much video was watched for each nest and for each treatment
## must be equal + ratio must be 1 to compare
camDur
camDur <- camDur[order(camDur$nestID),]

## graph total duration of video watched for each colony
##look at data we have so far based on each colony 

## Make a new column for nest type ie. NT or QT 
Queencharacter<-sapply(strsplit(camDur$nestID, ""), 
                          function(x){
                            x[1]
                          })
Numbercharacter<-sapply(strsplit(camDur$nestID, ""),
                        function(x){
                          x[2]
                        })    
                          
camDur$nestTYPE<-paste0(Queencharacter, Numbercharacter)

## remove data from nest types other than the ones we want (remove bad data)
camDur <- subset(camDur, subset = (camDur$nestTYPE == "NT" | camDur$nestTYPE == "NF" | camDur$nestTYPE == "QT" | camDur$nestTYPE == "QF"))

sumsTYPE<-camDur %>% group_by(nestTYPE)
ggplot(camDur, aes(x=nestID, y=forLen, fill = nestTYPE)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90))

ggplot(camDur, aes(x=nestID, y=nestLen, fill = nestTYPE)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90))

## look at data we have so far based on each type of colony 

ggplot(sumsTYPE, aes(x=nestTYPE, y=forLen, fill = nestTYPE)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90))

ggplot(sumsTYPE, aes(x=nestTYPE, y=nestLen, fill = nestTYPE)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90))

## print number of seconds and hours of video watched

## summary of all videos
allNestH <- sum(camDur$nestLen)/60/60
allForH <- sum(camDur$forLen)/60/60
allVideosH <- sum(camDur$totalLen)/60/60
avgNestH <- mean(camDur$nestLen)/60/60
avgForH <- mean(camDur$forLen)/60/60
avgTotalH <- mean(camDur$totalLen)/60/60

# summary by group
avgNFnestH <- mean(camDur$nestLen[camDur$nestTYPE == "NF"])/60/60
avgNTnestH <- mean(camDur$nestLen[camDur$nestTYPE == "NT"])/60/60
avgQFnestH <- mean(camDur$nestLen[camDur$nestTYPE == "QF"])/60/60
avgQTnestH <- mean(camDur$nestLen[camDur$nestTYPE == "QT"])/60/60

avgNFforH <- mean(camDur$forLen[camDur$nestTYPE == "NF"])/60/60
avgNTforH <- mean(camDur$forLen[camDur$nestTYPE == "NT"])/60/60
avgQFforH <- mean(camDur$forLen[camDur$nestTYPE == "QF"])/60/60
avgQTforH <- mean(camDur$forLen[camDur$nestTYPE == "QT"])/60/60

# print summaries
print(paste("We watched", round(allNestH, digits = 1), "hours of NEST videos overall, which is an average of", round(avgNestH, digits = 1), "hours per colony", sep = " "))
print(paste("We watched", round(allForH, digits = 1), "hours of FORAGING videos overall, which is an average of", round(avgForH, digits = 1), "hours per colony", sep = " "))
print(paste("We watched", round(allVideosH, digits = 1), "hours of ALL videos overall, which is an average of", round(avgTotalH, digits = 1), "hours per colony", sep = " "))

print(paste("NF COLONIES: we watched an average of", round(avgNFnestH, digits = 1), "hours of NEST and", round(avgNFforH, digits = 1), "hours of FOR", sep = " "))
print(paste("NT COLONIES: we watched an average of", round(avgNTnestH, digits = 1), "hours of NEST and", round(avgNTforH, digits = 1), "hours of FOR", sep = " "))
print(paste("QF COLONIES: we watched an average of", round(avgQFnestH, digits = 1), "hours of NEST and", round(avgQFforH, digits = 1), "hours of FOR", sep = " "))
print(paste("QT COLONIES: we watched an average of", round(avgQTnestH, digits = 1), "hours of NEST and", round(avgQTforH, digits = 1), "hours of FOR", sep = " "))

# summary by colony 
for (i in 1:nrow(camDur)) {
  print(paste(camDur$nestID[i], ": we watched a total of", round(camDur$nestLen[i]/60/60, digits = 1), "hours of NEST and", round(camDur$forLen[i]/60/60, digits = 1), "hours of FOR", sep = " "))
}
```


# visualize amount of video for each of the two timepoints (late and early)
```{r}
# rename it so i can manipulate from here
dates_data <- totalLen_data
dates_data
# pull out dateID from time ID
dates_data$dateID <- sapply(strsplit(dates_data$timeID, " "), 
                          function(x){
                            x[1]
                            } )
# format dateID as date so we can do math on it
dates_data$dateID <- as.Date(dates_data$dateID, "%Y%m%d")
dates_data

# add column for timepoint filled with NA values
dates_data$timepoint <- NA

# sort by nestID, then dateID
dates_data <- dates_data[order(dates_data$dateID),]
dates_data <- dates_data[order(dates_data$nestID),]
dates_data

# make empty early df
early_data <- data.frame(matrix(NA, nrow = 0, ncol = ncol(dates_data)))
## make column names the same
names(early_data) <- names(dates_data)

# make empty late df
late_data <- data.frame(matrix(NA, nrow = 0, ncol = ncol(dates_data)))
## make column names the same
names(late_data) <- names(dates_data)

# make empty error df
error_data <- data.frame(matrix(NA, nrow = 0, ncol = ncol(dates_data)))
## make column names the same
names(error_data) <- names(dates_data)

# for a given nestID
for(i in 1:length(unique(dates_data$nestID))) {
  # make a temporary dataframe containing info from only that nest
  nestid_data <- dates_data[dates_data$nestID == unique(dates_data$nestID)[i],]
  # add first row to early_data
  early_data <- rbind(early_data, nestid_data[1,])
  # for each dateID
  for(j in 2:nrow(nestid_data)) {
    # if dateID is less than or equal to previous dateID + 2
    if(nestid_data$dateID[j] <= nestid_data$dateID[1] + 2) {
      #   move that row to early_data df
      early_data <- rbind(early_data, nestid_data[j,])
    }
    # if dateID is more than or equal to previous dateID + 4
    else if(nestid_data$dateID[j] >= nestid_data$dateID[1] + 4) {
      #   move that row to late_data df
      late_data <- rbind(late_data, nestid_data[j,])
    } else {
      error_data <- rbind(error_data, nestid_data[j,])
    }
  }
}

early_data$timepoint <- "early"
late_data$timepoint <- "late"
dates_data <- rbind(early_data, late_data)
dates_data
head(dates_data)

```
```{r}
#plot it!

# subset the df to remove the obs, hour, and date columns
timepoint_data <- dates_data %>%
  dplyr::select(camID, nestID, totalLen)
# create empty dataframe to put length into
dateDur <- data.frame(nestID = NA,
                      early_forSum = NA,
                      late_forSum = NA,
                      early_nestSum = NA,
                      late_nestSum = NA)
# for each unique nest, subset the data to look at one nest at a time. then split out foraging and nest videos
for (i in 1:length(unique(dates_data$nestID))) {
  sub_data <- subset(dates_data, nestID == unique(dates_data$nestID)[i])       # subset to look at a single nest
  for_data <- subset(sub_data, sub_data$camID == "for")                        # subset foraging video only into for_data
  early_for_data <- subset(for_data, for_data$timepoint == "early")            # subset early foraging videos into early_for_data
  late_for_data <- subset(for_data, for_data$timepoint == "late")              # subset late foraging videos into late_for_data
  nest_data <- subset(sub_data, sub_data$camID == "nest")                      # subset nest video only into nest_data
  early_nest_data <- subset(nest_data, nest_data$timepoint == "early")         # subset early nest videos into early_nest_data
  late_nest_data <- subset(nest_data, nest_data$timepoint == "late")           # subset late nest videos into late_nest_data
  forSum <- sum(for_data$totalLen)                                             # sum the video duration of all foraging videos
  early_forSum <- sum(early_for_data$totalLen)                                 # sum the video duration of all early foraging videos
  late_forSum <- sum(late_for_data$totalLen)                                   # sum the video duration of all late foraging videos
  nestSum <- sum(nest_data$totalLen)                                           # sum the video duration of all nest videos
  early_nestSum <- sum(early_nest_data$totalLen)                               # sum the video duration of all early nest videos
  late_nestSum <- sum(late_nest_data$totalLen)                                      # sum the video duration of all late nest videos
  dateDur <- rbind(dateDur, c(sub_data$nestID[1], early_forSum, late_forSum, early_nestSum, late_nestSum, totalSum)) # add the sum totals to the dateDur df
}
# remove NA row initially created
dateDur <- dateDur[2:nrow(dateDur),]
dateDur


## Make a new column for nest type ie. NT or QT 
Queencharacter<-sapply(strsplit(dateDur$nestID, ""), 
                          function(x){
                            x[1]
                          })
Numbercharacter<-sapply(strsplit(dateDur$nestID, ""),
                        function(x){
                          x[2]
                        })    
dateDur$nestTYPE<-paste0(Queencharacter, Numbercharacter)

## gather sums into a single column to graph together
dateDur <- dateDur %>%
  gather(early_nestSum, late_nestSum, early_forSum, late_forSum, 
         key = "videoType", 
         value = "length")

dateDur$videoType <- factor(dateDur$videoType, levels = c("early_forSum", "late_forSum", "early_nestSum", "late_nestSum"))
dateDur$length <- as.numeric(dateDur$length)

#proportion of early to late for NF
sumsTOTAL <- dateDur %>%  filter(nestTYPE=="NF")
sumsTOTAL %>% ggplot(aes(x=nestID, y=length, fill=videoType)) + 
              geom_bar(stat="identity", position = position_dodge()) + 
              theme(axis.text.x = element_text(angle = 90), legend.position="top")

#proportion of early to late for NT
sumsTOTAL <- dateDur %>%  filter(nestTYPE=="NT")
sumsTOTAL$length <- as.numeric(sumsTOTAL$length)
sumsTOTAL %>% ggplot(aes(x=nestID, y=length, fill=videoType)) + 
              geom_bar(stat="identity", position = position_dodge()) + 
              theme(axis.text.x = element_text(angle = 90), legend.position="top")

#proportion of early to late for QT
sumsTOTAL <- dateDur %>%  filter(nestTYPE=="QT")
sumsTOTAL %>% ggplot(aes(x=nestID, y=length, fill=videoType)) + 
              geom_bar(stat="identity", position = position_dodge()) + 
              theme(axis.text.x = element_text(angle = 90), legend.position="top")

#proportion of early to late for QF
sumsTOTAL <- dateDur %>%  filter(nestTYPE=="QF")
sumsTOTAL %>% ggplot(aes(x=nestID, y=length, fill=videoType)) + 
              geom_bar(stat="identity", position = position_dodge()) + 
              theme(axis.text.x = element_text(angle = 90), legend.position="top")

#all nests individually
sumsTOTAL <- dateDur %>% group_by(nestID, videoType)
ggplot(sumsTOTAL, aes(x = nestID, y = length, fill = videoType)) +
  geom_bar(stat ="identity") + 
  theme(axis.text.x = element_text(angle = 90), legend.position = "top")

#all nests by group
sumsTYPE <- dateDur %>% group_by(nestTYPE)
ggplot(sumsTYPE, aes(x=nestTYPE, y = length, fill = videoType)) +
  geom_bar(stat = "identity", position = position_dodge()) + 
  theme(axis.text.x = element_text(angle = 90), legend.position = "top")

dateDur
sumsTOTAL
sumsTYPE

```


import egglaying data
```{r}
#Import egglaying data - find median timepoint, make early/late column and then merge to nestDEV
head(nestDEV)
egglaying<-read.csv("../Data/Egg_laying_Events.csv")
egglaying

#Change date to same format as above
egglaying$Date.Eggs.Laid <- as.Date(egglaying$Date.Eggs.Laid, "%m/%d/%y")

#Rename date name and microcolony name in egglaying to match dateID in nestDEV 
egglaying<-egglaying %>% dplyr::rename(dateID=Date.Eggs.Laid)
egglaying<-egglaying %>% dplyr::rename(nestID=MicrocolonyID)

# #Calculate median date between egg laying events for each nestID
# datesmedian<-egglaying %>% group_by(nestID) %>% dplyr::summarize(median=(ceiling(max(dateID)-min(dateID))/2)+min(dateID))
# #Combine median date information with egglaying dataframe
# egglayingmedian <- dplyr::left_join(egglaying, datesmedian, by= c("nestID" = "nestID"))
# 
# #Now write a loop to go through each row and add it either to late or early 
# egglayingmedian$timepoint<-NA
# 
# # make empty early df
# eggsearly <- data.frame(matrix(NA, nrow = 0, ncol = ncol(egglayingmedian)))
# ## make column names the same
# names(eggsearly) <- names(egglayingmedian)
# # make empty late df
# eggslate <- data.frame(matrix(NA, nrow = 0, ncol = ncol(egglayingmedian)))
# ## make column names the same
# names(eggslate) <- names(egglayingmedian)
# # make empty error df
# eggserror <- data.frame(matrix(NA, nrow = 0, ncol = ncol(egglayingmedian)))
# ## make column names the same
# names(eggserror) <- names(egglayingmedian)
# 
# for(i in 1:nrow(egglayingmedian)){
#   #if dateID is less than or equal to median
#   if(egglayingmedian$dateID[i]<=egglayingmedian$median[i]){
#     #move that row to early data df
#     eggsearly<-rbind(eggsearly,egglayingmedian[i,])
#   }
#   else if (egglayingmedian$dateID[i]>egglayingmedian$median[i]){
#     eggslate<-rbind(eggslate, egglayingmedian[i,])
#   }
#   else {eggserror<-rbind(eggserror, egglayingmedian[i,])}
# }
# 
# #add early to timepoint column 
# eggsearly <-  eggsearly %>% mutate(timepoint="early")
# #add late to timepoint column 
# eggslate<-eggslate %>% mutate(timepoint="late")
# #Merge early and late dataframes
# eggstotal<-rbind(eggsearly, eggslate)

#eggstotal has all the egglaying information (observer, notes, etc.), select only variables we need for analysis
head(eggstotal)
eggsmerge<-eggstotal %>% dplyr::select(nestID, dateID, WorkerID, Caste, Time, timepoint)
head(eggsmerge)

```
Combine egg laying and nestDEV to make count data 
```{r}
head(eggsmerge)
#make behav column with egglaying
eggsmerge <- eggsmerge %>% mutate(behav="egglaying")
#Make sure they have the same column headers so that we can do rbind
eggsmergebind<-eggsmerge %>% dplyr::rename(beeID=WorkerID) %>% dplyr::rename(caste=Caste) %>% dplyr::select(nestID, beeID, caste, timepoint, behav, dateID)
head(eggsmergebind)
nestDEV
nestDEVbind<-nestDEV %>% dplyr::select(nestID, dateID, timepoint, behav, beeID, caste) 
nestDEVbind

# #Add caste information to nestDEVbind from CasteInfo
# head(CasteInfo)
# CasteInformation<-CasteInfo %>% rename(beeID=IDnum) %>% mutate(beeID=as.character(beeID))
# CasteInformation
# nestDEVcaste<-left_join(nestDEVbind, CasteInformation, by=c("nestID", "beeID" ))
# head(nestDEVcaste)

# #Use string split to make a column with either W (worker) or Q (queen) from IDtype
# nestDEVcaste$Caste<-sapply(strsplit(nestDEVcaste$IDtype, ""),
#                            function(x){
#                              x[1]
#                            })
# nestDEVcaste

# #Assign castes either as queens or workers 
# workers<-nestDEVcaste %>% filter(Caste=="W") %>% mutate(Caste="worker")
# queens<-nestDEVcaste %>% filter(Caste=="Q") %>% mutate(Caste="queen")
# #Fix NAs by double checking master data sheet 
# #All worker colonies except QT02, and queen is 85 - no queen behavioral observations
# #so label all NAs as worker caste 
# nahs<-nestDEVcaste %>% filter(!Caste %in% c("W", "Q")) %>% mutate(Caste="worker")
# nahs
# nestDEVCaste<-rbind(workers, queens, nahs)
# nestDEVCaste<-nestDEVCaste %>% select(nestID, dateID, timepoint, behav, beeID, Caste)

#Assign castes either as queens or workers 
workers<-nestDEVbind %>% filter(caste=="W") %>% mutate(caste="worker")
queens<-nestDEVbind %>% filter(caste=="Q") %>% mutate(caste="queen")
#Fix NAs by double checking master data sheet 
#All worker colonies except QT02, and queen is 85 - no queen behavioral observations
#so label all NAs as worker caste 
nahs<-nestDEVbind %>% filter(!caste %in% c("W", "Q")) %>% mutate(caste="worker")
print(paste(nrow(workers), "workers +", nrow(queens), "queens +", nrow(nahs), "nahs", sep = " " ))
nahs
queens
workers
nestDEVbind<-rbind(workers, queens, nahs)
nestDEVbind
nestDEVbind<-nestDEVbind %>% dplyr::select(nestID, dateID, timepoint, behav, beeID, caste)

unique(nestDEVbind$caste)
nestDEVbind[nestDEVbind$beeID == "unknown",]

#Combine egglaying and worker behaviors
mergedbehavs<-rbind(nestDEVbind, eggsmergebind)
mergedbehavs
eggsmergebind %>% filter(nestID=="QT12")

###############################

#Now turn mergedbehavs into count data so we can do stats :) 
mergedbehavs$count<-1

## add random number column to make table compatible with pivot_wider. needs a unique identifier for each individual
mergedbehavs$rand <- NA
for (i in 1:(nrow(mergedbehavs))) {
  mergedbehavs$rand[i] <- runif(1)
}

## condense data frame into relevant columns, each row is a single observation for an individual
counts_final <- mergedbehavs %>%
  pivot_wider(id_cols = c("nestID", "beeID", "caste", "behav", "timepoint"),
              names_from = rand, 
              values_from = count) 

###############################

## add column to fill with sum of counts for each behav
counts_final$totCount <- rowSums(counts_final[6:ncol(counts_final)], na.rm = TRUE)

## subset dataframe so that all is left is variables of interest
counts_final <- counts_final %>%
  dplyr::select(nestID, beeID, caste, timepoint, behav, totCount)

## collapse dataframe so that each bee has one single row. cols = nestID, beeID, nectarforaging, *other behaviors
counts_final <- counts_final %>%
  pivot_wider(id_cols = c("nestID", "beeID", "caste", "timepoint"), 
              names_from = behav, 
              values_from = totCount)

## sum rows excluding first 4 (nestID and beeID, caste, timepoint) to see total number of behaviors carried out by each indiv
counts_final$nBehavs <- rowSums(counts_final[, 5:ncol(counts_final)], na.rm = TRUE)

## add column for nest type ie. NT or QT etc.
queenlessChar <- sapply(strsplit(counts_final$nestID, ""), 
                          function(x){
                            x[1]
                          })
numberChar <- sapply(strsplit(counts_final$nestID, ""),
                        function(x){
                          x[2]
                        })    
counts_final$nestTYPE <- paste0(queenlessChar, numberChar)

## add column for number of bees in the nest
counts_final$nBees <- NA
counts_final
counts_final$nBees[counts_final$nestTYPE == "NF"] <- 5
counts_final$nBees[counts_final$nestTYPE == "NT"] <- 3
counts_final$nBees[counts_final$nestTYPE == "QF"] <- 6
counts_final$nBees[counts_final$nestTYPE == "QT"] <- 4

## add column for number of workers in the nest
counts_final$nWork <- NA
counts_final$nWork[counts_final$nestTYPE == "NF"] <- 5
counts_final$nWork[counts_final$nestTYPE == "NT"] <- 3
counts_final$nWork[counts_final$nestTYPE == "QF"] <- 5
counts_final$nWork[counts_final$nestTYPE == "QT"] <- 3

## add column for queen presence
counts_final$queen <- NA
counts_final$queen[counts_final$nestTYPE == "NF"] <- 0
counts_final$queen[counts_final$nestTYPE == "NT"] <- 0
counts_final$queen[counts_final$nestTYPE == "QF"] <- 1
counts_final$queen[counts_final$nestTYPE == "QT"] <- 1
counts_final$queen <- as.character(counts_final$queen)

## make NA values equal to 0
counts_final[is.na(counts_final)] <- 0

## subset to remove the behaviors we're not interested in (remove behavs only used in erica's time budgeting)
countsDATA <- counts_final %>%
  dplyr::select(nestID, nestTYPE, beeID, caste, nBees, nWork, queen, timepoint, feedsbrood, nectarforaging, pollenforaging, egglaying, nBehavs)

write.csv(countsDATA, "../Data/countsanalysis.csv") 

countsDATA
```
