---
title: "taskOrganization"
output: pdf_document
---

# plot size adjustments
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# # multipanel single task framework plots
# knitr::opts_chunk$set(fig.width=3, fig.height=5) 
    
# # multipanel nmds plot
# knitr::opts_chunk$set(fig.width=3, fig.height=3.6) 

# # multipanel counts of specialists per nest for categorical frameworks plot
# knitr::opts_chunk$set(fig.width=3.6, fig.height=5.5) 

# # multipanel rptr plot
# knitr::opts_chunk$set(fig.width=2.5, fig.height=3.5) 



```

# load packages
```{r, echo = FALSE}
library(ggplot2)  # plots
library(ggpubr)   # ggdensity plots
library(lme4)     # glmms
library(sjPlot)   # model summary
library(multcomp) # tukey tests
library(car)      # qqp
library(MuMIn)    # model.sel
library(tidyverse)
library(plotly)   # plot kmeans
library(plyr)
library(dplyr)
library(factoextra)
library(vegan) 
library(effects)  # plot output of glmm
library(lsmeans)
library(MASS)
library(rptR)
library(tidyr)
library(cluster)  # clustering algorithms
library(ggforce)  # circles on graphs
```

# load data
```{r}
# pooled data across timepoints, values are counts
count_data <- read.csv("../Data/filtData/count_data.csv")
  # remove queens, make separate df with only workers with >=3 observations workers
count_data <- count_data[count_data$caste == "W",]
count_3 <- count_data[count_data$lazy == "notLazy",]

# split across timepoints, includes all bees, but only known bees with >=3 observations have shannon values
count_time <- read.csv("../Data/filtData/count_time.csv")
count_time <- count_time[count_time$caste == "W",]
count_3Time <- count_time[count_time$lazy == "notLazy",]

```

#.

# SHANNON VALUE
 shannon calcluated in cleanData script
## nest type models
 Two part model: How specialized are individuals? 
```{r}
# use workers with >=3 behaviors only

nrow(count_3)
# make a new column for over or under 0
count_3$shan0 <- NA
# if shannon = 0, shan0 = 1
count_3$shan0[count_3$shannon == 0] <- 1
# if shannon > 0, shan0 = 0
count_3$shan0[count_3$shannon > 0] <- 0

shanzero<-count_3 %>% filter(shan0=="1")
#How many are perfectly specialized? 
nrow(shanzero)

#Max shannon
max(count_3$shannon)
```

Pt 1. Bees with shannon=0
nBehavs is significant
```{r}
# model 0 vs. >0 shannon values
ps0 <- glmer(shan0 ~ 1 + (1|nestID) + (1|natal),
              data = count_3, family = binomial(link = "logit"))
ps1 <- glmer(shan0 ~ nestTYPE + nBehavs + (1|nestID) + (1|natal),
              data = count_3, family = binomial(link = "logit"))
ps2 <- glmer(shan0 ~ nestTYPE + nBehavs + (1|nestID) + (1|natal),
              data = count_3, family = binomial(link = "logit"))
ps3 <- glmer(shan0 ~ nestTYPE + nBehavs + (1|nestID) + (1|natal),
              data = count_3, family = binomial(link = "logit"))

model.sel(ps0, ps1, ps2, ps3)

#Best model is ps1

mymodel <- ps1
tab_model(mymodel)
summary(mymodel)

# plot model residuals
plot(fitted(mymodel), residuals(mymodel), xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, lty = 2)
lines(smooth.spline(fitted(mymodel), residuals(mymodel)))
```

Pt 2. Bees with shannon >0
null model is best
```{r}
# make a new column that contains only shannon for bees with shannon > 0
count_3$shan1 <- NA
count_3$shan1[count_3$shannon > 0] <- count_3$shannon[count_3$shannon > 0]

# it's mostly normal
qqp(count_3$shan1, "norm")

# model 0 vs. >0 shannon values
ps0 <- glmer(shan1 ~ 1 + (1|nestID)  + (1|natal),
              data = count_3)
ps1 <- glmer(shan1 ~ nestTYPE + nBehavs + (1|nestID) + (1|natal),
              data = count_3)
ps2 <- glmer(shan1 ~ nestTYPE + (1|nestID) + (1|natal),
              data = count_3)
ps3 <- glmer(shan1 ~ nBehavs + (1|nestID) + (1|natal),
              data = count_3)

model.sel(ps0, ps1, ps2, ps3)

mymodel <- ps0
tab_model(mymodel)
summary(mymodel)

# plot model residuals
modelResiduals <- resid(mymodel, type = "pearson") # Extract standardized residuals 
hist(modelResiduals)
```

## body size & ovary development models
null model is best fit for all
```{r}
#Body Size 
head(count_3)
hist(count_3$size)

s0 <- glmer(size ~ 1 + (1|natal) + (1|nestTYPE:nestID), data = count_3)
s1 <- glmer(size ~ shannon + (1|natal) + (1|nestTYPE:nestID), data = count_3)

model.sel(s0, s1)

#Ovary Resporbtion 
hist(count_3$ovRavg)
s0 <- glmer(ovRavg ~ 1 + (1|natal) + (1|nestTYPE:nestID), data = count_3)
s1 <- glmer(ovRavg ~ shannon + (1|natal) + (1|nestTYPE:nestID), data = count_3)

model.sel(s0, s1)

#Ovary Stage 
hist(count_3$ovSavg)
s0 <- glmer(ovSavg ~ 1 + (1|natal) + (1|nestTYPE:nestID), data = count_3)
s1 <- glmer(ovSavg ~ shannon + (1|natal) + (1|nestTYPE:nestID), data = count_3)

model.sel(s0, s1)
```



#.

# -CATEGORICAL TASK FRAMEWORKS-

# KMEANS

K Means Cluster Analyses -- determine whether points cluster into two or more groups
include all bees (including <3)

Elbow Method for finding the optimal number of clusters. optimal number of clusters = elbow of the graph. (in this case 3)

## clustering

 find number of clusters
```{r}
## set seed of random number generator for reproducibility
set.seed(123)

## compute and plot total within sum of squares for 2-10 clusters
k.max <- 10
## make sure the subset of count_data here includes feedsbrood, nectarforage, pollenforage, egglaying
data <- count_data[, c("feedsbrood", "nectarforaging", "pollenforaging", "egglaying")]

wss <- sapply(1:k.max,
              function(k){kmeans(data, k, nstart=50, iter.max = 20)$tot.withinss})
wss
## plot and look to find the elbow. here it is at 3
elbow <- plot(1:k.max, wss,
     type="b", pch = 19, frame = FALSE,
     xlab="Number of clusters K",
     ylab="Total within-clusters sum of squares")
```

 run k means analysis
```{r}
## set random number generator seed for reproducibility
set.seed(124)

## set k based on where elbow is in above graph
k <- 2

## run k means test
test <- kmeans(data, k, nstart = 20)
length(as.factor(test$cluster))
```
 
 graph k means analysis
```{r} 
count_data$cluster <- test$cluster

# make cluster a factor so we can graph with it
count_data$cluster <- as.factor(count_data$cluster)

# graph clusters in 3d plot
plot_ly(x = count_data$feedsbrood,
        y = count_data$allforaging,
        z = count_data$egglaying,
        type="scatter3d",
        mode="markers",
        color = count_data$cluster, colors = c('maroon', 'steelblue'),
        marker = list(size = 4)) %>%
  layout(
    title = "K-means clustering",
    scene = list(
      xaxis = list(title = "Brood feeding"),
      yaxis = list(title = "Resource collection"),
      zaxis = list(title = "Egg laying"))
  )
```
 
## body size & ovary development models
body size is significant
```{r}
kmeanstrends<-count_data %>% dplyr::select(size, ovSavg, cluster) %>% na.omit()

graphkmeans<-kmeanstrends %>% group_by(cluster) %>%
  mutate(asize=mean(size)) %>%
  mutate(sdsize=sd(size)) %>%
  mutate(aov=mean(ovSavg))  %>%
  mutate(sdov=sd(ovSavg)) %>%
  dplyr::select(cluster, asize, sdsize, aov, sdov) %>% unique()

ggplot(graphkmeans, aes(x=cluster, y=asize)) +
    geom_bar(stat="identity", position=position_dodge(), colour="black") +
  geom_errorbar(aes(ymin=asize-sdsize,  ymax=asize+sdsize))

ggplot(graphkmeans, aes(x=cluster, y=aov)) +
    geom_bar(stat="identity", position=position_dodge(), colour="black") +
  geom_errorbar(aes(ymin=aov-sdov,  ymax=aov+sdov))


count_data$cluster <- as.factor(count_data$cluster)

hist(count_data$ovSavg)
k0 <- glmer(ovSavg ~ 1 + (1|natal) + (1|nestTYPE:nestID),
            data = count_data)

k1 <- lmer(ovSavg ~ cluster + (1|natal) + (1|nestTYPE:nestID),
            data = count_data)
model.sel(k0, k1)

k2 <- lmer(size ~ 1 + (1|natal) + (1|nestTYPE:nestID),
            data = count_data)

k3 <- lmer(size ~ cluster + (1|natal) + (1|nestTYPE:nestID),
            data = count_data)
model.sel(k2, k3)

k4<-lmer(ovRavg~1+ (1|natal) + (1|nestTYPE:nestID),
            data = count_data)

k5<-lmer(ovRavg~cluster+ (1|natal) + (1|nestTYPE:nestID),
            data = count_data)
model.sel(k4, k5)
```

## analyze counts of specialists
 cluster and nest type significantly predict number of specialists per nest
```{r}
paste(nrow(count_data[count_data$cluster == "1",]), "kmeans cluster 1")
paste(nrow(count_data[count_data$cluster == "2",]), "kmeans cluster 2")

# How many specialists are in each nest?
kdata <- count_data
kdata_nestSum <- as.data.frame(matrix(0, nrow = length(unique(kdata$nestID)), ncol = 5))
names(kdata_nestSum) <- c("nestTYPE", "natal", "nestID", "one", "two")
kdata_nestSum$nestID <- unique(kdata$nestID)

# summarize by nest
for (i in 1:nrow(kdata_nestSum)) {
  for (j in 1:nrow(kdata)) {
    if (kdata$nestID[j] == kdata_nestSum$nestID[i]) {
      kdata_nestSum$nestTYPE[i] <- kdata$nestTYPE[j]
      kdata_nestSum$natal[i] <- kdata$natal[j]
      if (kdata$cluster[j] == "1") {
        kdata_nestSum$one[i] <- kdata_nestSum$one[i] + 1
      }
      if (kdata$cluster[j] == "2") {
        kdata_nestSum$two[i] <- kdata_nestSum$two[i] + 1
      }
    }
  }
}

# gather df to plot
kdata_nestSum <- kdata_nestSum %>%
  gather(one, two,
         key = "cluster", 
         value = "number")

# plot it
G4 <- ggplot(kdata_nestSum, aes(cluster, number, color = nestTYPE)) + 
  geom_point(position = position_jitter(width=.2, height=0.2), alpha = 0.7) +
  scale_color_manual(values = c("#fdb863", "#e66101", "#b2abd2", "#5e3c99"), labels = c("W3", "W5", "QW3", "QW5")) +
  stat_summary(fun = mean, geom = "point", size = 4, shape = 21, aes(fill = nestTYPE), color = "black") +
  scale_fill_manual(values = c("#fdb863", "#e66101", "#b2abd2", "#5e3c99")) +
  ggtitle("Most frequently performed task") +
  scale_x_discrete(labels=c("el" = "Egg\nlaying", "fb" = "Brood\nfeeding", "nf" = "Nectar\ncollection", "pf" = "Pollen\ncollection", "gen" = "Generalist", "oth" = "Other")) +
  labs(color="Social configuration", y = "Number of individuals per nest", x = "Task") +
  guides(fill=FALSE, color = guide_legend(override.aes = list(size = 5)))
G4

# Does number of bees in each category per nest differ based on nest type or behavior?
# Poisson
ggdensity(kdata_nestSum$number)
qqp(kdata_nestSum$number, "norm")
hist(kdata_nestSum$number)

H0<-glmer(number ~ 1 + (1|natal), data=kdata_nestSum, family=poisson)
H1<-glmer(number~ cluster + (1|natal), data=kdata_nestSum, family=poisson)
H2<-glmer(number~ nestTYPE + (1|natal), data=kdata_nestSum, family=poisson)
H3<-glmer(number~ cluster + nestTYPE + (1|natal), data=kdata_nestSum, family=poisson)
H4<-glmer(number~ cluster*nestTYPE + (1|natal), data=kdata_nestSum, family=poisson)

model.sel(H0, H1, H2, H3, H4)

mymodel <- H3
summary(mymodel)
tab_model(mymodel)

# plot model residuals
plot(fitted(mymodel), residuals(mymodel), xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, lty = 2)
lines(smooth.spline(fitted(mymodel), residuals(mymodel)))
```

# SHANNON THRESHOLD
 threshold specialization (specBehav) calculated in cleanData script
## body size & ovary development models
 null models fit best
```{r}
#Body Size 
hist(count_data$size)

s0 <- glmer(size ~ 1 + (1|natal) + (1|nestTYPE:nestID), data = count_data)
s1 <- glmer(size ~ specBehav + (1|natal) + (1|nestTYPE:nestID), data = count_data)

model.sel(s0, s1)
# Behavioral group not included in best model 

#Ovary Resporption 
hist(count_data$ovRavg)
s0 <- glmer(ovRavg ~ 1 + (1|natal) + (1|nestTYPE:nestID), data = count_data)
s1 <- glmer(ovRavg ~ specBehav + (1|natal) + (1|nestTYPE:nestID), data = count_data)

model.sel(s0, s1)

#Ovary Stage 
hist(count_data$ovSavg)
s0 <- glmer(ovSavg ~ 1 + (1|natal) + (1|nestTYPE:nestID), data = count_data)
s1 <- glmer(ovSavg ~ specBehav + (1|natal) + (1|nestTYPE:nestID), data = count_data)

model.sel(s0, s1)
```

## analyze counts of specialists
 behavior alone significantly predicts number of specialists per nest
```{r}
paste(nrow(count_data[count_data$specBehav == "nectarforaging",]), "shannon nectar collectors")
paste(nrow(count_data[count_data$specBehav == "pollenforaging",]), "shannon pollen collectors")
paste(nrow(count_data[count_data$specBehav == "feedsbrood",]), "shannon brood feeders")
paste(nrow(count_data[count_data$specBehav == "egglaying",]), "shannon egg layers")
paste(nrow(count_data[count_data$specBehav == "generalist",]), "shannon generalists")
paste(nrow(count_data[count_data$specBehav == "lazy",]), "shannon other")
paste(nrow(count_data), "total shannon categorized")

# How many specialists are in each nest?
shanBehav <- count_data
shanBehav_nestSum <- as.data.frame(matrix(0, nrow = length(unique(shanBehav$nestID)), ncol = 9))
names(shanBehav_nestSum) <- c("nestTYPE", "natal", "nestID", "nf", "pf", "bf", "el", "gen", "oth")
shanBehav_nestSum$nestID <- unique(shanBehav$nestID)

# summarize by nest
for (i in 1:nrow(shanBehav_nestSum)) {
  for (j in 1:nrow(shanBehav)) {
    if (shanBehav$nestID[j] == shanBehav_nestSum$nestID[i]) {
      shanBehav_nestSum$nestTYPE[i] <- shanBehav$nestTYPE[j]
      shanBehav_nestSum$natal[i] <- shanBehav$natal[j]
      if (shanBehav$specBehav[j] == "nectarforaging") {
        shanBehav_nestSum$nf[i] <- shanBehav_nestSum$nf[i] + 1
      }
      if (shanBehav$specBehav[j] == "pollenforaging") {
        shanBehav_nestSum$pf[i] <- shanBehav_nestSum$pf[i] + 1
      }
      if (shanBehav$specBehav[j] == "feedsbrood") {
        shanBehav_nestSum$bf[i] <- shanBehav_nestSum$bf[i] + 1
      }
      if (shanBehav$specBehav[j] == "egglaying") {
        shanBehav_nestSum$el[i] <- shanBehav_nestSum$el[i] + 1
      }
      if (shanBehav$specBehav[j] == "generalist") {
        shanBehav_nestSum$gen[i] <- shanBehav_nestSum$gen[i] + 1
      }
      if (shanBehav$specBehav[j] == "other") {
        shanBehav_nestSum$oth[i] <- shanBehav_nestSum$oth[i] + 1     
      }
    }
  }
}

# gather df to plot
shanBehav_nestSum <- shanBehav_nestSum %>%
  gather(nf, pf, bf, el, gen, oth,
         key = "behav", 
         value = "number")

# plot it
G2 <- ggplot(shanBehav_nestSum, aes(behav, number, color = nestTYPE)) + 
  geom_point(position = position_jitter(width=.2, height=0.2), alpha = 0.7) +
  scale_color_manual(values = c("#fdb863", "#e66101", "#b2abd2", "#5e3c99"), labels = c("W3", "W5", "QW3", "QW5")) +
  stat_summary(fun = mean, geom = "point", size = 4, shape = 21, aes(fill = nestTYPE), color = "black") +
  scale_fill_manual(values = c("#fdb863", "#e66101", "#b2abd2", "#5e3c99")) +
  ggtitle("Most frequently performed task") +
  scale_x_discrete(labels=c("el" = "Egg\nlaying", "fb" = "Brood\nfeeding", "nf" = "Nectar\ncollection", "pf" = "Pollen\ncollection", "gen" = "Generalist", "oth" = "Other")) +
  labs(color="Social configuration", y = "Number of individuals per nest", x = "Task") +
  guides(fill=FALSE, color = guide_legend(override.aes = list(size = 5)))
G2

# Does number of bees in each category per nest differ based on nest type or behavior?
# Poisson
ggdensity(shanBehav_nestSum$number)
qqp(shanBehav_nestSum$number, "norm")
hist(shanBehav_nestSum$number)

H0<-glmer(number ~ 1 + (1|natal), data=shanBehav_nestSum, family=poisson)
H1<-glmer(number~ behav + (1|natal), data=shanBehav_nestSum, family=poisson)
H2<-glmer(number~ nestTYPE + (1|natal), data=shanBehav_nestSum, family=poisson)
H3<-glmer(number~ behav + nestTYPE + (1|natal), data=shanBehav_nestSum, family=poisson)
H4<-glmer(number~ behav*nestTYPE + (1|natal), data=shanBehav_nestSum, family=poisson)

model.sel(H0, H1, H2, H3, H4)

mymodel <- H1
summary(mymodel)
tab_model(mymodel)

# plot model residuals
plot(fitted(mymodel), residuals(mymodel), xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, lty = 2)
lines(smooth.spline(fitted(mymodel), residuals(mymodel)))
```

# MOST FREQUENTLY PERFORMED TASK
 Analysis based on highest number of tasks workers perform 

## establish categories
```{r}
#filter so all bees have >= 3 behaviors (exclude lazies)
high_behav<-count_3

highbehav<-high_behav %>% dplyr::select(beeID, nectarforaging, 
                                 feedsbrood, pollenforaging, egglaying)

hbdf<-highbehav %>% pivot_longer(!beeID, names_to="Behavior", values_to="count")

#Sort each bee by which behavior they do the most and then assign that bee to that behavior
BehavAssign<-hbdf %>% group_by(beeID) %>% arrange(beeID, desc(count)) %>% slice_head() %>% mutate(BehavAssign=Behavior) %>% dplyr::select(beeID, BehavAssign)

#Merge back into original dataframe
FinalBehavRank<-left_join(high_behav, BehavAssign, by="beeID")
FinalBehavRank$BehavAssign <-as.factor(FinalBehavRank$BehavAssign)

#add highest count to count_data
count_data <- left_join(count_data, BehavAssign, by="beeID")
```

## body size & ovary development models
 null models fit best
```{r}
#Body Size 
hist(FinalBehavRank$size)
head(FinalBehavRank)

s0 <- glmer(size ~ 1 + (1|natal) + (1|nestTYPE:nestID), data = FinalBehavRank)
s1 <- glmer(size ~ BehavAssign + (1|natal) + (1|nestTYPE:nestID), data = FinalBehavRank)

model.sel(s0, s1)
# Behavioral group not included in best model 

#Ovary Resporbtion 
hist(FinalBehavRank$ovRavg)
s0 <- glmer(ovRavg ~ 1 + (1|natal) + (1|nestTYPE:nestID), data = FinalBehavRank)
s1 <- glmer(ovRavg ~ BehavAssign + (1|natal) + (1|nestTYPE:nestID), data = FinalBehavRank)

model.sel(s0, s1)

#Ovary Stage 
hist(FinalBehavRank$ovSavg)
s0 <- glmer(ovSavg ~ 1 + (1|natal) + (1|nestTYPE:nestID), data = FinalBehavRank)
s1 <- glmer(ovSavg ~ BehavAssign + (1|natal) + (1|nestTYPE:nestID), data = FinalBehavRank)

model.sel(s0, s1)
```

## analyze counts of specialists
 behavior alone significantly predicts number of specialists per nest
```{r}
# How many bees are in each category? 
paste(nrow(FinalBehavRank[FinalBehavRank$BehavAssign == "nectarforaging",]), "highest counts nectar collectors")
paste(nrow(FinalBehavRank[FinalBehavRank$BehavAssign == "pollenforaging",]), "highest counts pollen collectors")
paste(nrow(FinalBehavRank[FinalBehavRank$BehavAssign == "feedsbrood",]), "highest counts brood feeders")
paste(nrow(FinalBehavRank[FinalBehavRank$BehavAssign == "egglaying",]), "highest counts egg layers")

# How many specialists are in each nest?
highcounts <- FinalBehavRank
highcounts_nestSum <- as.data.frame(matrix(0, nrow = length(unique(highcounts$nestID)), ncol = 7))
names(highcounts_nestSum) <- c("nestTYPE", "natal", "nestID", "nf", "pf", "bf", "el")
highcounts_nestSum$nestID <- unique(highcounts$nestID)

# summarize by nest
for (i in 1:nrow(highcounts_nestSum)) {
  for (j in 1:nrow(highcounts)) {
    if (highcounts$nestID[j] == highcounts_nestSum$nestID[i]) {
      highcounts_nestSum$nestTYPE[i] <- highcounts$nestTYPE[j]
      highcounts_nestSum$natal[i] <- highcounts$natal[j]
      if (highcounts$BehavAssign[j] == "nectarforaging") {
        highcounts_nestSum$nf[i] <- highcounts_nestSum$nf[i] + 1
      }
      if (highcounts$BehavAssign[j] == "pollenforaging") {
        highcounts_nestSum$pf[i] <- highcounts_nestSum$pf[i] + 1
      }
      if (highcounts$BehavAssign[j] == "feedsbrood") {
        highcounts_nestSum$bf[i] <- highcounts_nestSum$bf[i] + 1
      }
      if (highcounts$BehavAssign[j] == "egglaying") {
        highcounts_nestSum$el[i] <- highcounts_nestSum$el[i] + 1
      }
    }
  }
}

# gather df to plot
highcounts_nestSum <- highcounts_nestSum %>%
  gather(nf, pf, bf, el, 
         key = "behav", 
         value = "number")

# plot it
G1 <- ggplot(highcounts_nestSum, aes(behav, number, color = nestTYPE)) + 
  geom_point(position = position_jitter(width=.2, height=0.2), alpha = 0.7) +
  scale_color_manual(values = c("#fdb863", "#e66101", "#b2abd2", "#5e3c99"), labels = c("W3", "W5", "QW3", "QW5")) +
  stat_summary(fun = mean, geom = "point", size = 4, shape = 21, aes(fill = nestTYPE), color = "black") +
  scale_fill_manual(values = c("#fdb863", "#e66101", "#b2abd2", "#5e3c99")) +
  ggtitle("Most frequently performed task") +
  scale_x_discrete(labels=c("egglaying" = "Egg\nlaying", "feedsbrood" = "Brood\nfeeding", "nectarforaging" = "Nectar\ncollection", "pollenforaging" = "Pollen\ncollection")) +
  labs(color="Social configuration", y = "Number of individuals per nest", x = "Task") +
  guides(fill=FALSE, color = guide_legend(override.aes = list(size = 5)))
G1

# Does number of bees in each category per nest differ based on nest type or behavior?
# Poisson
ggdensity(highcounts_nestSum$number)
qqp(highcounts_nestSum$number, "norm")
hist(highcounts_nestSum$number)

H0<-glmer(number ~ 1 + (1|natal), data=highcounts_nestSum, family=poisson)
H1<-glmer(number~ behav + (1|natal), data=highcounts_nestSum, family=poisson)
H2<-glmer(number~ nestTYPE + (1|natal), data=highcounts_nestSum, family=poisson)
H3<-glmer(number~ behav + nestTYPE + (1|natal), data=highcounts_nestSum, family=poisson)
H4<-glmer(number~ behav*nestTYPE + (1|natal), data=highcounts_nestSum, family=poisson)

model.sel(H0, H1, H2, H3, H4)

mymodel <- H1
summary(mymodel)
tab_model(mymodel)

# plot model residuals
plot(fitted(mymodel), residuals(mymodel), xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, lty = 2)
lines(smooth.spline(fitted(mymodel), residuals(mymodel)))
```

# PERFECTLY SPECIALIZED 

## establish categories
```{r}
# subset to look only at perfectly specialized individuals
perfSpec <- count_3 %>% filter(shannon=="0")

perfgraph<-perfSpec %>% dplyr::select(specBehav, beeID, ovSavg)
perfgraph <-perfgraph[complete.cases(perfgraph),]

# add perfSpec to count_data
count_data$perfSpec <- NA
for (i in 1:nrow(count_data)) {
  if (is.na(count_data$specProp[i])) {
  } else if (count_data$specProp[i] == 1) {
    count_data$perfSpec[i] <- count_data$specBehav[i] 
    }
}
```


## body size & ovary development models
 null models fit best
```{r}
#Body Size 
hist(perfSpec$size)

s0 <- glmer(size ~ 1 + (1|natal) + (1|nestTYPE:nestID), data = perfSpec)
s1 <- glmer(size ~ specBehav + (1|natal) + (1|nestTYPE:nestID), data = perfSpec)

model.sel(s0, s1)

#Ovary Resporbtion 
hist(perfSpec$ovRavg)
s0 <- glmer(ovRavg ~ 1 + (1|natal) + (1|nestTYPE:nestID), data = perfSpec)
s1 <- glmer(ovRavg ~ specBehav + (1|natal) + (1|nestTYPE:nestID), data = perfSpec)

model.sel(s0, s1)

#Ovary Stage 
hist(perfSpec$ovSavg)
s0 <- glmer(ovSavg ~ 1 + (1|natal) + (1|nestTYPE:nestID), data = perfSpec)
s1 <- glmer(ovSavg ~ specBehav + (1|natal) + (1|nestTYPE:nestID), data = perfSpec)

model.sel(s0, s1)
```

## analyze counts of specialists
 behavior alone significantly predicts number of specialists in a nest
```{r}
# How many bees perform more than one task? 
paste(nrow(perfSpec), "perfectly specialized workers")
paste(nrow(count_data) - nrow(perfSpec), "workers perform multiple tasks")
paste(nrow(perfSpec) / nrow(count_data) * 100, "percent perfectly specialized workers")
paste((1 - nrow(perfSpec)) / nrow(count_data) * 100, "percent of workers perform multiple tasks")

paste(nrow(perfSpec[perfSpec$specBehav == "nectarforaging",]), "perfectly specialized nectar collectors")
paste(nrow(perfSpec[perfSpec$specBehav == "pollenforaging",]), "perfectly specialized pollen collectors")
paste(nrow(perfSpec[perfSpec$specBehav == "feedsbrood",]), "perfectly specialized brood feeders")
paste(nrow(perfSpec[perfSpec$specBehav == "egglaying",]), "perfectly specialized egg layers")

# How many specialists are in each nest?
perfSpec_nestSum <- as.data.frame(matrix(0, nrow = length(unique(perfSpec$nestID)), ncol = 7))
names(perfSpec_nestSum) <- c("nestTYPE", "natal", "nestID", "nf", "pf", "bf", "el")
perfSpec_nestSum$nestID <- unique(perfSpec$nestID)

# summarize by nest
for (i in 1:nrow(perfSpec_nestSum)) {
  for (j in 1:nrow(perfSpec)) {
    if (perfSpec$nestID[j] == perfSpec_nestSum$nestID[i]) {
      perfSpec_nestSum$nestTYPE[i] <- perfSpec$nestTYPE[j]
      perfSpec_nestSum$natal[i] <- perfSpec$natal[j]
      if (perfSpec$specBehav[j] == "nectarforaging") {
        perfSpec_nestSum$nf[i] <- perfSpec_nestSum$nf[i] + 1
      }
      if (perfSpec$specBehav[j] == "pollenforaging") {
        perfSpec_nestSum$pf[i] <- perfSpec_nestSum$pf[i] + 1
      }
      if (perfSpec$specBehav[j] == "feedsbrood") {
        perfSpec_nestSum$bf[i] <- perfSpec_nestSum$bf[i] + 1
      }
      if (perfSpec$specBehav[j] == "egglaying") {
        perfSpec_nestSum$el[i] <- perfSpec_nestSum$el[i] + 1
      }
    }
  }
}

# gather df to plot
perfSpec_nestSum <- perfSpec_nestSum %>%
  gather(nf, pf, bf, el, 
         key = "behav", 
         value = "number")

G3 <- ggplot(perfSpec_nestSum, aes(behav, number, color = nestTYPE)) + 
  geom_point(position = position_jitter(width=.2, height=0.2), alpha = 0.7) +
  scale_color_manual(values = c("#fdb863", "#e66101", "#b2abd2", "#5e3c99"), labels = c("W3", "W5", "QW3", "QW5")) +
  stat_summary(fun = mean, geom = "point", size = 4, shape = 21, aes(fill = nestTYPE), color = "black") +
  scale_fill_manual(values = c("#fdb863", "#e66101", "#b2abd2", "#5e3c99")) +
  ggtitle("Perfect specialization") +
  scale_x_discrete(labels=c("egglaying" = "Egg\nlaying", "feedsbrood" = "Brood\nfeeding", "nectarforaging" = "Nectar\ncollection")) +
  labs(color="Social configuration", y = "Number of individuals per nest", x = "Task") +
  guides(fill=FALSE, color = guide_legend(override.aes = list(size = 5)))
G3

## Models 
# Poisson
ggdensity(perfSpec_nestSum$number)
qqp(perfSpec_nestSum$number, "norm")
hist(perfSpec_nestSum$number)

head(perfSpec_nestSum)
p0<-glmer(number~ 1  + (1|natal), data=perfSpec_nestSum, family=poisson)
p1<-glmer(number~ behav + (1|natal), data=perfSpec_nestSum, family=poisson)
p2<-glmer(number~ nestTYPE + (1|natal), data=perfSpec_nestSum, family=poisson)
p3<-glmer(number~ behav + nestTYPE  + (1|natal), data=perfSpec_nestSum, family=poisson)
p4<-glmer(number~ behav*nestTYPE  + (1|natal), data=perfSpec_nestSum, family=poisson)

model.sel(p0, p1, p2, p3, p4)

mymodel <- p1
tab_model(mymodel)
```

# SINGLE INSTANCE

## establish categories
```{r}
# subset to look only at nonlazy individuals
single <- count_3 

# add columns for presence/absence data
single$NF <- "no"
single$PF <- "no"
single$FB <- "no"
single$EL <- "no"

# go through each individual and update presence/absence data for each behavior
for (i in 1:nrow(single)) {
  if (single$nectarforaging[i] > 0) {
    single$NF[i] <- "yes"
  }
  if (single$pollenforaging[i] > 0) {
    single$PF[i] <- "yes"
  }
  if (single$feedsbrood[i] > 0) {
    single$FB[i] <- "yes"
  }
  if (single$egglaying[i] > 0) {
    single$EL[i] <- "yes"
  }
}

count_data$NF <- NA
count_data$PF <- NA
count_data$FB <- NA
count_data$EL <- NA

for(i in 1:nrow(count_data)) {
  for(j in 1:nrow(single)) {
    if(count_data$beeID[i] == single$beeID[j]) {
      count_data$NF[i] <- single$NF[j]
      count_data$PF[i] <- single$PF[j]
      count_data$FB[i] <- single$FB[j]
      count_data$EL[i] <- single$EL[j]
    }
  }
}
```

## body size & ovary development models 
 null models fit best
```{r}
#Body Size 
s0 <- glmer(size ~ 1 + (1|natal) + (1|nestTYPE:nestID), data = single)
s1 <- glmer(size ~ FB + PF + NF + EL + (1|natal) + (1|nestTYPE:nestID), data = single)

model.sel(s0, s1)

#Ovary Resporbtion 
s0 <- glmer(ovRavg ~ 1 + (1|natal) + (1|nestTYPE:nestID), data = single)
s1 <- glmer(ovRavg ~ FB + PF + NF + EL + (1|natal) + (1|nestTYPE:nestID), data = single)

model.sel(s0, s1)

#Ovary Stage 
s0 <- glmer(ovSavg ~ 1 + (1|natal) + (1|nestTYPE:nestID), data = single)
s1 <- glmer(ovSavg ~ FB + PF + NF + EL + (1|natal) + (1|nestTYPE:nestID), data = single)

model.sel(s0, s1)

# plot model residuals
plot(fitted(mymodel), residuals(mymodel), xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, lty = 2)
lines(smooth.spline(fitted(mymodel), residuals(mymodel)))
```

## analyze counts of specialists
 behavior alone significantly predicts number of specialists in a nest
```{r}
# print the number of bees that performed each task
print(paste(nrow(single[single$NF == "yes",]), "single instance nectar foragers from", length(unique(single$nestID[single$NF == "yes"])), "nests"))
print(paste(nrow(single[single$PF == "yes",]), "single instance pollen foragers from", length(unique(single$nestID[single$PF == "yes"])), "nests"))
print(paste(nrow(single[single$FB == "yes",]), "single instance brood feeders from", length(unique(single$nestID[single$FB == "yes"])), "nests"))
print(paste(nrow(single[single$EL == "yes",]), "single instance egg layers from", length(unique(single$nestID[single$EL == "yes"])), "nests"))

print(paste(length(unique(single$nestID)), "total nests"))

# How many specialists are in each nest?
single_nestSum <- as.data.frame(matrix(0, nrow = length(unique(single$nestID)), ncol = 7))
names(single_nestSum) <- c("nestTYPE", "natal", "nestID", "nf", "pf", "bf", "el")
single_nestSum$nestID <- unique(single$nestID)

# summarize by nest
for (i in 1:nrow(single_nestSum)) {
  for (j in 1:nrow(single)) {
    if (single$nestID[j] == single_nestSum$nestID[i]) {
      single_nestSum$nestTYPE[i] <- single$nestTYPE[j]
      single_nestSum$natal[i] <- single$natal[j]
      if (single$specBehav[j] == "nectarforaging") {
        single_nestSum$nf[i] <- single_nestSum$nf[i] + 1
      }
      if (single$specBehav[j] == "pollenforaging") {
        single_nestSum$pf[i] <- single_nestSum$pf[i] + 1
      }
      if (single$specBehav[j] == "feedsbrood") {
        single_nestSum$bf[i] <- single_nestSum$bf[i] + 1
      }
      if (single$specBehav[j] == "egglaying") {
        single_nestSum$el[i] <- single_nestSum$el[i] + 1
      }
    }
  }
}

# gather df to plot
single_nestSum <- single_nestSum %>%
  gather(nf, pf, bf, el, 
         key = "behav", 
         value = "number")

G5 <- ggplot(single_nestSum, aes(behav, number, color = nestTYPE)) + 
  geom_point(position = position_jitter(width=.2, height=0.2), alpha = 0.7) +
  scale_color_manual(values = c("#fdb863", "#e66101", "#b2abd2", "#5e3c99"), labels = c("W3", "W5", "QW3", "QW5")) +
  stat_summary(fun = mean, geom = "point", size = 4, shape = 21, aes(fill = nestTYPE), color = "black") +
  scale_fill_manual(values = c("#fdb863", "#e66101", "#b2abd2", "#5e3c99")) +
  ggtitle("Perfect specialization") +
  scale_x_discrete(labels=c("egglaying" = "Egg\nlaying", "feedsbrood" = "Brood\nfeeding", "nectarforaging" = "Nectar\ncollection")) +
  labs(color="Social configuration", y = "Number of individuals per nest", x = "Task") +
  guides(fill=FALSE, color = guide_legend(override.aes = list(size = 5)))
G5

## Models 
# Poisson
ggdensity(single_nestSum$number)
qqp(single_nestSum$number, "norm")
hist(single_nestSum$number)

head(single_nestSum)
p0<-glmer(number~ 1  + (1|natal), data=single_nestSum, family=poisson)
p1<-glmer(number~ behav + (1|natal), data=single_nestSum, family=poisson)
p2<-glmer(number~ nestTYPE + (1|natal), data=single_nestSum, family=poisson)
p3<-glmer(number~ behav + nestTYPE  + (1|natal), data=single_nestSum, family=poisson)
p4<-glmer(number~ behav*nestTYPE  + (1|natal), data=single_nestSum, family=poisson)

model.sel(p0, p1, p2, p3, p4)

mymodel <- p1
tab_model(mymodel)
```

# GRAPH COUNTS OF SPECIALISTS
```{r}
#Put all graphs in one figure 
ggarrange(G1, G3, G5, G4, G2, nrow = 3, ncol=2, common.legend = TRUE, legend="bottom", labels=c("A", "B", "C", "D", "E"))
ggsave("../figures/specializationdistsgraph.jpg")

```
#.

# -NMDS-


# NMDS clustering
```{r}
# pooled data across timepoints, values are counts
# includes only known bees
count_3 <- count_data[count_data$lazy == "notLazy",]

# make matrix of only behavior counts for all timepoints
nmds_m <- as.matrix(count_3[, c("feedsbrood", "nectarforaging", "pollenforaging", "egglaying")]) 

# Run NMDS with euclidean distance
nmds_scores <- metaMDS(nmds_m)
plot(nmds_scores)

# Gets NMDS info for each behavior
behav_scores <- as.data.frame(scores(nmds_scores, "species"))
behav_scores$behav <- c("Brood feeding", "Nectar collection", "Pollen collection", "Egg laying")

# merge bee NMDS info into nmds_data
nmds_scores <- as.data.frame(scores(nmds_scores))
nmds_data <- cbind(count_3, nmds_scores)

nmds_data$nestTYPE <- ordered(nmds_data$nestTYPE, levels = c("NT", "QT", "NF", "QF"))

# Plot it using ggplot
p1 <- ggplot() + 
  geom_point(data=nmds_data, aes(x=NMDS1, y=NMDS2, color = nestTYPE), size = 2.5, position = position_jitter(width=0.05, height=0.05), alpha = 0.7) + 
  scale_color_manual(values = c("#fdb863", "#e66101", "#b2abd2", "#5e3c99"), labels = c("W3", "W5", "QW3", "QW5")) +
  geom_text(data=behav_scores, aes(x=NMDS1, y=NMDS2, label=behav), size = 2.5) +
  coord_cartesian(xlim=c(-1.5, 1.5), ylim=c(-1.3, 1.3)) +
  labs(color = "Social configuration") +
  theme(text = element_text(size = 8)) +
  guides(colour = guide_legend(override.aes = list(shape = 15, size = 5)))
p1
ggsave("../figures/nmdsAll.jpg")
```

## plot body size & ovary stage onto nmds
```{r}
# # we only want known bees with >=3 observations (unknown bees and bees <3 obs have NA shannon)
nmds_worker <- count_3
# 
# # make matrix of only behavior counts for all timepoints
nmds_wM <- as.matrix(nmds_worker[, c("feedsbrood", "nectarforaging", "pollenforaging", "egglaying")]) 
# 
# # Run NMDS with euclidean distance
nmds_Wscores <- metaMDS(nmds_wM)
plot(nmds_Wscores)

# Gets NMDS info for each behavior
behav_Wscores <- as.data.frame(scores(nmds_Wscores, "species"))
behav_Wscores$behav <- rownames(behav_Wscores)
 
# merge bee NMDS info into nmds_worker
nmds_Wscores <- as.data.frame(scores(nmds_Wscores))
nmds_worker <- cbind(nmds_worker, nmds_Wscores)

nmds_worker$nestTYPE <- ordered(nmds_worker$nestTYPE, levels = c("NT", "QT", "NF", "QF"))


# plot ovary stage onto nmds
p3 <- ggplot() + 
  geom_point(data=nmds_data, aes(x=NMDS1, y=NMDS2, shape = caste, color = ovSavg), size = 2.5, position = position_jitter(width=0.05, height=0.05), alpha = 0.7) + 
  scale_colour_gradient(low = "yellow", high = "blue") + 
  scale_shape_manual(values = c(21, 16), labels = c("Queen", "Worker")) +
  geom_text(data=behav_scores, aes(x=NMDS1, y=NMDS2, label=behav), size = 2.5) +
  coord_cartesian(xlim=c(-1.5, 1.5), ylim=c(-1.3, 1.3)) +
  labs(shape = "Caste", color = "Ovary stage") +
  theme(text = element_text(size = 10))
p3
ggsave("../figures/nmdsOVARY.jpg")

# plot ovary stage by egg laying
ggplot() +
  geom_point(data = nmds_worker, aes(x = egglaying, y = ovSavg, color = ovSavg), 
             size = 2, position = position_jitter(width = 0.2, height = 0.2), alpha = 0.5) +
    scale_colour_gradient(low = "yellow", high = "blue") 
ggsave("../figures/eggOVARY.jpg")

# plot body size onto nmds
p4 <- ggplot() + 
  geom_point(data=nmds_data, aes(x=NMDS1, y=NMDS2, shape = caste, color = size), size = 2.5, position = position_jitter(width=0.05, height=0.05), alpha = 0.7) + 
  scale_colour_gradient(low = "yellow", high = "red") + 
  scale_shape_manual(values = c(21, 16), labels = c("Queen", "Worker")) +
  geom_text(data=behav_scores, aes(x=NMDS1, y=NMDS2, label=behav), size = 2.5) +
  coord_cartesian(xlim=c(-1.5, 1.5), ylim=c(-1.3, 1.3)) +
  labs(shape = "Caste", color = "Body size") +
  theme(text = element_text(size = 10))
p4  
ggsave("../figures/nmdsSIZE.jpg")

# plot body size and ovary development on one graph
ggarrange(p4, p3, nrow = 2, labels = c("A", "B"))
ggsave("../figures/nmdsPanelSizeOvary.jpg")
```

## plot behavioral categories onto nmds plot
```{r}
nmds_data$specBehav <- ordered(nmds_data$specBehav, levels = c("egglaying", "feedsbrood", "nectarforaging", "pollenforaging", "generalist"))
nmds_data$perfSpec <- ordered(nmds_data$specBehav, levels = c("egglaying", "feedsbrood", "nectarforaging", "pollenforaging", "generalist"))
nmds_data$BehavAssign <- ordered(nmds_data$BehavAssign, levels = c("egglaying", "feedsbrood", "nectarforaging", "pollenforaging", "generalist"))
nmds_data$cluster <- as.factor(nmds_data$cluster)
nmds_data
behav_scores$behav <- ordered(behav_scores$behav, levels = c("egglaying", "feedsbrood", "nectarforaging", "pollenforaging", "generalist"))

#add highest counts behavAssign to nmds
nmds_data$BehavAssign <- NA
nmds_data$BehavAssign <- colnames(nmds_data[nmds_data$nBehavs > 0, c("egglaying", "feedsbrood", "nectarforaging", "pollenforaging")])[max.col(nmds_data[nmds_data$nBehavs > 0, c("egglaying", "feedsbrood", "nectarforaging", "pollenforaging")], ties.method = "first")] 

# Plot it using ggplot
p2 <- ggplot() + 
  geom_point(data=nmds_data, aes(x=NMDS1, y=NMDS2, shape = cluster, color = BehavAssign, fill = specBehav), 
             size = 2.5, position = position_jitter(width=0.05, height=0.05)) + 
  scale_shape_manual(values = c(25, 24, 21), 
                     labels = c("3 - Resource collection", "2 - Egg laying", "1 - Generalist")) +
  scale_fill_manual(values = alpha(c("#F8766D", "#7CAE00", "#00BFC4", "white"), 0.5), 
                    labels = c("Egg laying", "Brood feeding", "Nectar collection", "Generalist")) +
  scale_color_manual(values = c("#F8766D", "#7CAE00", "#00BFC4", "#C77CFF"), 
                     labels = c("Egg laying", "Brood feeding", "Nectar collection", "Pollen collection"))  +
  geom_circle(data = as.data.frame(matrix(data = c(0.53, 0.84), nrow = 1)), # brood feeding 
              aes(x0 = V1, y0 = V2, r = 0.13), color = "gray") +
  geom_circle(data = as.data.frame(matrix(data = c(-1.2, 0.2), nrow = 1)), # nectar collection
              aes(x0 = V1, y0 = V2, r = 0.13), color = "gray") +
  geom_circle(data = as.data.frame(matrix(data = c(1.43, -0.92), nrow = 1)), # egg laying
              aes(x0 = V1, y0 = V2, r = 0.13), color = "gray") +
  geom_text(data=behav_scores, aes(x=NMDS1, y=NMDS2, label=behav), size = 2.5) +
  coord_cartesian(xlim=c(-1.5, 1.5), ylim=c(-1.3, 1.3)) +
  labs(color = "Most frequent\nbehavior", fill = "Shannon-based\ncategorization", shape = "K-means categorization") +
  theme(text = element_text(size = 8)) +
  guides(color = guide_legend(override.aes = list(shape = 22, size = 5)), 
         fill = guide_legend(override.aes = list(shape = 22, size = 5, 
                                                 colors = alpha(c("#F8766D", "#7CAE00", "#00BFC4", "grey88"), 0.4))))

p2
ggsave("../figures/nmdsFrameworks.jpg")

# plot nmds plots on one graph
ggarrange(p1, p2, nrow = 2, labels = c("A", "B"))
ggsave("../figures/nmdsPanelAll.jpg")
```









#.

# -REPEATABILITY-

# SHANNON VALUES

## average timepoint models
 two part glmm on early vs. late shannons:

Pt. 1: nothing significant
```{r}
#How many bees meet the criteria? 
count_3Time %>% dplyr::select(beeID) %>% unique() %>% nrow()
# two part model
# make a new column for over or under 0
count_3Time$shan0 <- NA
# if shannon = 0, shan0 = 1
count_3Time$shan0[count_3Time$shannon == 0] <- 1
# if shannon > 0, shan0 = 0
count_3Time$shan0[count_3Time$shannon > 0] <- 0

hist(count_3Time$shannon)
count_3Time

# model 0 vs. >0 shannon values
ps1 <- glmer(shan0 ~ timepoint + nestTYPE + (1|nestTYPE:nestID:beeID) + (1|natal) + (1|nBehavs),
              data = count_3Time, family = binomial(link = "logit"))
ps4 <- glmer(shan0 ~ timepoint*nestTYPE + (1|nestTYPE:nestID:beeID) + (1|natal) + (1|nBehavs),
              data = count_3Time, family = binomial(link = "logit"))
ps2 <- glmer(shan0 ~ timepoint + (1|nestTYPE:nestID:beeID) + (1|natal) + (1|nBehavs),
              data = count_3Time, family = binomial(link = "logit"))
ps3 <- glmer(shan0 ~ nestTYPE + (1|nestTYPE:nestID:beeID) + (1|natal) + (1|nBehavs),
              data = count_3Time, family = binomial(link = "logit"))
ps0 <- glmer(shan0 ~ 1 + (1|nestTYPE:nestID:beeID) + (1|natal) + (1|nBehavs),
              data = count_3Time, family = binomial(link = "logit"))

model.sel(ps0, ps1, ps2, ps3, ps4)

mymodel <- ps3
tab_model(mymodel)
summary(mymodel)

# plot model residuals
plot(fitted(mymodel), residuals(mymodel), xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, lty = 2)
lines(smooth.spline(fitted(mymodel), residuals(mymodel)))
```

Pt. 2: timepoint significantly predicts degree of specialization
        -bees become more specialized over time
```{r}
# make a new column that contains only shannon for bees with shannon > 0
count_3Time$shan1 <- NA
count_3Time$shan1[count_3Time$shannon > 0] <- count_3Time$shannon[count_3Time$shannon > 0]
# it's mostly normal  - i think so!
hist(count_3Time$shan1)
qqp(count_3Time$shan1, "norm")

# model >0 shannon values
ps1 <- glmer(shan1 ~ timepoint + nestTYPE + (1|nestTYPE:nestID:beeID) + (1|natal) + (1|nBehavs),
              data = count_3Time)
ps4 <- glmer(shan1 ~ timepoint*nestTYPE + (1|nestTYPE:nestID:beeID) + (1|natal) + (1|nBehavs),
              data = count_3Time)
ps2 <- glmer(shan1 ~ timepoint + (1|nestTYPE:nestID:beeID) + (1|natal) + (1|nBehavs),
              data = count_3Time)
ps3 <- glmer(shan1 ~ nestTYPE + (1|nestTYPE:nestID:beeID) + (1|natal) + (1|nBehavs),
              data = count_3Time)
ps0 <- glmer(shan1 ~ 1 + (1|nestTYPE:nestID:beeID) + (1|natal) + (1|nBehavs),
              data = count_3Time)

model.sel(ps0, ps1, ps2, ps3, ps4)

mymodel <- ps2
tab_model(mymodel)
summary(mymodel)
plot_model(mymodel)


# plot model residuals
plot(fitted(mymodel), residuals(mymodel), xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, lty = 2)
lines(smooth.spline(fitted(mymodel), residuals(mymodel)))
```


## change in shannon models
 null model fits best
```{r}
#how many bees are at both early and late timepoints? 
shanspec<-count_3Time %>% filter(shanDist!="NA")
nrow(shanspec)
# pretty normal
ggdensity(shanspec$shanDist)
qqp(shanspec$shanDist, "norm")

cs0 <- glmer(shanDist ~ 1 + (1|nestTYPE:nestID) + (1|natal),
              data = shanspec)
cs1 <- glmer(shanDist ~ nestTYPE + (1|nestTYPE:nestID) + (1|natal),
              data = shanspec)

model.sel(cs0, cs1)
mymodel <- cs0

# plot model residuals
plot(fitted(mymodel), residuals(mymodel), xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, lty = 2)
lines(smooth.spline(fitted(mymodel), residuals(mymodel)))
```

# ANOSIM
Look at NMDS at two time points 
```{r}
# Look at NMDS at two points
nmds_time<-read.csv("../Data/filtData/count_time.csv") %>% 
  dplyr::select(nestID, nestTYPE, beeID, caste,  
         specBehav, timepoint, nectarforaging, feedsbrood, pollenforaging, lazy)

# we only want known bees with >=3 observations (unknown bees and bees <3 obs have NA shannon)
nmds_time<- nmds_time %>% filter(lazy=="notLazy")

#Filter so that we only use beeIDs that have observations at both time points 

timen<-nmds_time %>% 
  dplyr::select(timepoint, nestTYPE, nestID, beeID, feedsbrood, 
                nectarforaging, pollenforaging) %>% 
  pivot_longer(!c(timepoint, beeID, nestTYPE, nestID), names_to="Behavior", values_to="Counts")  

timen$Dist <- NA
# calculate change in proportion over time and add to Dist column
for (i in 1:nrow(timen)) {              # for each row in the dataset
  if(timen$timepoint[i] == "late") {                # look at the the late bees only
    for (j in 1:nrow(timen)) {                     # then iterate back through the dataset
      if(timen$timepoint[j] == "early" & 
         timen$beeID[j] == timen$beeID[i]
         & timen$Behavior[j] == timen$Behavior[i]) {   
        # and find the early entry with the same behav
        timen$Dist[i] <- timen$Counts[i] - timen$Counts[j] 
        # calculate the difference across time
      }
    }
  }
}

#Filter out individuals that do not have observations at both timepoints
timen<-timen[complete.cases(timen),]
# Select all beeIDs from rpttime that had a reciprocal timepoint and filter rptDist so both timepoints are in dataframe
beestime<-timen %>% dplyr::select(beeID) %>% unique()

namesbeesfilt<-as.list(beestime)
nmdsTIME<-nmds_time %>% filter(beeID %in% namesbeesfilt$beeID)

nmdsTIME %>% dplyr::select(beeID) %>% unique() %>% nrow()


# make matrix of all behaviors except egg laying counts for all timepoints
nmds_mT <- as.matrix(nmdsTIME[, c("feedsbrood", "nectarforaging", "pollenforaging")])

# Run NMDS with euclidean distance
nmds_scoresT <- metaMDS(nmds_mT)
plot(nmds_scoresT)

# Gets NMDS info for each behavior
behav_scoresT <- as.data.frame(scores(nmds_scoresT, "species"))
behav_scoresT$behav <- rownames(behav_scoresT)


# merge bee NMDS info into nmds_data
nmds_scoresT <- as.data.frame(scores(nmds_scoresT))
nmds_dataT <- cbind(nmdsTIME, nmds_scoresT)

nmds_dataT$nestTYPE <- ordered(nmds_dataT$nestTYPE, levels = c("NT", "QT", "NF", "QF"))

#Run analysis of similarity to see if variation is greater between time points than within time points
anotime = anosim(nmds_mT, nmds_dataT$timepoint, distance = "euclidean", permutations = 9999)
#ANOSIM is significant - to see where run anosims between different groups 
anotime
```

Repeatability measurements and interpretation instructions:

https://cran.r-project.org/web/packages/rptR/vignettes/rptR.html
If 95% confidence intervals of random effect does not reach 0, this suggests that the behavior is repeatable 
Individuals=grouping factor in our case 
R^2 quantifies the proportion of variance explained by fixed effects 
R=0 no variation is explained by the fixed effect 
Adjusted repeatability: controls for fixed effects - any variance that is explained by the fixed effect is excluded from the denominator 

# RPTR
## prep dataframe
```{r}
rptdata <- count_3Time %>% dplyr::select(nestID, nestTYPE, beeID, timepoint, nectarforaging, feedsbrood, pollenforaging, nBehavs, specBehav, lazy)

rpttime<-rptdata %>% 
  dplyr::select(timepoint, nestTYPE, nestID, beeID, feedsbrood, 
                nectarforaging, pollenforaging) %>% 
  pivot_longer(!c(timepoint, beeID, nestTYPE, nestID), names_to="Behavior", values_to="Counts")  

rpttime$Dist <- NA
rpttime$propDist <- NA

# calculate change in number of behaviors over time and add to Dist column
for (i in 1:nrow(rpttime)) {              
# for each row in the dataset
  if(rpttime$timepoint[i] == "late") {                
  # look at the the late bees only
    for (j in 1:nrow(rpttime)) {                     
    # then iterate back through the dataset
      if(rpttime$timepoint[j] == "early" & rpttime$beeID[j] == rpttime$beeID[i] & rpttime$Behavior[j] == rpttime$Behavior[i]) {   
      # and find the early entry with the same behav
        rpttime$Dist[i] <- rpttime$Counts[i] - rpttime$Counts[j] 
        # calculate distance
        rpttime$propDist[i] <- (rpttime$Counts[i] - rpttime$Counts[j]) / rpttime$Counts[j]
        # calculate the percent change (late - early) / early
      }
    }
  }
}

# Filter out individuals that do not have observations at both timepoints
rpttime<-rpttime[complete.cases(rpttime),]

# Select all beeIDs from rpttime that had a reciprocal timepoint and filter rptDist so both timepoints are in dataframe
beestime<-rpttime %>% dplyr::select(beeID) %>% unique()

namesbeesfilt<-as.list(beestime)
rpt_data<-rptdata %>% filter(beeID %in% namesbeesfilt$beeID)

rpt_data %>% dplyr::select(beeID) %>% unique() %>% nrow()

#pivot longer for graphs :) 
# rpt_graphs<-rpttime %>% pivot_longer(!c(nestID, nestTYPE, beeID, timepoint), names_to="Behavior", values_to="Counts")
```

## run rptr analyses
**THIS IS VERY SLOW - DON'T RUN UNLESS YOU NEED TO
```{r}
hist(rptdata$feedsbrood)
wfb<- rpt(feedsbrood ~ timepoint+(1|beeID)+(1|nestID)+(1|nestTYPE),
            grname = c("beeID", "nestID", "nestTYPE"), data = rptdata, 
            datatype = "Gaussian", nboot = 1000, npermut = 0)
summary(wfb)
print(wfb)
plot(wfb, cex.main = 1)

#Check model fit - residuals looks ok 
lmfb<-lmer(feedsbrood~timepoint+(1|beeID)+(1|nestID),  
           data=rptdata)

summary(lmfb)
hist(residuals(lmfb))
plot(fitted(lmfb), residuals(lmfb), xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, lty = 2)
lines(smooth.spline(fitted(lmfb), residuals(lmfb)))
```

 nectar foraging
```{r}
hist(rptdata$nectarforaging)
wnf<- rpt(nectarforaging ~ timepoint+(1|beeID)+(1|nestID)+(1|nestTYPE),
            grname = c("beeID", "nestID", "nestTYPE"), data = rptdata, 
            datatype = "Gaussian", nboot = 1000, npermut = 0)
summary(wnf)
print(wnf) 
plot(wnf, cex.main = 1)

#Check model fit - nectar foraging
lmnf<-lmer(nectarforaging~timepoint+(1|beeID)+(1|nestID),  
           data=rptdata)

summary(lmnf)
hist(residuals(lmnf))
plot(fitted(lmnf), residuals(lmnf), xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, lty = 2)
lines(smooth.spline(fitted(lmnf), residuals(lmnf)))
head(rpt_data)

```
 
 pollen foraging
```{r}
hist(rptdata$pollenforaging)
wf<- rpt(pollenforaging ~ timepoint+(1|beeID)+(1|nestID)+(1|nestTYPE),
            grname = c("beeID", "nestID", "nestTYPE"), data = rptdata, 
            datatype = "Gaussian", nboot = 1000, npermut = 0)
summary(wf)
print(wf)
plot(wf, cex.main = 1)

#Check model fit - pollen foraging - these look pretty off 
lmpf<-lmer(pollenforaging~timepoint+(1|beeID)+(1|nestID),  
           data=rptdata)

summary(lmpf)
hist(residuals(lmpf))
plot(fitted(lmpf), residuals(lmpf), xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, lty = 2)
lines(smooth.spline(fitted(lmpf), residuals(lmpf)))
```

## plots 
 change in individuals from early to late
```{r}
# plot the change from early to late

# make inf 18.1 (larger than any others)
# add a new value for graphing infinities separately
rpttime$inf <- "no"
for(i in 1:nrow(rpttime)) {
  if(rpttime$propDist[i] == Inf) {
    rpttime$propDist[i] <- 1
    rpttime$inf[i] <- "yes"
  }
  if(rpttime$propDist[i] == -Inf) {
    rpttime$propDist[i] <- -1
    rpttime$inf[i] <- "yes"
  }
  # make -100% change also be infinity 
  if(rpttime$Counts[i] == 0) {
    rpttime$inf[i] <- "yes"
  }
}

rpttime$propDist <- rpttime$propDist * 100

rpttime$nestTYPE <- ordered(rpttime$nestTYPE, levels = c("NT", "NF", "QT", "QF"))

# recode propDist

R1<-ggplot(rpttime, aes(Dist, Behavior)) +
  geom_point(position = position_jitter(width=2, height=0.3), alpha = 0.7, aes(color = nestTYPE, size = abs(propDist), shape = inf)) +
  scale_shape_manual(values = c(19, 21), labels = c("yes", "no")) +
  #stat_summary(fun = mean, geom = "point", size = 3) +
  geom_vline(aes(xintercept = 0), color = "gray70", size = 0.6) +
  scale_color_manual(values = c("#fdb863", "#e66101", "#b2abd2", "#5e3c99"), labels = c("W3", "W5", "QW3", "QW5")) +
  labs(x = "Change in number of behaviors performed by each individual", y = "Task", 
       size = "Percent change", color = "Social configuration", shape = ">0 observations at both timeframes") +
  scale_y_discrete(labels=c("pollenforaging" = "Pollen\ncollection", "nectarforaging" = "Nectar\ncollection", "feedsbrood" = "Brood\nfeeding")) + 
  theme(legend.position="bottom", legend.box = "vertical") + 
  guides(color = guide_legend(order = 1, override.aes = list(shape = 15, size = 5)),
         size = guide_legend(order=2),
         shape = guide_legend(order = 3))#+

R1

ggsave("../figures/rptDistBehav.jpg")
```

nest
```{r}
# summarize by nest
rptnest <- rpttime %>% group_by(Behavior, nestID, nestTYPE) %>% 
  mutate(nestDist=sum(Dist),
         nestCounts=sum(Counts))  %>% 
  dplyr::select(Behavior, nestID, nestTYPE, nestDist, nestCounts) %>% unique()

# calculate nestPropDist on summary data
rptnest$nestPropDist <- NA
for(i in 1:nrow(rptnest)) {
  rptnest$nestPropDist[i] <- rptnest$nestDist[i] / (rptnest$nestCounts[i] - rptnest$nestDist[i])
}

rptnest$inf <- "no"
for(i in 1:nrow(rptnest)) {
  # make +infinity change infinity
  if(rptnest$nestPropDist[i] == Inf) {
    rptnest$nestPropDist[i] <- 1
    rptnest$inf[i] <- "yes"
  }
  if(rptnest$nestPropDist[i] == -Inf) {
    rptnest$nestPropDist[i] <- -1
    rptnest$inf[i] <- "yes"
  }
  # make -100% change also be infinity 
  if(rptnest$nestCounts[i] == 0) {
    rptnest$inf[i] <- "yes"
  }
}

rptnest$nestPropDist <- rptnest$nestPropDist * 100

R2<-ggplot(rptnest, aes(nestDist, Behavior)) +
  geom_point(position = position_jitter(width=2, height=0.3), alpha = 0.7,
             aes(color = nestTYPE, size = abs(nestPropDist), shape = inf)) +
  scale_shape_manual(values = c(19, 21), labels = c("yes", "no")) +
  #stat_summary(fun = mean, geom = "point", size = 3) +
  geom_vline(aes(xintercept = 0), color = "gray70", size = 0.6) +
  scale_color_manual(values = c("#fdb863", "#e66101", "#b2abd2", "#5e3c99"), labels = c("W3", "W5", "QW3", "QW5")) +
  labs(x = "Change in number of behaviors performed by each nest", y = "Task", 
       size = "Percent change", color = "Social configuration", shape = ">0 observations at both timeframes") +
  scale_y_discrete(labels=c("pollenforaging" = "Pollen\ncollection", "nectarforaging" = "Nectar\ncollection", "feedsbrood" = "Brood\nfeeding")) + 
  theme(legend.position="bottom", legend.box = "vertical") + 
  guides(color = guide_legend(order = 1, override.aes = list(shape = 15, size = 5)),
         size = guide_legend(order=2),
         shape = guide_legend(order = 3))#+
R2
ggsave("../figures/rptNEST.jpg")


# graph together
ggarrange(R1, R2, nrow=2, common.legend = TRUE, legend="bottom", labels=c('A', 'B'))

ggsave("../figures/repeatability.jpg")
```














































