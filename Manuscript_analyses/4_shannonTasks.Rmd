---
title: "shannonTasks"
author: "ES"
date: "7/27/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# load packages
```{r, echo = FALSE}
library(vegan)    # shannon diversity function
library(ggplot2)  # plots
library(ggpubr)   # ggdensity plots
library(lme4)     # glmms
library(sjPlot)   # model summary
library(multcomp) # tukey tests
library(lsmeans)  # ls means posthoc tests
```

# load data
```{r}
# pooled data across timepoints, values are counts of total observations in a given nest carried out by that bee/task combination
# nests with >3 observations, regardless of # observations per bee
shanP_data <- read.csv("../Data/tempData/nestCounts_filt.csv")
shanP_data
shanP_data$nestTYPE <- ordered(shanP_data$nestTYPE, levels = c("NT", "QT", "NF", "QF"))

# split across timepoints, nests with >3 observations, regardless of # observations per bee
shanEarly_data <- read.csv("../Data/tempData/nestEarlyCounts_filt.csv")
shanLate_data <- read.csv("../Data/tempData/nestLateCounts_filt.csv")

# merge early and late shannon
shanT_data <- rbind(shanEarly_data, shanLate_data)
# remove egg laying from total counts of behavior
shanT_data$nBehavs <- shanT_data$nBehavs - shanT_data$egglaying
# remove egg laying from df
shanT_data <- within(shanT_data, rm(egglaying))
shanT_data
```

# shannon index for each task

# POOLED TIMEPOINTS, including egg laying
****do we need to include bees that did not carry out any behaviors here? ****
```{r}
taskP <- shanP_data
taskP

# make df to put shannon values into
# taskS <- matrix(NA, nrow = length(unique(taskP$nestID)), ncol = 2)
# colnames(taskS) <- c("nestID", "shannon")
# taskS <- as.data.frame(taskS)
taskS <- matrix(NA, ncol = 4)
colnames(taskS) <- c("nestID", "behav", "shannon", "nBehav")
  
# for each nest, calculate mutal entropy for entire matrix (I)
for(index in 1:length(unique(taskP$nestID))) {                      # for each unique nestID in the dataset
  nest_df <- taskP[taskP$nestID == unique(taskP$nestID)[index], ]   # subset to look only at that nestID
  nest_m <- as.matrix(nest_df[,c("feedsbrood", "nectarforaging", "pollenforaging", "egglaying")])   # convert to matrix of behaviors for that nest ID
  if (nrow(nest_df) < 2) {
    nest_m <- rbind(nest_m, c(0, 0, 0, 0))
  }
  nest_m <- t(nest_m)                                               # transpose the matrix so that behaviors are now rows and individuals are columns
  nest_m <- nest_m[rowSums(nest_m) > 0,, drop = FALSE]              # remove behaviors without any observations
  # make a matrix to put shannon values into
  nestS <- matrix(NA, ncol = 4, nrow = nrow(nest_m))                # make a nest-specific matrix to put shannon values into
  nestS <- as.data.frame(nestS)                                     # turn it into a df
  colnames(nestS) <- c("nestID", "behav", "shannon", "nBehav")    # name columns same as the taskP df
  shannon <- diversity(nest_m, index = "shannon")                   # calculate shannon for each behavior in the nest
  nestS$behav <- rownames(nest_m)                                     # add the name of each behavior to the nestS df
  nestS$shannon <- shannon                                          # add the corresponding shannon score for each behavior
  nestS$nBehav <- rowSums(nest_m)
  nestS$nestID <- unique(taskP$nestID)[index]                       # copy nestID into the nestS df
  taskS <- rbind(taskS, nestS)                                      # add the nest-specific df to the overall task df
}

# check out resulting df
taskS
# add nestTYPE column
taskS$nestTYPE <- substr(taskS$nestID, start = 1, stop = 2)

# remove na row
taskS <- taskS[!is.na(taskS$shannon),]

taskS$nestTYPE <- ordered(taskS$nestTYPE, levels = c("NT", "QT", "NF", "QF"))

# plot it
ggplot(taskS, aes(shannon, behav)) +
  geom_point(position = position_jitter(width=0.05, height=0.2), alpha = 0.9, aes(color = nestTYPE)) +
  stat_summary(fun = mean, geom = "point", size = 5)
ggsave("../figures/taskShann.jpg")

# plot degree of specialization against number of observations
ggplot(taskS, aes(shannon, nBehav, color = behav, shape = nestTYPE)) +
  geom_point(position = position_jitter(width=0.1, height=1), alpha = 0.9, size = 1.8) +
  scale_shape_manual(values = c(16, 15, 21, 22))
ggsave("../figures/pooledTaskShannonVSnBehavs.jpg")
```

# COMPARE EARLY VS LATE TIMEPOINTS, excluding egg laying, separate nectar & pollen foraging
THIS HAS ISSUES AND NEEDS WORK -- ITS VERY COMPLICATED
```{r}
taskT <- shanT_data
taskT
# copied from above, but using new df with timepoints


taskTimeShan <- matrix(NA, ncol = 5)
colnames(taskTimeShan) <- c("nestID", "behav", "shannon", "nBehav", "timepoint")
  
# for each nest, calculate shannon for each behavior at each timepoint
for(index in 1:length(unique(taskT$nestID))) {                      
  # subset to look only at that nestID
  nest_df <- taskT[taskT$nestID == unique(taskT$nestID)[index], ]   
  
  # subset to look only at early timepoint and only at behaviors for that nest-timepoint
  nestE <- nest_df[nest_df$timepoint == "early", c("feedsbrood", "nectarforaging", "pollenforaging")]
  # if early timepoint has only 1 observation, add a row of 0s to make it compatible with transpose
  if (nrow(nestE) == 1) {
    nestE <- rbind(nestE, c(0,0,0))
  }
  # if early timepoint does exist, do stuff
  if (nrow(nestE) > 1) {
    # transpose it so that behaviors are now rows and individuals are columns
    nestE <- t(nestE)
    # remove behaviors with 0 observations, and keep row names for behaviors with >0 observations
    nestE <- nestE[rowSums(nestE) > 0,, drop = FALSE]
    # make a matrix to put shannon values into
    nestEshan <- matrix(NA, ncol = 5, nrow = nrow(nestE))
    # convert it to a df
    nestEshan <- as.data.frame(nestEshan)
    # make column names match taskTimeShan df
    colnames(nestEshan) <- c("nestID", "behav", "shannon", "nBehav", "timepoint")
    # calculate shannon for each behavior in the nest
    shannon <- diversity(nestE, index = "shannon")
    # add the name of each behavior, corresponding shannon, timepoint, nBehav, and nestID to the nestEshan df
    nestEshan$behav <- rownames(nestE)                                     # add the name of each behavior to the nestS df
    nestEshan$shannon <- shannon 
    nestEshan$timepoint <- "early"
    nestEshan$nBehav <- rowSums(nestE)
    nestEshan$nestID <- unique(taskT$nestID)[index] 
    # bind the rows to the overal taskTimeShan df
    taskTimeShan <- rbind(taskTimeShan, nestEshan)
    } 
  # if early timepoint doesn't exist, print that there are 0 early observations in that nest 
  if (nrow(nestE == 0)) {
      print(paste("there are 0 early observations for nest", unique(taskT$nestID)[index]))
    }

  # do the same for late
  nestL <- nest_df[nest_df$timepoint == "late", c("feedsbrood", "nectarforaging", "pollenforaging")]
    # if late timepoint has only 1 observation, add a row of 0s to make it compatible with transpose
  if (nrow(nestL) == 1) {
    nestL <- rbind(nestL, c(0,0,0))
  }
  # if late timepoint doesn't exist, print that there are 0 late observations in that nest
  if (nrow(nestL == 0)) {
    print(paste("there are 0 late observations for nest", unique(taskT$nestID)[index]))
  } 
  # if late timepoint does exist, do stuff
  if (nrow(nestL) > 1) {
      # transpose it so that behaviors are now rows and individuals are columns
      nestL <- t(nestL)
      # remove behaviors with 0 observations, and keep row names for behaviors with >0 observations
      nestL <- nestL[rowSums(nestL) > 0,, drop = FALSE]
      # make a matrix to put shannon values into
      nestLshan <- matrix(NA, ncol = 5, nrow = nrow(nestL))
      # convert it to a df
      nestLshan <- as.data.frame(nestLshan)
      # make column names match taskTimeShan df
      colnames(nestLshan) <- c("nestID", "behav", "shannon", "nBehav", "timepoint")
      # calculate shannon for each behavior in the nest
      shannon <- diversity(nestL, index = "shannon")
      # add the name of each behavior, corresponding shannon, timepoint, nBehav, and nestID to the nestEshan df
      nestLshan$behav <- rownames(nestL)                                     # add the name of each behavior to the nestS df
      nestLshan$shannon <- shannon 
      nestLshan$timepoint <- "late"
      nestLshan$nBehav <- rowSums(nestL)
      nestLshan$nestID <- unique(taskT$nestID)[index] 
      # bind the rows to the overal taskTimeShan df
      taskTimeShan <- rbind(taskTimeShan, nestLshan)
  }
}

# add nestTYPE column
taskTimeShan$nestTYPE <- substr(taskTimeShan$nestID, start = 1, stop = 2)

# remove na row
taskTimeShan <- taskTimeShan[!is.na(taskTimeShan$shannon),]

# order nestTYPEs
taskTimeShan$nestTYPE <- ordered(taskTimeShan$nestTYPE, levels = c("NT", "QT", "NF", "QF"))

# plot it
ggplot(taskTimeShan, aes(shannon, behav, shape = timepoint)) +
  geom_point(position = position_jitter(width=0.05, height=0.2), alpha = 0.9, aes(color = nestTYPE)) +
  stat_summary(fun = mean, geom = "point", size = 5) +
  scale_shape_manual(values = c(17, 25))
ggsave("../figures/taskShannTIME.jpg")

###########################################

# add column for shanDist
taskTimeShan$shanDist <- NA
# calculate change in shannon over time and add to shanDist column
for (i in 1:nrow(taskTimeShan)) {                                                   # for each row in the dataset
  if(taskTimeShan$timepoint[i] == "late") {                                         # look at the the late bees only
    for (j in 1:nrow(taskTimeShan)) {                                               # then iterate back through the dataset
      if(taskTimeShan$timepoint[j] == "early" & taskTimeShan$behav[j] == taskTimeShan$behav[i]) {   # and find the early entry with the same behav
        taskTimeShan$shanDist[i] <- taskTimeShan$shannon[i] - taskTimeShan$shannon[j]               # calculate the difference in shannon index across time
      }
    }
  }
}

# plot the change in shannon from early to late
avgShannDist <- taskTimeShan %>% summarize(avg = mean(shanDist, na.rm = T)) %>% pull(avg)

ggplot(taskTimeShan, aes(shanDist, behav)) +
  geom_point(position = position_jitter(width=0.1, height=0.2), alpha = 0.8, aes(color = nestTYPE)) +
  scale_shape_manual(values = c(17, 25)) +
  stat_summary(fun = mean, geom = "point", size = 5) +
  geom_vline(aes(xintercept = avgShannDist), color = "gray70", size = 0.6) +
  labs(x = "change in shannon index from early to late timepoint")
ggsave("../figures/shanDistBehav.jpg")
```

# glmms on pooled shannon across nestTYPEs
```{r}
# it's not really normal... not sure what distribution to use
ggdensity(taskS$shannon)
qqp(taskS$shannon, "norm")
taskS

# need to add natal colony as random effect
ps <- glmer(shannon ~ behav + nestTYPE + nBehav + (1|nestID),
              data = taskS)
mymodel <- ps
summary(mymodel)
tab_model(mymodel)

posthoc1 <- glht(mymodel, linfct = mcp(behav = "Tukey"))
summary(posthoc1)

# plot model residuals
plot(fitted(mymodel), residuals(mymodel), xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, lty = 2)
lines(smooth.spline(fitted(mymodel), residuals(mymodel)))
```

# glmms on early vs. late shannons
```{r}
# it's not really normal... not sure what distribution to use
ggdensity(taskTimeShan$shannon)
qqp(taskTimeShan$shannon, "norm")

# need to add natal colony as random effect
ts <- glmer(shannon ~ timepoint*behav + nBehav + nestTYPE + (1|nestID),
              data = taskTimeShan)
mymodel <- ts
summary(mymodel)
tab_model(mymodel)

posthoc1 <- glht(mymodel, linfct = mcp(behav = "Tukey"))
summary(posthoc1)

# plot model residuals
plot(fitted(mymodel), residuals(mymodel), xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, lty = 2)
lines(smooth.spline(fitted(mymodel), residuals(mymodel)))
```

# glmms on change in shannon across timepoints
```{r}
# pretty normal
ggdensity(taskTimeShan$shanDist)
qqp(taskTimeShan$shanDist, "norm")
taskTimeShan
# need to add natal colony as random effect
cs <- glmer(shanDist ~ nestTYPE*behav + (1|nestID),
              data = taskTimeShan)
mymodel <- cs
summary(mymodel)
tab_model(mymodel)
posthoc1 <- glht(mymodel, linfct = mcp(nestTYPE = "Tukey"))
summary(posthoc1)
posthoc2 <- glht(mymodel, linfct = mcp(behav = "Tukey"))
summary(posthoc2)
posthoc6 <- lsmeans(mymodel, pairwise ~ behav|nestTYPE, adjust = "tukey")
summary(posthoc6)

# plot model residuals
plot(fitted(mymodel), residuals(mymodel), xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, lty = 2)
lines(smooth.spline(fitted(mymodel), residuals(mymodel)))
```


















































# division of labor mutual entropy
<!-- # division of labor indices -->
<!-- this yeilds a DOL index between 0 (no division) and 1 (complete division) for nest-level tasks, bees, and both task & bee -->
<!-- issues = does not describe which behavior a bee is specializing on. eg specializing entirely on nectar foraging and specializing entirely on egg laying both yield same number -->

<!-- https://www.journals.uchicago.edu/doi/pdfplus/10.1086/424968 -->

<!-- https://watermark.silverchair.com/arn018.pdf?token=AQECAHi208BE49Ooan9kkhW_Ercy7Dm3ZL_9Cf3qfKAc485ysgAAArAwggKsBgkqhkiG9w0BBwagggKdMIICmQIBADCCApIGCSqGSIb3DQEHATAeBglghkgBZQMEAS4wEQQM0mGmfTsnhsoK-Y_uAgEQgIICY-aMO-F9oEaBklacEnjaMSJCFsghtzm6jKWajfSFUi1WmnoBV8zpdiY0ztkvgG8k3Vi7Vaby0gWJGaGto13hllldFKZg-C-TNDdv7yJt81TrpV3M_ooNiYcjJq92Y6ObRoYrlxUJfi77RK3_cDBJ9Ag8JjhA03UWwerFU5FE71P3-7ptplP8rI8QYpXNZdtZbyoYrEN80JYxjgt1o2zAFGvRF3r-_1ExlhdpKr5k0OxGqlCa11kFUpBAjFpMun5qR6JL-8bkcbRIAmNnBBduCg1CSXoUBpx18ouZnNJu_v9OQodZ7hBYPfu62SRjQ9TNEZqadgMAt0mMreuH60st2TagmvXlqLPPyoIu7-0ZBvdD6nvcmJ-miBhUw7Z6vCia1KhrvpvKvhZem2N3zsGsNSp_UFSvVSwtNeHdguMtId5zSe70mWdbDBfTJAsag1sf5YAeCd0XwDSRsfarD2aAYlmQ0ARCd8qC8yxdUlKqohn3Xsh70IBQL1jc_l32k1Q7fiplJiD6hQ69Yge2M961fZML1G5vIQa5DxBgThNYg5GyQxXnyzCFHWJIDhqKwHtWgiWQgbA63qMK2IHNicOSw8JhrpaWlWgEUX8NiaiF7ICzNxFh2pcdL-hnazO1StB1anJtiTo-RHgeLji4E9qYFpT3DYcw6ptUAxjLUql3d1M0aByMRS0EhoZCoUfER_8iiUicTNGUi4w85O5mm55B4vRheg5XGSlby26I0_H9zOtK-eQ3PmKHB4DyPvd-Ch24hp4FBEFJM4pI_sCZJc8_p8JuYOonUk_M3aqNLQKGznrL_xu2 -->
<!-- ```{r} -->
<!-- # MUTUTAL ENTROPY CALCULATIONS -->

<!-- # make df to put entropy values into -->
<!-- nestdol <- matrix(NA, nrow = length(unique(dol_data$nestID)), ncol = 7) -->
<!-- colnames(nestdol) <- c("nestID", "HX","HY", "I", "indivSpec", "taskSpec", "symmDOL") -->
<!-- nestdol <- as.data.frame(nestdol) -->

<!-- # for each nest, calculate mutal entropy for entire matrix (I) -->
<!-- for(index in 1:length(unique(dol_data$nestID))) {                   # for each unique nestID in the dataset -->
<!--   nest_df <- dol_data[dol_data$nestID == unique(dol_data$nestID)[index], ]                          # subset to look only at that nestID -->
<!--   nest_m <- as.matrix(nest_df[,c("feedsbrood", "nectarforaging", "pollenforaging", "egglaying")])   # convert to matrix of behaviors for that nest ID  -->
<!--   nestdol$nestID[index] <- unique(dol_data$nestID)[index]           # copy nestID into the nestdol df -->
<!--                                                                     # make row and col sum vectors to use in future calculations -->
<!--   sumRow <- rowSums(nest_m) -->
<!--   sumCol <- colSums(nest_m) -->
<!--             # calculate nest-level individual shannon diversity index via mutual entropy paper's definition -->
<!--             # HZ = -SUMMATIONz [ p(Z) * log (p(Z)) ] -->
<!--   HX <- 0                                                           # reset HX to start at 0 for each nest -->
<!--   for(x in 1:nrow(nest_m)) {                                        # for each individual -->
<!--     pX <- sumRow[x]                                                 # p is the proportion of all behaviors in the nest carried out by that individual -->
<!--     hX <- pX * log(pX)                                              # calculate the shannon's index for that individual -->
<!--     HX <- HX + hX                                                   # add it to nestH, to produce an overall H for the nest -->
<!--   } -->
<!--   HX <- HX * -1                                                     # multiply HX by -1 b/c negative summation -->
<!--   nestdol$HX[index] <- HX                                           # copy HX value into the nestdol df -->
<!--             # calculate nest-level task shannon diversity index via mutual entropy paper's definition -->
<!--             # HZ = -SUMMATIONz [ p(Z) * log (p(Z)) ] -->
<!--   HY <- 0                                                           # reset HY to start at 0 for each nest -->
<!--   for(y in 1:ncol(nest_m)) {                                        # for each task -->
<!--     pY <- sumCol[y]                                                 # p is the proportion of all behaviors in the nest carried out as that task -->
<!--     if(pY > 0) { -->
<!--       hY <- pY * log(pY)                                            # calculate the shannon's index for that task -->
<!--       HY <- HY + hY                                                 # add it to nestH, to produce an overall H for the nest -->
<!--     } -->
<!--   } -->
<!--   HY <- HY * -1                                                     # multiply HY by -1 b/c negative summation -->
<!--   nestdol$HY[index] <- HY                                           # copy HY into the nestdol df -->
<!--             # calculate I for a given nest -->
<!--             # I = mutual entropy = SUMMATIONxy [ p(x,y) * log( p(x,y) / p(x) * p(y) ) ] -->
<!--             # p(x,y) = nest_m[x,y] -->
<!--             # p(x) = sumRow[x] -->
<!--             # p(y) = sumCol[y] -->
<!--   I <- 0                                                            # reset I to start at 0 for each nest -->
<!--   for(x in 1:nrow(nest_m)) {                                        # for each row in the nest -->
<!--     for(y in 1:ncol(nest_m)) {                                      # iterate through each column (i.e. iterate through each column/row combo -- each entry in matrix) -->
<!--       if(nest_m[x,y] != 0) {                                        # if the matrix value does not equal 0 (which will produce a -inf value of i b/c divided by 0) -->
<!--         pxy <- nest_m[x,y]                                          # assign pxy to the individual matrix cell value (probability of that individual-task combo) -->
<!--         px <- sumRow[x]                                             # assign px to the sum of the matrix row (probability of that individual carrying out a behavior) -->
<!--         py <- sumCol[y]                                             # assign py to the sum of the matrix column (probability of that task occuring) -->
<!--         i <- pxy * log(pxy / (px * py))                             # calculate the mutual entropy for that item in the matrix -->
<!--         I <- I + i                                                  # add it to I, to produce an overall I for the matrix -->
<!--       } else {                                                      # if the matrix value = 0, print that the value equals 0 and don't do any calculations on it -->
<!--         #print(paste("matrix position", x, y, "is value 0" )) -->
<!--       } -->
<!--     } -->
<!--   } -->
<!--   nestdol$I[index] <- I                                             # copy I into the nestdol df -->
<!--             # indivSpec = D Y|X = I / HX -->
<!--             # taskSpec = D X|Y = I / HY -->
<!--             # dolSymmetry = D X,Y = I / sqrt(HX * HY) -->
<!--   indivSpec <- I / HX                                               # calculate individual specialization: division of individuals into tasks -->
<!--   nestdol$indivSpec[index] <- indivSpec                             # copy into nestdol df -->
<!--   taskSpec <- I / HY                                                # calculate task specialization: division of tasks into inviduals -->
<!--   nestdol$taskSpec[index] <- taskSpec                               # copy into nestdol df -->
<!--   symmDOL <- I / (sqrt(HX*HY))                                      # calculate symmetric division of labor -->
<!--   nestdol$symmDOL[index] <- symmDOL                                 # copy into nestdol df -->
<!-- } -->

<!-- nestdol -->
<!-- ``` -->

<!-- # plots -->
<!-- ```{r} -->
<!-- # add nestTYPE column -->
<!-- nestdol$nestTYPE <- substr(nestdol$nestID, start = 1, stop = 2) -->
<!-- # add group size column -->
<!-- nestdol$nBees[nestdol$nestTYPE == "NT"] <- 3  -->
<!-- nestdol$nBees[nestdol$nestTYPE == "NF"] <- 5 -->
<!-- nestdol$nBees[nestdol$nestTYPE == "QT"] <- 4  -->
<!-- nestdol$nBees[nestdol$nestTYPE == "QF"] <- 6  -->

<!-- # density graph of specialization values -->
<!-- nestdol_plot <- nestdol %>% -->
<!--   gather(indivSpec, taskSpec, symmDOL, -->
<!--          key = "dol",  -->
<!--          value = "value") -->
<!-- ggplot(nestdol_plot, aes(value, fill = dol)) +  -->
<!--   geom_density(alpha = 0.3) -->
<!-- ggsave("../figures/nestDOL.jpg") -->

<!-- # taskSpec vs. indivSpec scatterplot -->
<!-- ggplot(nestdol, aes(taskSpec, indivSpec, color = nestTYPE)) + -->
<!--   geom_point(size = 3, alpha = 0.8) + -->
<!-- ggsave("../figures/nestSpec.jpg") -->

<!-- # group size vs. taskSpec scatterplot -->
<!-- ggplot(nestdol, aes(taskSpec, nBees, color = nestTYPE)) + -->
<!--   geom_point(position = position_jitter(width=0.1, height=0.1), alpha = 0.5) + -->
<!--   stat_summary(fun = mean, geom = "point", size = 5) -->

<!-- # group size vs. indivSpec scatterplot -->
<!-- ggplot(nestdol, aes(indivSpec, nBees, color = nestTYPE)) + -->
<!--   geom_point(position = position_jitter(width=0.1, height=0.1), alpha = 0.5) + -->
<!--   stat_summary(fun = mean, geom = "point", size = 5) -->

<!-- # group size vs. symmDOL scatterplot -->
<!-- ggplot(nestdol, aes(symmDOL, nBees, color = nestTYPE)) +  -->
<!--   geom_point(position = position_jitter(width=0.1, height=0.1), alpha = 0.5) + -->
<!--   stat_summary(fun = mean, geom = "point", size = 5) -->
<!-- ``` -->

<!-- <!-- # make sure i'm doing it right by testing an example in the text -- all good! -->
# WHICH ONE IS INDIVIDUAL DOL VS TASK DOL?? OPPOSITE IN TEXT AND FIGURES IN THE PAPER??
<!-- ```{r} -->
<!-- b <- matrix(c(100, 0, 25, 25, 25, 25, 0, 100, 25, 25, 25, 25, 0, 0, 25, 25, 25, 25), nrow = 3, byrow = TRUE) -->
<!-- sum(b) -->
<!-- bb <- b/500 -->
<!-- bb -->
<!-- sum(bb) -->

<!--   # make row and col sum vectors to use in future calculations -->
<!--   sumRow <- rowSums(bb) -->
<!--   sumCol <- colSums(bb) -->

<!--   # calculate nest-level individual shannon diversity index via mutual entropy paper's definition -->
<!--   # HZ = -SUMMATIONz [ p(Z) * log (p(Z)) ] -->
<!--   HX <- 0 -->
<!--   for(x in 1:nrow(bb)) {        # for each individual -->
<!--     pX <- sumRow[x]               # p is the proportion of all behaviors in the nest carried out by that individual -->
<!--     hX <- pX * log(pX)            # calculate the shannon's index for that individual -->
<!--     HX <- HX + hX                 # add it to nestH, to produce an overall H for the nest -->
<!--   } -->
<!--   HX <- HX * -1 -->

<!--   # calculate nest-level task shannon diversity index via mutual entropy paper's definition -->
<!--   # HX = -SUMMATIONz [ p(Z) * log (p(Z)) ] -->
<!--   HY <- 0 -->
<!--   for(y in 1:ncol(bb)) {      # for each task -->
<!--     pY <- sumCol[y]               # p is the proportion of all behaviors in the nest carried out as that task -->
<!--     if(pY > 0) { -->
<!--       hY <- pY * log(pY)            # calculate the shannon's index for that task -->
<!--       HY <- HY + hY                 # add it to nestH, to produce an overall H for the nest -->
<!--     } -->
<!--   } -->
<!--   HY <- HY * -1 -->

<!--   # I = mutual entropy = SUMMATIONxy [ p(x,y) * log( p(x,y) / p(x) * p(y) ) ] -->
<!--   # p(x,y) = nest_m[x,y] -->
<!--   # p(x) = sumRow[x] -->
<!--   # p(y) = sumCol[y] -->

<!--   # calculate I for a given nest -->
<!--   I <- 0 -->
<!--   # create variable I to add total entropy to -->
<!--   for(x in 1:nrow(bb)) {                # for each row in the nest -->
<!--     for(y in 1:ncol(bb)) {              # iterate through each column (i.e. iterate through each column/row combo -- each entry in matrix) -->
<!--       if(bb[x,y] != 0) {                # if the matrix value does not equal 0 (which will produce a -inf value of i b/c divided by 0) -->
<!--         pxy <- bb[x,y] -->
<!--         px <- sumRow[x] -->
<!--         py <- sumCol[y] -->
<!--         i <- pxy * log(pxy / (px * py))   # calculate the mutual entropy for that item in the matrix -->
<!--         I <- I + i                        # add it to I, to produce an overall I for the matrix -->
<!--       } else {                            # if the matrix value = 0, print that the value equals 0 and don't do any calculations on it -->
<!--         #print(paste("matrix position", x, y, "is value 0" )) -->
<!--       } -->
<!--     } -->
<!--   } -->

<!--   # indivSpec = D Y|X = I / HX -->
<!--   # taskSpec = D X|Y = I / HY -->
<!--   # dolSymmetry = D X,Y = I / sqrt(HX * HY) -->

<!--   # calculate individual specialization: division of individuals into tasks -->
<!--   indivSpec <- I / HX -->
<!--   indivSpec -->
<!--   # calculate task specialization: division of tasks into inviduals -->
<!--   taskSpec <- I / HY -->
<!--   taskSpec -->
<!--   # calculate symmetric division of labor -->
<!--   symmDOL <- I / (sqrt(HX*HY)) -->
<!--   symmDOL -->
<!-- ``` -->