---
title: "dol"
author: "ES"
date: "7/17/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# load packages
```{r, echo = FALSE}
library(vegan)    # shannon diversity function
library(ggplot2)  # plots
library(ggpubr)   # ggdensity plots
library(lme4)     # glmms
library(sjPlot)   # model summary
library(multcomp) # tukey tests
library(car)      # qqp
library(MuMIn)    # model.sel
```

# load data
```{r}
# pooled data across timepoints, values are counts
# only includes bees with >=3 observations, regardless of # observations per nest
shanP_data <- read.csv("../Data/tempData/beeCounts_filt.csv")
shanP_data$nestTYPE <- ordered(shanP_data$nestTYPE, levels = c("NT", "QT", "NF", "QF"))

# split across timepoints, bees with >=3 observations, regardless of # observations per nest
# some bees are only included in early (and not late) and vice versa 
shanEarly_data <- read.csv("../Data/tempData/beeEarlyCounts_filt.csv")
shanLate_data <- read.csv("../Data/tempData/beeLateCounts_filt.csv")
# merge early and late shannon
shanT_data <- rbind(shanEarly_data, shanLate_data)
shanT_data$nestTYPE <- ordered(shanT_data$nestTYPE, levels = c("NT", "QT", "NF", "QF"))
shanT_data
```

# add natal colony to both dfs
```{r}
master <- read.csv("../Data/CleanMasterData.csv")
master

# make a new column in shanP_data for natal colony
shanP_data$natal <- NA
shanT_data$natal <- NA

# for each bee in the shanP_data df
for (i in 1:nrow(shanP_data)) {
  # go through master until you find the matching nestID
  for (j in 1:nrow(master)) {
    # if the nest ID matches
    if (shanP_data$nestID[i] == master$nestID[j]) {
      # if shanP_data bee is a queen
      if(shanP_data$caste[i] == "queen") {
        # add queen natal colony to shanP_data
        shanP_data$natal[i] <- master$Qnatal[j]
      }
      # if shanP_data bee is a worker
      if (shanP_data$caste[i] == "worker") {
        # add worker natal colony to shanP_data
        shanP_data$natal[i] <- master$Wnatal[j]
      }
    }
  }
}
# for each bee in the shanT df
for (i in 1:nrow(shanT_data)) {
  # go through master until you find the matching nestID
  for (j in 1:nrow(master)) {
    # if the nest ID matches
    if (shanT_data$nestID[i] == master$nestID[j]) {
      # if shanT_data bee is a queen
      if(shanT_data$caste[i] == "queen") {
        # add queen natal colony to shanT_data
        shanT_data$natal[i] <- master$Qnatal[j]
      }
      # if shanT_data bee is a worker
      if (shanT_data$caste[i] == "worker") {
        # add worker natal colony to shanT_data
        shanT_data$natal[i] <- master$Wnatal[j]
      }
    }
  }
}
```

# shannon index for each individual

# POOLED TIMEPOINTS, including egg laying, separate foraging
yields df: dol
same as shanP_data df, but with shannon index as shannon column
```{r}
# rename for reproducibility
dol <- shanP_data

# start with matrix where each row is an individual, and each column is a behavior
dol_m <- as.matrix(dol[,c("feedsbrood", "nectarforaging", "pollenforaging", "egglaying")])

# make a column to enter shannon into dol df
dol$shannon <- NA
# calculate shannon for each bee in the matrix and add to shannon column
dol$shannon <- diversity(dol_m, index = "shannon") 

# plot density curves of shannon values by nest type
ggplot(dol, aes(shannon, fill = nestTYPE)) + 
  geom_density(alpha = 0.3)
ggsave("../figures/shannonHist.jpg")

# plot nestTYPE vs. shannon scatterplot
ggplot(dol, aes(shannon, nestTYPE, color = nestTYPE, shape = caste)) +
  geom_point(position = position_jitter(width=0.05, height=0.2), alpha = 0.5) +
  scale_shape_manual(values = c(21, 16)) +
  stat_summary(fun = mean, geom = "point", size = 5)
ggsave("../figures/pooledShannon.jpg")

# plot number of behaviors vs. shannon scatterplot
ggplot(dol, aes(shannon, nBehavs, color = nestTYPE, shape = caste)) +
  geom_point(position = position_jitter(width=0.05, height=1), alpha = 0.8, size = 2) +
  scale_shape_manual(values = c(21, 16))
ggsave("../figures/pooledShannonVSnBehavs.jpg")
```

# POOLED behavioral specialists
```{r}
# define shannon threshold under which represents a specialist
shannonSpecialist <- 0.6

# subset to look only at specialists
specPool <- dol[dol$shannon < shannonSpecialist,]
nonSpecPool <- dol[dol$shannon >= shannonSpecialist,]

# name the behavior that each specialist specializes in
# define the number of columns prior to the first behavior
skip <- 8
# make a column for behavioral specialization
specPool$specBehav <- NA
specPool$specProp <- NA

for (i in 1:nrow(specPool)) {
  # name the behavior that each individual specialized in: column index of max number of behaviors + skip columns
  behavior <- names(specPool[skip + max.col(specPool[i, c("feedsbrood", "nectarforaging", "pollenforaging", "egglaying")])])
  # input that behavior into specBehav column
  specPool$specBehav[i] <- behavior
  # calculate proportion of total behaviors comprised by specialized behavior
  specPool$specProp[i] <- specPool[i, behavior] / specPool$nBehavs[i]
}
specPool

# caclulate minimum proportion of behaviors carried out by specialists
minSpecProp <- min(specPool$specProp)
print(paste0("With a shannon specialist cutoff of ", shannonSpecialist, ", the specialized behavior comprises ", minSpecProp, " to 100% of all behaviors carried out by a given individual."))


behavior <- specPool$specBehav[1]
behavior
specPool[1, behavior]
specPool

# look at proportions of behaviors with specialists


# add back in non-specialists, with NA value in specBehav column

# make NA column for specBehav
nonSpecPool$specBehav <- "generalist"
nonSpecPool$specProp <- NA
ALLspecPool <- rbind(specPool, nonSpecPool)


# write to drive
write.csv(ALLspecPool, "../Data/tempData/beeCounts_filtSpecPOOLED.csv")
ALLspecPool

# count number of specialists in each category per nest
# make empty matrix to put number into
nSpec <- matrix(NA, ncol = 3, nrow = length(unique(dol$nestID))*5)
# convert to df
nSpec <- as.data.frame(nSpec)
# name columns relevant info
colnames(nSpec) <- c("nestID", "specBehav", "nBeesPerNest")
# repeat the 4 behaviors over in specBehav column
nSpec$specBehav <- c("feedsbrood", "nectarforaging", "pollenforaging", "egglaying", "generalist")
# set number of specialists to 0
nSpec$nBeesPerNest <- 0
# fill nestID with 5x each nest id (one for each behavior)
for (i in 0:(length(unique(dol$nestID))-1)) {
  nSpec$nestID[((i * 5) + 1):((i + 1) * 5)] <- unique(dol$nestID)[i + 1]
}
# replace number of bees with accurate number
# first summarize 
nSpec_missing0 <- ALLspecPool %>% dplyr::group_by(nestID, nestTYPE, specBehav) %>% dplyr::summarise(nBeesPerNest = dplyr::n())
nSpec_missing0

# for each line in nSpec_missing0
for (i in 1:nrow(nSpec_missing0)) {
  # iterate through the nSpec df
  for (j in 1:nrow(nSpec)) {
    # until you find matching nestID and specBehav comb
    if (nSpec_missing0$nestID[i] == nSpec$nestID[j] && nSpec_missing0$specBehav[i] == nSpec$specBehav[j]) {
      # copy number of bees per nest into nSpec
      nSpec$nBeesPerNest[j] <- nSpec_missing0$nBeesPerNest[i]
      } else {}
  }
}
nSpec
nSpec$nestTYPE <- substr(nSpec$nestID, start = 1, stop = 2)
nSpec$nestTYPE <- ordered(nSpec$nestTYPE, levels = c("NT", "QT", "NF", "QF"))
nSpec$specBehav <- ordered(nSpec$specBehav, levels = c("generalist", "pollenforaging", "nectarforaging", "feedsbrood", "egglaying"))


ggplot(nSpec, aes(nBeesPerNest, specBehav)) +
  geom_point(position = position_jitter(width=0.15, height=0.2), alpha = 0.9, aes(color = nestTYPE)) +
  stat_summary(fun = mean, geom = "point", size = 5)
ggsave("../figures/nSpecialists.jpg")
```

# COMPARE EARLY VS LATE TIMEPOINTS, excluding egg laying, separate nectar & pollen foraging
```{r}
dolT <- shanT_data

# convert to matrix of behaviors to be used in shannon
dolT_m <- as.matrix(dolT[,c("feedsbrood", "nectarforaging", "pollenforaging")])

# calculate shannon for each bee in the matrix
dolT$shannon <- diversity(dolT_m, index = "shannon") 
dolT$casteTime <- paste0(dolT$timepoint, dolT$caste)

# plot shannon values by timepoint
ggplot(dolT, aes(shannon, nestTYPE, shape = casteTime, fill = nestTYPE, color = nestTYPE)) + 
  geom_point(position = position_jitter(width=0.15, height=0.2), alpha = 0.8) +
  scale_shape_manual(values = c(15, 17, 0, 6)) +
  stat_summary(fun = mean, geom = "point", size = 5)
ggsave("../figures/shannonHistTime.jpg")

# find change in shannon over time per bee

# make beeID include nest for clarity
dolT$beeID <- paste0(dolT$nestID, dolT$beeID)

# add shanDist column to put distance into
dolT$shanDist <- NA

# calculate change and add to shanDist column
for (i in 1:nrow(dolT)) {                                                   # for each row in the dataset
  if(dolT$timepoint[i] == "late") {                                         # look at the the late bees only
    for (j in 1:nrow(dolT)) {                                               # then iterate back through the dataset
      if(dolT$timepoint[j] == "early" & dolT$beeID[j] == dolT$beeID[i]) {   # and find the early entry with the same bee ID
        dolT$shanDist[i] <- dolT$shannon[i] - dolT$shannon[j]               # calculate the difference in shannon index across time
      }
    }
  }
}

# plot the change in shannon from early to late
ggplot(dolT, aes(shanDist, fill = nestTYPE)) + 
  geom_density(alpha = 0.3)

avgShannDist <- dolT %>% dplyr::summarize(avg = mean(shanDist, na.rm = T)) %>% dplyr::pull(avg)
avgShannDist
ggplot(dolT, aes(shanDist, nestTYPE, color = nestTYPE, shape = caste)) +
  geom_point(position = position_jitter(width=0.1, height=0.2), alpha = 0.5) +
  scale_shape_manual(values = c(21, 16)) +
  stat_summary(fun = mean, geom = "point", size = 5) +
  geom_vline(aes(xintercept = avgShannDist), color = "gray70", size = 0.6) +
  labs(x = "change in shannon index from early to late timepoint")
ggsave("../figures/shanDist.jpg")

# look at how many bees it's actually plotting here -- ~10 per nestTYPE
dolT[!is.na(dolT$shanDist),]
dolT
```

# COMAPRE EARLY AND LATE behavioral specialists
```{r}
# define shannon threshold under which represents a specialist
shannonSpecialist <- 0.6

# subset to look only at specialists
specTime <- dolT[dolT$shannon < shannonSpecialist,]
nonSpecTime <- dolT[dolT$shannon >= shannonSpecialist,]

# name the behavior that each specialist specializes in
# define the number of columns prior to the first behavior
skip <- 10
# name the behavior: column index of max number of behaviors + skip columns
for (i in 1:nrow(specTime)) {
  specTime$specBehav[i] <- names(specTime[skip + max.col(specTime[i, c("feedsbrood", "nectarforaging", "pollenforaging")])])
}
specTime

# add back in non-specialists, with NA value in specBehav column

# make NA column for specBehav
nonSpecTime$specBehav <- "generalist"
ALLspecTime <- rbind(specTime, nonSpecTime)


# write to drive
write.csv(ALLspecTime, "../Data/tempData/beeCounts_filtSpecTIME.csv")
ALLspecTime

# count number of specialists in each category
# make empty matrix to put number into
nSpecT <- matrix(NA, ncol = 4, nrow = length(unique(dolT$nestID))*10)
# convert to df
nSpecT <- as.data.frame(nSpecT)
# name columns relevant info
colnames(nSpecT) <- c("nestID", "timepoint", "specBehav", "nBeesPerNest")
# repeat the 4 behaviors over in specBehav column
nSpecT$specBehav <- c("feedsbrood", "feedsbrood", "nectarforaging", "nectarforaging", "pollenforaging", "pollenforaging", "egglaying", "egglaying", "generalist", "generalist")
# repeat the timepoints over in timepoint column
nSpecT$timepoint <- c("early", "late")
# set number of specialists to 0
nSpecT$nBeesPerNest <- 0
# fill nestID with 4x each nest id (one for each behavior)
for (i in 0:(length(unique(dolT$nestID))-1)) {
  nSpecT$nestID[((i * 10) + 1):((i + 1) * 10)] <- unique(dolT$nestID)[i + 1]
}
# replace number of bees > 0 with accurate number
# first summarize 
nSpec_missing0T <- ALLspecTime %>% dplyr::group_by(nestID, nestTYPE, specBehav, timepoint) %>% dplyr::summarise(nBeesPerNest = dplyr::n())
nSpec_missing0T

# for each line in nSpec_missing0T
for (i in 1:nrow(nSpec_missing0T)) {
  # iterate through the nSpecT df
  for (j in 1:nrow(nSpecT)) {
    # until you find matching nestID and specBehav comb
    if (nSpec_missing0T$nestID[i] == nSpecT$nestID[j] && nSpec_missing0T$specBehav[i] == nSpecT$specBehav[j] && nSpec_missing0T$timepoint[i] == nSpecT$timepoint[j]) {
      # copy number of bees per nest into nSpecT
      nSpecT$nBeesPerNest[j] <- nSpec_missing0T$nBeesPerNest[i]
      } else {}
  }
}

nSpecT$nestTYPE <- substr(nSpecT$nestID, start = 1, stop = 2) 
nSpecT$nestTYPE <- ordered(nSpecT$nestTYPE, levels = c("NT", "QT", "NF", "QF"))
nSpecT$specBehav <- ordered(nSpecT$specBehav, levels = c("generalist", "pollenforaging", "nectarforaging", "feedsbrood", "egglaying"))

ggplot(nSpecT, aes(nBeesPerNest, specBehav, shape = timepoint)) +
  geom_point(position = position_jitter(width=0.18, height=0.2), alpha = 0.7, aes(color = nestTYPE)) +
  scale_shape_manual(values = c(17, 25)) +
  stat_summary(fun = mean, geom = "point", size = 5) 
ggsave("../figures/nSpecialistsTIME.jpg")


```
# two part model on pooled shannon across nestTYPES
```{r}
# make a new column for over or under 0
dol$shan0 <- NA
# if shannon = 0, shan0 = 1
dol$shan0[dol$shannon == 0] <- 1
# if shannon > 0, shan0 = 0
dol$shan0[dol$shannon > 0] <- 0


# model 0 vs. >0 shannon values
# need to add natal colony as random effect
ps0 <- glmer(shan0 ~ 1 + (1|nestID) + (1|natal),
              data = dol, family = binomial(link = "logit"))
ps1 <- glmer(shan0 ~ nestTYPE + nBehavs + caste + (1|nestID) + (1|natal),
              data = dol, family = binomial(link = "logit"))
ps2 <- glmer(shan0 ~ nestTYPE + nBehavs + caste + (1|nestID) + (1|natal),
              data = dol, family = binomial(link = "logit"))
ps3 <- glmer(shan0 ~ nestTYPE + caste + (1|nestID) + (1|natal),
              data = dol, family = binomial(link = "logit"))
ps4 <- glmer(shan0 ~ nestTYPE + nBehavs + (1|nestID) + (1|natal),
              data = dol, family = binomial(link = "logit"))
ps5 <- glmer(shan0 ~ nBehavs + caste + (1|nestID) + (1|natal),
              data = dol, family = binomial(link = "logit"))
ps6 <- glmer(shan0 ~ nestTYPE + (1|nestID) + (1|natal),
              data = dol, family = binomial(link = "logit"))
ps7 <- glmer(shan0 ~ nBehavs + (1|nestID) + (1|natal),
              data = dol, family = binomial(link = "logit"))
ps8 <- glmer(shan0 ~ caste + (1|nestID) + (1|natal),
              data = dol, family = binomial(link = "logit"))
model.sel(ps0, ps1, ps2, ps3, ps4, ps5, ps6, ps7, ps8)

mymodel <- ps5
tab_model(mymodel)
# plot model residuals
plot(fitted(mymodel), residuals(mymodel), xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, lty = 2)
lines(smooth.spline(fitted(mymodel), residuals(mymodel)))

################

# make a new column that contains only shannon for bees with shannon > 0
dol$shan1 <- NA
dol$shan1[dol$shannon > 0] <- dol$shannon[dol$shannon > 0]
# it's mostly normal
qqp(dol$shan1, "norm")

# model 0 vs. >0 shannon values
# need to add natal colony as random effect
ps0 <- glmer(shan1 ~ 1 + (1|nestID)  + (1|natal),
              data = dol)
ps1 <- glmer(shan1 ~ nestTYPE + nBehavs + caste + (1|nestID) + (1|natal),
              data = dol)
ps2 <- glmer(shan1 ~ nestTYPE + nBehavs + (1|nestID) + (1|natal),
              data = dol)
ps3 <- glmer(shan1 ~ nestTYPE + caste + (1|nestID) + (1|natal),
              data = dol)
ps4 <- glmer(shan1 ~ nestTYPE + nBehavs + (1|nestID) + (1|natal),
              data = dol)
ps5 <- glmer(shan1 ~ nBehavs + caste + (1|nestID) + (1|natal),
              data = dol)
ps6 <- glmer(shan1 ~ nestTYPE + (1|nestID) + (1|natal),
              data = dol)
ps7 <- glmer(shan1 ~ nBehavs + (1|nestID) + (1|natal),
              data = dol)
ps8 <- glmer(shan1 ~ caste + (1|nestID) + (1|natal),
              data = dol)
model.sel(ps0, ps1, ps2, ps3, ps4)

mymodel <- ps0
tab_model(mymodel)
# plot model residuals
modelResiduals <- resid(mymodel, type = "pearson") # Extract standardized residuals 
hist(modelResiduals)
```
# glmms on pooled shannon across nestTYPEs -->
<!-- ```{r} -->
<!-- # it's not normal... not sure what distribution to use -->
<!-- over0 <- dol$shannon[dol$shannon > 0] -->
<!-- ggdensity(dol$shannon) -->
<!-- hist(dol$shannon) -->
<!-- qqp(dol$shannon, "norm") -->
<!-- qqp(over0, "norm") -->
<!-- dol$shannon1 <- dol$shannon + 1 -->
<!-- gamma <- fitdistr(dol$shannon1, "gamma") -->
<!-- qqp(dol$shannon1, "gamma", shape = gamma$estimate[[1]], rate = gamma$estimate[[2]]) -->
<!-- beta <- fitdistr(dol$shannon1, "beta") -->
<!-- qqp(dol$shannon1, "beta", shape = beta$estimate[[1]], rate = beta$estimate[[2]]) -->
<!-- qqp(dol$shannon, "beta") -->
<!-- ebeta() -->

<!-- library(qqplotr) -->
<!-- di <- "exp" -->
<!-- dp <- list(rate = 2) -->
<!-- de <- TRUE # enabling the detrend option -->
<!-- # normal -->
<!-- gg <- ggplot(data = dol, mapping = aes(sample = shannon)) + -->
<!--     stat_qq_band() + -->
<!--     stat_qq_line() + -->
<!--     stat_qq_point() -->
<!-- # other -->
<!-- gg <- ggplot(data = dol, mapping = aes(sample = shannon)) + -->
<!--     stat_qq_band(distribution = di, dparams = dp, detrend = de) + -->
<!--     stat_qq_line(distribution = di, dparams = dp, detrend = de) + -->
<!--     stat_qq_point(distribution = di, dparams = dp, detrend = de) -->
<!-- gg -->
<!-- qqPlot(dol$shannon, "normal") -->
<!-- dol -->

<!-- # MODELS -->

<!-- dol$queen <- 0 -->
<!-- dol$queen[dol$nestTYPE == "QT"] <- 1 -->
<!-- dol$queen[dol$nestTYPE == "QF"] <- 1 -->
<!-- dol -->
<!-- # need to add natal colony as random effect -->
<!-- # ps0 <- glmer(shannon ~ 1 + (1|nestID) + (1|caste), -->
<!-- #               data = dol) -->
<!-- # ps1 <- glmer(shannon ~ nestTYPE*nBehavs + (1|nestID) + (1|caste), -->
<!-- #               data = dol) -->
<!-- ps2 <- glmer(shannon ~ nestTYPE + nBehavs + (1|nestID) + (1|caste), -->
<!--              data = dol) -->
<!-- # ps3 <- glmer(shannon ~ nestTYPE + (1|nestID) + (1|caste), -->
<!-- #               data = dol) -->
<!-- # ps4 <- glmer(shannon ~ nBehavs + (1|nestID) + (1|caste), -->
<!-- #               data = dol) -->
<!-- # model.sel(ps0, ps1, ps2, ps3, ps4) -->

<!-- mymodel <- ps -->

<!-- # mymodel <- ps2 -->
<!-- # summary(mymodel) -->
<!-- # tab_model(mymodel) -->

<!-- # library("glmmTMB") -->
<!-- # mymodel <- glmmTMB(shannon ~ nestTYPE + nBehavs + (1|nestID) + (1|caste), -->
<!-- #                    family = nbinom2, data = dol) -->
<!-- # library("mgcv") -->
<!-- # mymodel <- gam(shannon ~ nestTYPE + nBehavs, -->
<!-- #                    family = nb, method = "ML", data = dol) -->
<!-- # plot model residuals -->
<!-- plot(fitted(mymodel), residuals(mymodel), xlab = "Fitted Values", ylab = "Residuals") -->
<!-- abline(h = 0, lty = 2) -->
<!-- lines(smooth.spline(fitted(mymodel), residuals(mymodel))) -->
<!-- ``` -->

# glmms on early vs. late shannons
```{r}
# two part model
# make a new column for over or under 0
dolT$shan0 <- NA
# if shannon = 0, shan0 = 1
dolT$shan0[dolT$shannon == 0] <- 1
# if shannon > 0, shan0 = 0
dolT$shan0[dolT$shannon > 0] <- 0


# model 0 vs. >0 shannon values
# need to add natal colony as random effect
ps0 <- glmer(shan0 ~ 1 + (1|nestID) + (1|natal),
              data = dolT, family = binomial(link = "logit"))
ps1 <- glmer(shan0 ~ timepoint + nestTYPE + nBehavs + caste + (1|nestID) + (1|natal),
              data = dolT, family = binomial(link = "logit"))
ps2 <- glmer(shan0 ~ nestTYPE + nBehavs + caste + (1|nestID) + (1|natal),
              data = dolT, family = binomial(link = "logit"))
ps3 <- glmer(shan0 ~ timepoint + nestTYPE + caste + (1|nestID) + (1|natal),
              data = dolT, family = binomial(link = "logit"))
ps4 <- glmer(shan0 ~ timepoint + nestTYPE + nBehavs + (1|nestID) + (1|natal),
              data = dolT, family = binomial(link = "logit"))
ps5 <- glmer(shan0 ~ timepoint + nBehavs + caste + (1|nestID) + (1|natal),
              data = dolT, family = binomial(link = "logit"))
ps6 <- glmer(shan0 ~ nestTYPE + nBehavs + caste + (1|nestID) + (1|natal),
              data = dolT, family = binomial(link = "logit"))
ps7 <- glmer(shan0 ~ timepoint + nestTYPE + (1|nestID) + (1|natal),
              data = dolT, family = binomial(link = "logit"))
ps8 <- glmer(shan0 ~ timepoint + nBehavs + (1|nestID) + (1|natal),
              data = dolT, family = binomial(link = "logit"))
ps9 <- glmer(shan0 ~ timepoint + caste + (1|nestID) + (1|natal),
              data = dolT, family = binomial(link = "logit"))
ps10 <- glmer(shan0 ~ nestTYPE + caste + (1|nestID) + (1|natal),
              data = dolT, family = binomial(link = "logit"))
ps11 <- glmer(shan0 ~ timepoint + nBehavs + (1|nestID) + (1|natal),
              data = dolT, family = binomial(link = "logit"))
ps12 <- glmer(shan0 ~ nestTYPE + nBehavs + (1|nestID) + (1|natal),
              data = dolT, family = binomial(link = "logit"))
ps13 <- glmer(shan0 ~ nBehavs + caste + (1|nestID) + (1|natal),
              data = dolT, family = binomial(link = "logit"))
ps14 <- glmer(shan0 ~ nestTYPE + (1|nestID) + (1|natal),
              data = dolT, family = binomial(link = "logit"))
ps15 <- glmer(shan0 ~ nBehavs + (1|nestID) + (1|natal),
              data = dolT, family = binomial(link = "logit"))
ps16 <- glmer(shan0 ~ caste + (1|nestID) + (1|natal),
              data = dolT, family = binomial(link = "logit"))
model.sel(ps0, ps1, ps2, ps3, ps4, ps5, ps6, ps7, ps8, ps9, ps10, ps11, ps12, ps13, ps14, ps15, ps16)

mymodel <- ps15
tab_model(mymodel)
# plot model residuals
plot(fitted(mymodel), residuals(mymodel), xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, lty = 2)
lines(smooth.spline(fitted(mymodel), residuals(mymodel)))

################

# make a new column that contains only shannon for bees with shannon > 0
dolT$shan1 <- NA
dolT$shan1[dolT$shannon > 0] <- dolT$shannon[dolT$shannon > 0]
# it's mostly normal
hist(dolT$shan1)
qqp(dolT$shan1, "norm")

# model 0 vs. >0 shannon values
# need to add natal colony as random effect
ps0 <- glmer(shan1 ~ 1 + (1|nestID) + (1|natal),
              data = dolT)
ps1 <- glmer(shan1 ~ timepoint + nestTYPE + nBehavs + caste + (1|nestID) + (1|natal),
              data = dolT)
ps2 <- glmer(shan1 ~ nestTYPE + nBehavs + caste + (1|nestID) + (1|natal),
              data = dolT)
ps3 <- glmer(shan1 ~ timepoint + nestTYPE + caste + (1|nestID) + (1|natal),
              data = dolT)
ps4 <- glmer(shan1 ~ timepoint + nestTYPE + nBehavs + (1|nestID) + (1|natal),
              data = dolT)
ps5 <- glmer(shan1 ~ timepoint + nBehavs + caste + (1|nestID) + (1|natal),
              data = dolT)
ps6 <- glmer(shan1 ~ nestTYPE + nBehavs + caste + (1|nestID) + (1|natal),
              data = dolT)
ps7 <- glmer(shan1 ~ timepoint + nestTYPE + (1|nestID) + (1|natal),
              data = dolT)
ps8 <- glmer(shan1 ~ timepoint + nBehavs + (1|nestID) + (1|natal),
              data = dolT)
ps9 <- glmer(shan1 ~ timepoint + caste + (1|nestID) + (1|natal),
              data = dolT)
ps10 <- glmer(shan1 ~ nestTYPE + caste + (1|nestID) + (1|natal),
              data = dolT)
ps11 <- glmer(shan1 ~ timepoint + nBehavs + (1|nestID) + (1|natal),
              data = dolT)
ps12 <- glmer(shan1 ~ nestTYPE + nBehavs + (1|nestID) + (1|natal),
              data = dolT)
ps13 <- glmer(shan1 ~ nBehavs + caste + (1|nestID) + (1|natal),
              data = dolT)
ps14 <- glmer(shan1 ~ nestTYPE + (1|nestID) + (1|natal),
              data = dolT)
ps15 <- glmer(shan1 ~ nBehavs + (1|nestID) + (1|natal),
              data = dolT)
ps16 <- glmer(shan1 ~ caste + (1|nestID) + (1|natal),
              data = dolT)
model.sel(ps0, ps1, ps2, ps3, ps4, ps5, ps6, ps7, ps8, ps9, ps10, ps11, ps12, ps13, ps14, ps15, ps16)

mymodel <- ps0
tab_model(mymodel)

# plot model residuals
plot(fitted(mymodel), residuals(mymodel), xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, lty = 2)
lines(smooth.spline(fitted(mymodel), residuals(mymodel)))
```

# glmms on change in shannon across timepoints
```{r}
# pretty normal
ggdensity(dolT$shanDist)
qqp(dolT$shanDist, "norm")

# need to add natal colony as random effect
cs0 <- glmer(shanDist ~ 1 + (1|nestID) + (1|natal),
              data = dolT)
cs1 <- glmer(shanDist ~ nestTYPE + caste + (1|nestID) + (1|natal),
              data = dolT)
cs2 <- glmer(shanDist ~ nestTYPE + (1|nestID) + (1|natal),
              data = dolT)
cs3 <- glmer(shanDist ~ caste + (1|nestID) + (1|natal),
              data = dolT)
model.sel(cs0, cs1, cs2, cs3)

mymodel <- cs2
tab_model(mymodel)
posthoc1 <- glht(mymodel, linfct = mcp(nestTYPE = "Tukey"))
summary(posthoc1)

# plot model residuals
plot(fitted(mymodel), residuals(mymodel), xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, lty = 2)
lines(smooth.spline(fitted(mymodel), residuals(mymodel)))
```

# tally specialists switching across timepoints
```{r}
ALLspecTime

# condense df so each bee is one row with early/late specializations as separate columns
specSwitch <- pivot_wider(data = ALLspecTime, 
                          id_cols = c("nestID", "nestTYPE", "beeID", "caste", "natal"),
                          names_from = timepoint,
                          values_from = specBehav)

# tally switches
## rename NA to "lazy"
specSwitch[is.na(specSwitch$early), "early"] <- "lazy"
specSwitch[is.na(specSwitch$late), "late"] <- "lazy"
## name the behavioral specializations
behavs <- unique(specSwitch$early)
behavs
## make a df with each row and column as each behavior
tallySwitches <- matrix(0, nrow = length(behavs), ncol = length(behavs))
tallySwitches <- as.data.frame(tallySwitches)
rownames(tallySwitches) <- behavs
colnames(tallySwitches) <- behavs
## tally the switches
for(i in 1:nrow(specSwitch)) {
  if(specSwitch$early[i] == "feedsbrood") {
    if(specSwitch$late[i] == "feedsbrood") {
      tallySwitches["feedsbrood", "feedsbrood"] <- tallySwitches["feedsbrood", "feedsbrood"] + 1
    }
    if(specSwitch$late[i] == "nectarforaging") {
      tallySwitches["feedsbrood", "nectarforaging"] <- tallySwitches["feedsbrood", "nectarforaging"] + 1
    }
    if(specSwitch$late[i] == "pollenforaging") {
      tallySwitches["feedsbrood", "pollenforaging"] <- tallySwitches["feedsbrood", "pollenforaging"] + 1
    }
    if(specSwitch$late[i] == "generalist") {
      tallySwitches["feedsbrood", "generalist"] <- tallySwitches["feedsbrood", "generalist"] + 1
    }
    if(specSwitch$late[i] == "lazy") {
      tallySwitches["feedsbrood", "lazy"] <- tallySwitches["feedsbrood", "lazy"] + 1
    }
  }
  if(specSwitch$early[i] == "nectarforaging") {
    if(specSwitch$late[i] == "feedsbrood") {
      tallySwitches["nectarforaging", "feedsbrood"] <- tallySwitches["nectarforaging", "feedsbrood"] + 1
    }
    if(specSwitch$late[i] == "nectarforaging") {
      tallySwitches["nectarforaging", "nectarforaging"] <- tallySwitches["nectarforaging", "nectarforaging"] + 1
    }
    if(specSwitch$late[i] == "pollenforaging") {
      tallySwitches["nectarforaging", "pollenforaging"] <- tallySwitches["nectarforaging", "pollenforaging"] + 1
    }
    if(specSwitch$late[i] == "generalist") {
      tallySwitches["nectarforaging", "generalist"] <- tallySwitches["nectarforaging", "generalist"] + 1
    }
    if(specSwitch$late[i] == "lazy") {
      tallySwitches["nectarforaging", "lazy"] <- tallySwitches["nectarforaging", "lazy"] + 1
    }
  }
  if(specSwitch$early[i] == "pollenforaging") {
    if(specSwitch$late[i] == "feedsbrood") {
      tallySwitches["pollenforaging", "feedsbrood"] <- tallySwitches["pollenforaging", "feedsbrood"] + 1
    }
    if(specSwitch$late[i] == "nectarforaging") {
      tallySwitches["pollenforaging", "nectarforaging"] <- tallySwitches["pollenforaging", "nectarforaging"] + 1
    }
    if(specSwitch$late[i] == "pollenforaging") {
      tallySwitches["pollenforaging", "pollenforaging"] <- tallySwitches["pollenforaging", "pollenforaging"] + 1
    }
    if(specSwitch$late[i] == "generalist") {
      tallySwitches["pollenforaging", "generalist"] <- tallySwitches["pollenforaging", "generalist"] + 1
    }
    if(specSwitch$late[i] == "lazy") {
      tallySwitches["pollenforaging", "lazy"] <- tallySwitches["pollenforaging", "lazy"] + 1
    }
  }
  if(specSwitch$early[i] == "generalist") {
    if(specSwitch$late[i] == "feedsbrood") {
      tallySwitches["generalist", "feedsbrood"] <- tallySwitches["generalist", "feedsbrood"] + 1
    }
    if(specSwitch$late[i] == "nectarforaging") {
      tallySwitches["generalist", "nectarforaging"] <- tallySwitches["generalist", "nectarforaging"] + 1
    }
    if(specSwitch$late[i] == "pollenforaging") {
      tallySwitches["generalist", "pollenforaging"] <- tallySwitches["generalist", "pollenforaging"] + 1
    }
    if(specSwitch$late[i] == "generalist") {
      tallySwitches["generalist", "generalist"] <- tallySwitches["generalist", "generalist"] + 1
    }
    if(specSwitch$late[i] == "lazy") {
      tallySwitches["generalist", "lazy"] <- tallySwitches["generalist", "lazy"] + 1
    }
  }
  if(specSwitch$early[i] == "lazy") {
    if(specSwitch$late[i] == "feedsbrood") {
      tallySwitches["lazy", "feedsbrood"] <- tallySwitches["lazy", "feedsbrood"] + 1
    }
    if(specSwitch$late[i] == "nectarforaging") {
      tallySwitches["lazy", "nectarforaging"] <- tallySwitches["lazy", "nectarforaging"] + 1
    }
    if(specSwitch$late[i] == "pollenforaging") {
      tallySwitches["lazy", "pollenforaging"] <- tallySwitches["lazy", "pollenforaging"] + 1
    }
    if(specSwitch$late[i] == "generalist") {
      tallySwitches["lazy", "generalist"] <- tallySwitches["lazy", "generalist"] + 1
    }
    if(specSwitch$late[i] == "lazy") {
      tallySwitches["lazy", "lazy"] <- tallySwitches["lazy", "lazy"] + 1
    }
  }
}
tallySwitches

## add bees who were lazy at both timepoints
allBees <- read.csv("../Data/allBees.csv")
## remove unknown bees
allBees <- allBees[allBees$beeID != "unknown",]
## combine beeID and nestID to use unique identifier
allBees$beeID <- paste0(allBees$nestID, allBees$beeID)
## filter allBees to look only at bees not included in specSwitch df (these are the bees w/o obs at either timepoint -- i.e.-- lazy-lazy)
lazylazy <- allBees %>% filter(!beeID %in% specSwitch$beeID)
## add the number of lazylazy bees to the tallySwitches df
tallySwitches["lazy","lazy"] <- nrow(lazylazy)
tallySwitches
write.csv(tallySwitches, "../Data/tallySwitches.csv")
```






 









































# division of labor mutual entropy
<!-- # division of labor indices -->
<!-- this yeilds a DOL index between 0 (no division) and 1 (complete division) for nest-level tasks, bees, and both task & bee -->
<!-- issues = does not describe which behavior a bee is specializing on. eg specializing entirely on nectar foraging and specializing entirely on egg laying both yield same number -->

<!-- https://www.journals.uchicago.edu/doi/pdfplus/10.1086/424968 -->

<!-- https://watermark.silverchair.com/arn018.pdf?token=AQECAHi208BE49Ooan9kkhW_Ercy7Dm3ZL_9Cf3qfKAc485ysgAAArAwggKsBgkqhkiG9w0BBwagggKdMIICmQIBADCCApIGCSqGSIb3DQEHATAeBglghkgBZQMEAS4wEQQM0mGmfTsnhsoK-Y_uAgEQgIICY-aMO-F9oEaBklacEnjaMSJCFsghtzm6jKWajfSFUi1WmnoBV8zpdiY0ztkvgG8k3Vi7Vaby0gWJGaGto13hllldFKZg-C-TNDdv7yJt81TrpV3M_ooNiYcjJq92Y6ObRoYrlxUJfi77RK3_cDBJ9Ag8JjhA03UWwerFU5FE71P3-7ptplP8rI8QYpXNZdtZbyoYrEN80JYxjgt1o2zAFGvRF3r-_1ExlhdpKr5k0OxGqlCa11kFUpBAjFpMun5qR6JL-8bkcbRIAmNnBBduCg1CSXoUBpx18ouZnNJu_v9OQodZ7hBYPfu62SRjQ9TNEZqadgMAt0mMreuH60st2TagmvXlqLPPyoIu7-0ZBvdD6nvcmJ-miBhUw7Z6vCia1KhrvpvKvhZem2N3zsGsNSp_UFSvVSwtNeHdguMtId5zSe70mWdbDBfTJAsag1sf5YAeCd0XwDSRsfarD2aAYlmQ0ARCd8qC8yxdUlKqohn3Xsh70IBQL1jc_l32k1Q7fiplJiD6hQ69Yge2M961fZML1G5vIQa5DxBgThNYg5GyQxXnyzCFHWJIDhqKwHtWgiWQgbA63qMK2IHNicOSw8JhrpaWlWgEUX8NiaiF7ICzNxFh2pcdL-hnazO1StB1anJtiTo-RHgeLji4E9qYFpT3DYcw6ptUAxjLUql3d1M0aByMRS0EhoZCoUfER_8iiUicTNGUi4w85O5mm55B4vRheg5XGSlby26I0_H9zOtK-eQ3PmKHB4DyPvd-Ch24hp4FBEFJM4pI_sCZJc8_p8JuYOonUk_M3aqNLQKGznrL_xu2 -->
<!-- ```{r} -->
<!-- # MUTUTAL ENTROPY CALCULATIONS -->

<!-- # make df to put entropy values into -->
<!-- nestdol <- matrix(NA, nrow = length(unique(dol_data$nestID)), ncol = 7) -->
<!-- colnames(nestdol) <- c("nestID", "HX","HY", "I", "indivSpec", "taskSpec", "symmDOL") -->
<!-- nestdol <- as.data.frame(nestdol) -->

<!-- # for each nest, calculate mutal entropy for entire matrix (I) -->
<!-- for(index in 1:length(unique(dol_data$nestID))) {                   # for each unique nestID in the dataset -->
<!--   nest_df <- dol_data[dol_data$nestID == unique(dol_data$nestID)[index], ]                          # subset to look only at that nestID -->
<!--   nest_m <- as.matrix(nest_df[,c("feedsbrood", "nectarforaging", "pollenforaging", "egglaying")])   # convert to matrix of behaviors for that nest ID -->
<!--   nestdol$nestID[index] <- unique(dol_data$nestID)[index]           # copy nestID into the nestdol df -->
<!--                                                                     # make row and col sum vectors to use in future calculations -->
<!--   sumRow <- rowSums(nest_m) -->
<!--   sumCol <- colSums(nest_m) -->
<!--             # calculate nest-level individual shannon diversity index via mutual entropy paper's definition -->
<!--             # HZ = -SUMMATIONz [ p(Z) * log (p(Z)) ] -->
<!--   HX <- 0                                                           # reset HX to start at 0 for each nest -->
<!--   for(x in 1:nrow(nest_m)) {                                        # for each individual -->
<!--     pX <- sumRow[x]                                                 # p is the proportion of all behaviors in the nest carried out by that individual -->
<!--     hX <- pX * log(pX)                                              # calculate the shannon's index for that individual -->
<!--     HX <- HX + hX                                                   # add it to nestH, to produce an overall H for the nest -->
<!--   } -->
<!--   HX <- HX * -1                                                     # multiply HX by -1 b/c negative summation -->
<!--   nestdol$HX[index] <- HX                                           # copy HX value into the nestdol df -->
<!--             # calculate nest-level task shannon diversity index via mutual entropy paper's definition -->
<!--             # HZ = -SUMMATIONz [ p(Z) * log (p(Z)) ] -->
<!--   HY <- 0                                                           # reset HY to start at 0 for each nest -->
<!--   for(y in 1:ncol(nest_m)) {                                        # for each task -->
<!--     pY <- sumCol[y]                                                 # p is the proportion of all behaviors in the nest carried out as that task -->
<!--     if(pY > 0) { -->
<!--       hY <- pY * log(pY)                                            # calculate the shannon's index for that task -->
<!--       HY <- HY + hY                                                 # add it to nestH, to produce an overall H for the nest -->
<!--     } -->
<!--   } -->
<!--   HY <- HY * -1                                                     # multiply HY by -1 b/c negative summation -->
<!--   nestdol$HY[index] <- HY                                           # copy HY into the nestdol df -->
<!--             # calculate I for a given nest -->
<!--             # I = mutual entropy = SUMMATIONxy [ p(x,y) * log( p(x,y) / p(x) * p(y) ) ] -->
<!--             # p(x,y) = nest_m[x,y] -->
<!--             # p(x) = sumRow[x] -->
<!--             # p(y) = sumCol[y] -->
<!--   I <- 0                                                            # reset I to start at 0 for each nest -->
<!--   for(x in 1:nrow(nest_m)) {                                        # for each row in the nest -->
<!--     for(y in 1:ncol(nest_m)) {                                      # iterate through each column (i.e. iterate through each column/row combo -- each entry in matrix) -->
<!--       if(nest_m[x,y] != 0) {                                        # if the matrix value does not equal 0 (which will produce a -inf value of i b/c divided by 0) -->
<!--         pxy <- nest_m[x,y]                                          # assign pxy to the individual matrix cell value (probability of that individual-task combo) -->
<!--         px <- sumRow[x]                                             # assign px to the sum of the matrix row (probability of that individual carrying out a behavior) -->
<!--         py <- sumCol[y]                                             # assign py to the sum of the matrix column (probability of that task occuring) -->
<!--         i <- pxy * log(pxy / (px * py))                             # calculate the mutual entropy for that item in the matrix -->
<!--         I <- I + i                                                  # add it to I, to produce an overall I for the matrix -->
<!--       } else {                                                      # if the matrix value = 0, print that the value equals 0 and don't do any calculations on it -->
<!--         #print(paste("matrix position", x, y, "is value 0" )) -->
<!--       } -->
<!--     } -->
<!--   } -->
<!--   nestdol$I[index] <- I                                             # copy I into the nestdol df -->
<!--             # indivSpec = D Y|X = I / HX -->
<!--             # taskSpec = D X|Y = I / HY -->
<!--             # dolSymmetry = D X,Y = I / sqrt(HX * HY) -->
<!--   indivSpec <- I / HX                                               # calculate individual specialization: division of individuals into tasks -->
<!--   nestdol$indivSpec[index] <- indivSpec                             # copy into nestdol df -->
<!--   taskSpec <- I / HY                                                # calculate task specialization: division of tasks into inviduals -->
<!--   nestdol$taskSpec[index] <- taskSpec                               # copy into nestdol df -->
<!--   symmDOL <- I / (sqrt(HX*HY))                                      # calculate symmetric division of labor -->
<!--   nestdol$symmDOL[index] <- symmDOL                                 # copy into nestdol df -->
<!-- } -->

<!-- nestdol -->
<!-- ``` -->

<!-- # plots -->
<!-- ```{r} -->
<!-- # add nestTYPE column -->
<!-- nestdol$nestTYPE <- substr(nestdol$nestID, start = 1, stop = 2) -->
<!-- # add group size column -->
<!-- nestdol$nBees[nestdol$nestTYPE == "NT"] <- 3  -->
<!-- nestdol$nBees[nestdol$nestTYPE == "NF"] <- 5 -->
<!-- nestdol$nBees[nestdol$nestTYPE == "QT"] <- 4  -->
<!-- nestdol$nBees[nestdol$nestTYPE == "QF"] <- 6  -->

<!-- # density graph of specialization values -->
<!-- nestdol_plot <- nestdol %>% -->
<!--   gather(indivSpec, taskSpec, symmDOL, -->
<!--          key = "dol",  -->
<!--          value = "value") -->
<!-- ggplot(nestdol_plot, aes(value, fill = dol)) +  -->
<!--   geom_density(alpha = 0.3) -->
<!-- ggsave("../figures/nestDOL.jpg") -->

<!-- # taskSpec vs. indivSpec scatterplot -->
<!-- ggplot(nestdol, aes(taskSpec, indivSpec, color = nestTYPE)) + -->
<!--   geom_point(size = 3, alpha = 0.8) + -->
<!-- ggsave("../figures/nestSpec.jpg") -->

<!-- # group size vs. taskSpec scatterplot -->
<!-- ggplot(nestdol, aes(taskSpec, nBees, color = nestTYPE)) + -->
<!--   geom_point(position = position_jitter(width=0.1, height=0.1), alpha = 0.5) + -->
<!--   stat_summary(fun = mean, geom = "point", size = 5) -->

<!-- # group size vs. indivSpec scatterplot -->
<!-- ggplot(nestdol, aes(indivSpec, nBees, color = nestTYPE)) + -->
<!--   geom_point(position = position_jitter(width=0.1, height=0.1), alpha = 0.5) + -->
<!--   stat_summary(fun = mean, geom = "point", size = 5) -->

<!-- # group size vs. symmDOL scatterplot -->
<!-- ggplot(nestdol, aes(symmDOL, nBees, color = nestTYPE)) +  -->
<!--   geom_point(position = position_jitter(width=0.1, height=0.1), alpha = 0.5) + -->
<!--   stat_summary(fun = mean, geom = "point", size = 5) -->
<!-- ``` -->

<!-- <!-- # make sure i'm doing it right by testing an example in the text -- all good! -->
# WHICH ONE IS INDIVIDUAL DOL VS TASK DOL?? OPPOSITE IN TEXT AND FIGURES IN THE PAPER??
<!-- ```{r} -->
<!-- b <- matrix(c(100, 0, 25, 25, 25, 25, 0, 100, 25, 25, 25, 25, 0, 0, 25, 25, 25, 25), nrow = 3, byrow = TRUE) -->
<!-- sum(b) -->
<!-- bb <- b/500 -->
<!-- bb -->
<!-- sum(bb) -->

<!--   # make row and col sum vectors to use in future calculations -->
<!--   sumRow <- rowSums(bb) -->
<!--   sumCol <- colSums(bb) -->

<!--   # calculate nest-level individual shannon diversity index via mutual entropy paper's definition -->
<!--   # HZ = -SUMMATIONz [ p(Z) * log (p(Z)) ] -->
<!--   HX <- 0 -->
<!--   for(x in 1:nrow(bb)) {        # for each individual -->
<!--     pX <- sumRow[x]               # p is the proportion of all behaviors in the nest carried out by that individual -->
<!--     hX <- pX * log(pX)            # calculate the shannon's index for that individual -->
<!--     HX <- HX + hX                 # add it to nestH, to produce an overall H for the nest -->
<!--   } -->
<!--   HX <- HX * -1 -->

<!--   # calculate nest-level task shannon diversity index via mutual entropy paper's definition -->
<!--   # HX = -SUMMATIONz [ p(Z) * log (p(Z)) ] -->
<!--   HY <- 0 -->
<!--   for(y in 1:ncol(bb)) {      # for each task -->
<!--     pY <- sumCol[y]               # p is the proportion of all behaviors in the nest carried out as that task -->
<!--     if(pY > 0) { -->
<!--       hY <- pY * log(pY)            # calculate the shannon's index for that task -->
<!--       HY <- HY + hY                 # add it to nestH, to produce an overall H for the nest -->
<!--     } -->
<!--   } -->
<!--   HY <- HY * -1 -->

<!--   # I = mutual entropy = SUMMATIONxy [ p(x,y) * log( p(x,y) / p(x) * p(y) ) ] -->
<!--   # p(x,y) = nest_m[x,y] -->
<!--   # p(x) = sumRow[x] -->
<!--   # p(y) = sumCol[y] -->

<!--   # calculate I for a given nest -->
<!--   I <- 0 -->
<!--   # create variable I to add total entropy to -->
<!--   for(x in 1:nrow(bb)) {                # for each row in the nest -->
<!--     for(y in 1:ncol(bb)) {              # iterate through each column (i.e. iterate through each column/row combo -- each entry in matrix) -->
<!--       if(bb[x,y] != 0) {                # if the matrix value does not equal 0 (which will produce a -inf value of i b/c divided by 0) -->
<!--         pxy <- bb[x,y] -->
<!--         px <- sumRow[x] -->
<!--         py <- sumCol[y] -->
<!--         i <- pxy * log(pxy / (px * py))   # calculate the mutual entropy for that item in the matrix -->
<!--         I <- I + i                        # add it to I, to produce an overall I for the matrix -->
<!--       } else {                            # if the matrix value = 0, print that the value equals 0 and don't do any calculations on it -->
<!--         #print(paste("matrix position", x, y, "is value 0" )) -->
<!--       } -->
<!--     } -->
<!--   } -->

<!--   # indivSpec = D Y|X = I / HX -->
<!--   # taskSpec = D X|Y = I / HY -->
<!--   # dolSymmetry = D X,Y = I / sqrt(HX * HY) -->

<!--   # calculate individual specialization: division of individuals into tasks -->
<!--   indivSpec <- I / HX -->
<!--   indivSpec -->
<!--   # calculate task specialization: division of tasks into inviduals -->
<!--   taskSpec <- I / HY -->
<!--   taskSpec -->
<!--   # calculate symmetric division of labor -->
<!--   symmDOL <- I / (sqrt(HX*HY)) -->
<!--   symmDOL -->
<!-- ``` -->