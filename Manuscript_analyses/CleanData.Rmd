---
title: "CleanData"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
  
### Load Packages
```{r}
library(tidyverse)
library(dplyr)
library(ggplot2)
```

We have to manually download each project file from Boris. Each project is a single aggregated data file and represents one nest (ex. QF01). To download Boris files into a directory for data cleaning, do the following: 
1) Open project file in BORIS
2) Observations -> Export Events -> Aggregated events
3) Press select all and then ok 
4) Select all subjects then all behaviors, press ok 
5) Group selected events into one file 
6) Save file as nest name eg. "QF01" as a .csv file in the BORISfiles directory 
*Note: all state events must be paired to export as an aggregated file 

### Load Data
```{r}

## create a list of all the files in the BORISfiles directory. these are all the files we want to import
## use pattern="*.csv", when getting files from google drive stream, there is an extra non-.csv file 

## use full.names=TRUE so that it reads in files using absolute file path 

list_filenames <- function(BORISfiles_path) {
  filenames <- list.files(BORISfiles_path,
                          pattern = "*.csv",
                          full.names = TRUE)
  return(filenames)
}


## use filenames below to enter your file path to the BORISfiles folder (can be found in GitHub repo)

## Erica's BORISfiles path
filenames <- list_filenames("/Users/ericasarro/Google\ Drive\ File\ Stream/My\ Drive/WoodardLab.shared/Projects/2018.Awesome.Summer.Experiments/Raw\ Data/BORISfiles")

## Kaleigh's BORISfiles path
#filenames <- list_filenames("/Users/kaleighfisher/Desktop/Boris_files")

## Lauren's BORISfiles path
#filenames <- list_filenames("")

head(filenames)

## loop over the files and import all of them. rename column names to remove "." and make shorter
all_data <- do.call(rbind, lapply(filenames, 
                                    function(i) {
                                      read.csv(i, header = TRUE,
                                               col.names = c("obsID",
                                                             "obsDate",
                                                             "filename",
                                                             "totalLen",
                                                             "fps",
                                                             "beeID",
                                                             "behav", 
                                                             "cat",
                                                             "mod",
                                                             "behavType",
                                                             "start",
                                                             "stop",
                                                             "dur",
                                                             "comStart",
                                                             "comStop"))
                     }
))

all_data

```






### Clean Data
split obsID column into its component parts to enable manipulation by camera/colony/time/date
```{r}
## convert columns to character to enable manipulation with strsplit() and subset(startsWith())
all_data$beeID <- as.character(all_data$beeID)
all_data$obsID <- as.character(all_data$obsID)

## split out obsID into camID, nestID, dateID and hourID (split based on the tab (\t) between elements)
## element 1 is camID
all_data$camID <- sapply(strsplit(all_data$obsID, "\t"), 
                          function(x){
                            x[1]
                            } )
## element 2 is nestID
all_data$nestID <- sapply(strsplit(all_data$obsID, "\t"), 
                          function(x){
                            x[2]
                            } )
## element 3 is dateID
all_data$dateID <- sapply(strsplit(all_data$obsID, "\t"), 
                          function(x){ 
                            x[3]
                            } )
## element 4 is hourID
all_data$hourID <- sapply(strsplit(all_data$obsID, "\t"), 
                          function(x){ 
                            x[4]
                            } )

head(all_data)
```
These files are updated as more video observations are done. Video observations are performed by many different observers. Check how many videos have been observed for each project for foraging and nest, at the two different time points. 


## look at how many observations we have for each nest for each BORIS download
```{r}

## Make a new column for nest type ie. NT or QT 
Queencharacter<-sapply(strsplit(all_data$nestID, ""), 
                          function(x){
                            x[1]
                          })
Numbercharacter<-sapply(strsplit(all_data$nestID, ""),
                        function(x){
                          x[2]
                        })    
                          
all_data$nestTYPE<-paste0(Queencharacter, Numbercharacter)

##remove first 30 rows because they are labelled incorrectly, Erica is fixing, will not be an issue next download 

data_sum<- all_data %>% select(camID, nestID, nestTYPE) %>% arrange(nestID, camID)
datasum<-data_sum[-c(1:30),]

sumsTOTAL<-datasum %>% group_by(nestID, camID) %>% summarise(Observations=n())
sumsTYPE<-datasum %>% group_by(nestTYPE, camID) %>% summarise(Observations=n())

##look at data we have so far based on each colony 

ggplot(sumsTOTAL, aes(x=nestID, y=Observations, fill=camID)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90))

## look at data we have so far based on each type of colony 
ggplot(sumsTYPE, aes(x=nestTYPE, y=Observations, fill=camID)) +
  geom_bar(stat="identity")+theme(axis.text.x=element_text(angle=90))



```


output df with each bee as a single row, behaviors as columns, count of frequency of each behavior per bee as values
```{r}
## collapse the dataframe to count the number of instances doing each behavior
## this outputs a new dataframe with columns nestID, beeID, nectarforaging, feedsbrood, pollenforaging 
#  (and any other behaviors recorded), with counts for each behavior in as values
## assumes that no two behaviors stopped at the exact same time. cannot handle duplicate stop times. 
#  not sure how to fix that...
count_data <- all_data
## add a column with value 1 that counts the behavioral observation 
count_data$count <- 1  
## condense data frame into relevant columns, each row is a single observation for an individual
count_data <- count_data %>%
  pivot_wider(id_cols = c("nestID", "beeID", "behav"), 
              names_from = stop, 
              values_from = count) 

## add column for sum of counts for each behav
count_data$totCount <- rowSums(count_data[4:ncol(count_data)], na.rm = TRUE)

## subset dataframe so that all is left is nestID, beeID, behav, and totCount
count_data <- count_data %>%
  select(nestID, beeID, behav, totCount)

## collapse dataframe so that each bee has one single row. cols = nestID, beeID, nectarforaging, *other behaviors
count_data <- count_data %>%
  pivot_wider(id_cols = c("nestID", "beeID"), 
              names_from = behav, 
              values_from = totCount)

## replace NA values with 0
count_data[is.na(count_data)] <- 0

## sum rows excluding first two (nestID and beeID) to see total number of behaviors carried out by each indiv
count_data$nBehavs <- rowSums(count_data[, 3:ncol(count_data)], na.rm = TRUE)

count_data

##Save dataframe as .csv so it can be used in other downstrea analyses 
write.csv(count_data, "count_data.csv")

```
output df with each bee as a single row, behaviors as columns, total duration of each behavior per bee as values
```{r}
## rename for clarity
time_data <- all_data

## only look at first 5 minutes of the watched video to standardize
time_data$start <- as.numeric(time_data$start)
time_data$stop <- as.numeric(time_data$stop)
time_data <- time_data[time_data$start <= 300, ]
## make behaviors stop at the end of 5 minutes
for (i in 1:nrow(time_data)) {
  if (time_data$stop[i] >300) {
    time_data$stop[i] <- 301 + runif(1)
  }
}

## recalculate duration data to account for stop time at 5 minutes
for (i in 1:nrow(time_data)) {
  time_data$dur[i] <- time_data$stop[i] - time_data$start[i]
}

## make duration of all brood feeding events 1 second duration to enable duration comparisons
for (i in 1:nrow(time_data)) {
  if (time_data$behav[i] == "feedsbrood") {
    time_data$dur[i] <- 1
  }
}

time_data

## collapse dataframe so that columns = nestID, beeID, behav, and stop times for each behavior. 
## values = duration of each behav
## produces error: Values in `dur` are not uniquely identified; output will contain list-cols. 
#  table showing values as <S3: vctrs_list_of> 
#  cannot have dupliate stop times
dur_data <- time_data %>%
  pivot_wider(id_cols = c("nestID", "beeID", "behav"), 
              names_from = stop, 
              values_from = dur, 
              names_repair = "minimal")

## add column for sum of duration for each behav
dur_data$totDur <- rowSums(dur_data[4:ncol(dur_data)], na.rm = TRUE)

## subset dataframe so that all is left is nestID, beeID, behav, and totDur
dur_data <- dur_data %>%
  select(nestID, beeID, behav, totDur)

## collapse dataframe so that each bee has one single row. cols = nestID, beeID, nectarforaging, *other behaviors
dur_data <- dur_data %>%
  pivot_wider(id_cols = c("nestID", "beeID"), 
              names_from = behav, 
              values_from = totDur)

## replace NA values with 0
dur_data[is.na(dur_data)] <- 0

dur_data

##Save dataframe as .csv so it can be used in other downstrea analyses 
write.csv(dur_data, "dur_data.csv")


```
output df with total duration of video watched per colony. columns = nestID and totalLen
```{r}
## select only the obsID, nestID, and totalLen columns
## subset to only the unique combinations (ie. remove duplicates so we don't count more time than we watched)
totalLen_data <- all_data %>%
  select(obsID, nestID, totalLen) %>%
  unique()
totalLen_data

## split out obsID into camID, dateID and hourID (split based on the tab (\t) between elements)
## element 1 is camID
totalLen_data$camID <- sapply(strsplit(totalLen_data$obsID, "\t"), 
                          function(x){
                            x[1]
                            } )
## element 3 is dateID
totalLen_data$dateID <- sapply(strsplit(totalLen_data$obsID, "\t"), 
                          function(x){ 
                            x[3]
                            } )
## element 4 is hourID
totalLen_data$hourID <- sapply(strsplit(totalLen_data$obsID, "\t"), 
                          function(x){ 
                            x[4]
                            } )
## combine date and hour into a single column called timeID
totalLen_data$timeID <- paste(totalLen_data$dateID, totalLen_data$hourID)
## subset the df to remove the obs, hour, and date columns
totalLen_data <- totalLen_data %>%
  select(camID, timeID, nestID, totalLen)
## make totalLen reflect only the first 5 minutes of the video, since we removed observations from after that point
totalLen_data$totalLen[totalLen_data$totalLen > 300] <- 300

totalLen_data


## for each nestID, remove nest videos that have a matching foraging video (i.e. watched twice)
#  sum totalLen for all the for videos + nest videos that do not have a matching for video

## create empty dataframe to put length into
camDur <- data.frame(nestID = NA,
                     forLen = NA,
                     nestLen = NA,
                     totalLen = NA)
## for each unique nest, subset the data to look at one nest at a time. then split out foraging and nest videos
## then remove nest videos that have a matching foraging video. then sum total length of remaining nest + for videos
## then add those values to the camDur dataframe
for (i in 1:length(unique(totalLen_data$nestID))) {
  sub_data <- subset(totalLen_data, nestID == unique(totalLen_data$nestID)[i])
  for_data <- subset(sub_data, sub_data$camID == "for")
  nest_data <- subset(sub_data, sub_data$camID == "nest")
  subNest_data <- nest_data %>%
      filter(! timeID %in% for_data$timeID)
  forSum <- sum(for_data$totalLen)
  totNestSum <- sum(nest_data$totalLen)
  subNestSum <- sum(subNest_data$totalLen)
  camSum <- forSum + subNestSum
  camDur <- rbind(camDur, c(sub_data$nestID[1], forSum, totNestSum, camSum))
}
## remove NA row initially created
camDur <- camDur[2:nrow(camDur),]

## make columns numeric so i can calculate ratio in next step
camDur$totalLen <- as.numeric(camDur$totalLen)
camDur$forLen <- as.numeric(camDur$forLen)
camDur$nestLen <- as.numeric(camDur$nestLen)

## make new column with the ratio of foraging to nest video length. should be ~1 for each colony
camDur$FNratio <- NA
for (i in 1:nrow(camDur)) {
  camDur$FNratio[i] <- camDur$forLen[i] / camDur$nestLen[i]
}

##Save dataframe as .csv so it can be used in other downstrea analyses 
write.csv(camDur, "camDur.csv")


## check to see how much video was watched for each nest and for each treatment
## must be equal + ratio must be 1 to compare
camDur
```







