---
title: "beeSpecialization"
output: pdf_document
fig.width: 6
fig.height: 15
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# load packages
```{r}
library(tidyverse)
library(dplyr)
library(ggplot2)
library(cluster) # clustering algorithms
library(factoextra)
library(vegan) 
library(lme4)
library(plotly)
```

# load data
```{r}
early_data <- read.csv("../Data/beeEarlyProp_data.csv")
late_data <- read.csv("../Data/beeLateProp_data.csv")
time_data <- rbind(early_data, late_data)
```

# NMDS on early and late beeProp data -- individual specialization over time, not including egg laying
```{r}
# Convert dataframes into matrices - two sets: one with combined foraging and one with separated foraging 
# Need to add a unique number to each worker in case there are repeats 

# rename initial count data frame
nmds_data <- time_data
# make NA values 0
nmds_data[is.na(nmds_data)] <- 0
nmds_data
numBees <- nrow(nmds_data)
# remove bees lacking any behaviors
nmds_data <-nmds_data[rowSums(nmds_data[(10:(ncol(nmds_data) - 1))]) > 0, ]
numDatapoints <- nrow(nmds_data)
print(paste( (numBees - numDatapoints), "bees were removed from the nmds data because they had 0 recorded behaviors", sep = " "))

# # add dummy variable to include lazy workers
# nmds_data$nothing <- 0.01

# remove bees with NA beeID
nmds_data <- nmds_data[!is.na(nmds_data$beeID),]
# remane beeID to combine nestID and beeID to account for duplicates
nmds_data$beeID <- paste0(nmds_data$nestID, nmds_data$beeID)
nmds_data

# make matrix of only behavior counts for all timepoints
nmds_all <- as.matrix(nmds_data[,c("feedsbrood", "nectarforaging", "pollenforaging")]) # not inlcuding egg laying

nmds_all

# Run NMDS with euclidean distance
nmds_all <- metaMDS(nmds_all)
plot(nmds_all)

# Get coordinates to graph it 
# Gets NMDS info for each individual
data.scores <- as.data.frame(scores(nmds_all))
data.scores$caste <- nmds_data$caste
data.scores$nestTYPE <-nmds_data$nestTYPE
data.scores$timepoint <-nmds_data$timepoint
data.scores$beeID <-nmds_data$beeID
data.scores$nestID <- nmds_data$nestID
data.scores$nBees <- nmds_data$nBees
data.scores$nWork <- nmds_data$nWork
data.scores$queen <- nmds_data$queen
data.scores

# Gets NMDS info for each behavior
behav.scores<-as.data.frame(scores(nmds_all, "species"))
behav.scores$behav<-rownames(behav.scores)
behav.scores

# Plot it using ggplot
ggplot() + 
  geom_text(data=behav.scores, aes(x=NMDS1, y=NMDS2, label=behav)) +
  geom_point(data=data.scores, aes(x=NMDS1, y=NMDS2, shape=caste, color = timepoint), size = 2, position = position_jitter(width=0.08, height=0.08)) + 
  scale_shape_manual(values = c(21, 16)) +
  # geom_line(data=data.scores, aes(x=NMDS1, NMDS2, fill = beeID), size = 0.15, position = position_jitter(width = 0, height = 0),
  #          arrow = arrow(length=unit(0.25,"cm"), type = "open")) +
  coord_cartesian(xlim=c(-1.5, 1.5), ylim=c(-1.5, 2))
ggsave("../figures/nmds_time.jpg")

# plot it split out by nestID
p <- ggplot() + 
  geom_text(data=behav.scores, aes(x=NMDS1, y=NMDS2, label=behav), size = 2) +
  geom_point(data=data.scores, aes(x=NMDS1, y=NMDS2, shape=caste, fill = timepoint), position = position_jitter(width=0.05, height=0.05)) + 
  scale_color_manual(values = c("red", "blue")) +
  # geom_line(data=data.scores, aes(x=NMDS1, NMDS2, fill = beeID), size = 0.15,
  #          arrow = arrow(length=unit(0.15,"cm"), type = "open")) +
  coord_cartesian(xlim=c(-2, 2), ylim=c(-2, 2))
plots = data.scores %>%
    do(plots = p %+% . + facet_wrap(~nestID))
plots$plots

# plot split out by nestTYPE
p <- ggplot() + 
  geom_text(data=behav.scores, aes(x=NMDS1, y=NMDS2, label=behav), size = 3) +
  geom_point(data=data.scores, aes(x=NMDS1, y=NMDS2, shape=caste, fill = timepoint), size = 2, position = position_jitter(width=0.05, height=0.05)) + 
  scale_color_manual(values = c("red", "blue")) +
  # geom_line(data=data.scores, aes(x=NMDS1, NMDS2, fill = beeID), size = 0.15,
  #          arrow = arrow(length=unit(0.15,"cm"), type = "open")) +
  coord_cartesian(xlim=c(-2, 2), ylim=c(-2, 2))
plots = data.scores %>%
    do(plots = p %+% . + facet_wrap(~nestTYPE))
plots$plots
```

# find avg distance between early and late timepoints
```{r}
# calculate total distance between early and late for each bee

#first add empty columns to input data into
data.scores$totalDist <- NA
data.scores$nmds1dist <- NA
data.scores$nmds2dist <- NA

# then calculate distances for each bee
for (i in 1:nrow(data.scores)) {                                                                # for each row in the dataset
  if(data.scores$timepoint[i] == "late") {                                                      # look at the the late bees only
    for (j in 1:nrow(data.scores)) {                                                            # then iterate back through the dataset
      if(data.scores$timepoint[j] == "early" & data.scores$beeID[j] == data.scores$beeID[i]) {  # and find the early entry with the same bee ID
        x1 <- data.scores$NMDS1[j]                                                              # define the nmds coordinates as x,y for early (j) and late (i)
        y1 <- data.scores$NMDS2[j]
        x2 <- data.scores$NMDS1[i]
        y2 <- data.scores$NMDS2[i]
        totalDistance <- sqrt( (x2 - x1)^2 + (y2 - y1)^2 )                                      # formula for distance between two points
        data.scores$totalDist[i] <- totalDistance                                               # fill in the dataframe with distances between early and late
        data.scores$nmds1dist[i] <- x2 - x1
        data.scores$nmds2dist[i] <- y2 - y1
        # print(paste("late data.scores$nmds1 from line", i, "=", data.scores$NMDS1[i],
        #             " //  early data.scores$nmds1 from line", j, "=", data.scores$NMDS1[j], sep = " "))
      }
    }
  }
}

data.scores
ggplot(data.scores, aes(totalDist, fill = nestTYPE)) + geom_density(alpha = 0.3)
ggsave("../figures/totalDistance_time.jpg")
ggplot(data.scores, aes(nmds1dist, fill = nestTYPE)) + geom_density(alpha = 0.3)
ggsave("../figures/nmds1Distance_time.jpg")
ggplot(data.scores, aes(nmds2dist, fill = nestTYPE)) + geom_density(alpha = 0.3)
ggsave("../figures/nmds2Distance_time.jpg")

# summarize change in total distance
distTotal <- ddply(data.scores, c("nestTYPE", "caste"),
                summarise,
                mean = mean(totalDist, na.rm = TRUE),
                sd = sd(totalDist, na.rm = TRUE),
                sem = sd(totalDist, na.rm = TRUE)/sqrt(length(!is.na(totalDist))))
distTotal

# summarize change in NMDS1 (-brood feeding VS + foraging)
distNMDS1 <- ddply(data.scores, c("nestTYPE", "caste"),
                summarise,
                mean = mean(nmds1dist, na.rm = TRUE),
                sd = sd(nmds1dist, na.rm = TRUE),
                sem = sd(nmds1dist, na.rm = TRUE)/sqrt(length(!is.na(NMDS1))))
distNMDS1

# summarize change in NMDS2 (-brood feeding & nectar foraging VS +pollen foraging)
distNMDS2 <- ddply(data.scores, c("nestTYPE", "caste"),
                summarise,
                mean = mean(nmds2dist, na.rm = TRUE),
                sd = sd(nmds2dist, na.rm = TRUE),
                sem = sd(nmds2dist, na.rm = TRUE)/sqrt(length(!is.na(NMDS2))))
distNMDS2
```

# glmm on NMDS coordinates across time, nestTYPE, and caste
could also do queen, nBees, nWork instead of or in addition to nestTYPE
```{r}

# rename for analyses
nmdsData <- data.scores

library(car)
library(MASS)

############ CAN'T FIGURE OUT CORRECT DISTRIBUTION. ANALYSES ARE INVALID UNTIL THIS IS RESOLVED ############
# normal distribution
qqp(nmdsData$NMDS1, "norm")

# lnorm means lognormal
qqp(nmdsData$NMDS1, "lnorm")

# gamma must be positive numbers
# gamma <- fitdistr(nmdsData$NMDS1, "gamma")
# qqp(nmdsData$NMDS1, "gamma", shape = gamma$estimate[[1]], rate = gamma$estimate[[2]])

# run model on NMDS1: egg laying VS foraging (brood feeding in between)
library(lme4)
nmds1 <- glmer(NMDS1 ~ nestTYPE + caste + timepoint + (1|beeID) + (1|nestID),
              data = nmdsData)

# p values
library(sjPlot)
tab_model(nmds1)

# run model on NMDS2: brood feeding VS egg laying + foraging
library(lme4)
nmds2 <- glmer(NMDS2 ~ nestTYPE + caste + timepoint + (1|beeID) + (1|nestID),
              data = nmdsData)

# p values
library(sjPlot)
tab_model(nmds2)
```

# repeatability analyses on NMDS coordinates (same as ICC intra-class correlation)
https://cran.r-project.org/web/packages/rptR/vignettes/rptR.html
```{r}
library(rptR)

# rename
countScores <- data.scores
countScores

# take a look at distribution of scores
# both of these are very irregularly distributed
ggplot(countScores, aes(NMDS1, fill = timepoint)) + geom_density(alpha = 0.2)
ggplot(countScores, aes(NMDS2, fill = timepoint)) + geom_density(alpha = 0.2)

# run repeatibility estimation using lmm method

############### DATA IS NOT GAUSSIAN -- NEED TO ADDRESS THIS ####################

# NMDS1: low = egg laying, high = foraging, mid = brood feeding
rep1 <- rpt(NMDS1 ~ (1|beeID),
            grname = "beeID", data = countScores, datatype = "Gaussian", nboot = 1000, npermut = 0)
summary(rep1)
print(rep1)
plot(rep1, cex.main = 1)

rep1Exp <- rpt(NMDS1 ~ nestTYPE + caste + (1|beeID),
               grname = "beeID", data = countScores, datatype = "Gaussian", nboot = 1000, npermut = 0)
print(rep1Exp)
summary(rep1Exp)
plot(rep1Exp, cex.main = 1)

# NMDS2: low = brood feeding, mid = egg laying + foraging
rep2Exp <- rpt(NMDS2 ~ nestTYPE + caste + (1|beeID),
               grname = "beeID", data = countScores, datatype = "Gaussian", nboot = 1000, npermut = 0)
print(rep2Exp)
summary(rep2Exp)
plot(rep2Exp, cex.main = 1)
```

# division of labor index

this yeilds a DOL index between 0 (no division) and 1 (complete division) for each bee
issues = does not describe which behavior a bee is specializing on. eg specializing entirely on nectar foraging and specializing entirely on egg laying both yield same number

https://www.journals.uchicago.edu/doi/pdfplus/10.1086/424968

https://watermark.silverchair.com/arn018.pdf?token=AQECAHi208BE49Ooan9kkhW_Ercy7Dm3ZL_9Cf3qfKAc485ysgAAArAwggKsBgkqhkiG9w0BBwagggKdMIICmQIBADCCApIGCSqGSIb3DQEHATAeBglghkgBZQMEAS4wEQQM0mGmfTsnhsoK-Y_uAgEQgIICY-aMO-F9oEaBklacEnjaMSJCFsghtzm6jKWajfSFUi1WmnoBV8zpdiY0ztkvgG8k3Vi7Vaby0gWJGaGto13hllldFKZg-C-TNDdv7yJt81TrpV3M_ooNiYcjJq92Y6ObRoYrlxUJfi77RK3_cDBJ9Ag8JjhA03UWwerFU5FE71P3-7ptplP8rI8QYpXNZdtZbyoYrEN80JYxjgt1o2zAFGvRF3r-_1ExlhdpKr5k0OxGqlCa11kFUpBAjFpMun5qR6JL-8bkcbRIAmNnBBduCg1CSXoUBpx18ouZnNJu_v9OQodZ7hBYPfu62SRjQ9TNEZqadgMAt0mMreuH60st2TagmvXlqLPPyoIu7-0ZBvdD6nvcmJ-miBhUw7Z6vCia1KhrvpvKvhZem2N3zsGsNSp_UFSvVSwtNeHdguMtId5zSe70mWdbDBfTJAsag1sf5YAeCd0XwDSRsfarD2aAYlmQ0ARCd8qC8yxdUlKqohn3Xsh70IBQL1jc_l32k1Q7fiplJiD6hQ69Yge2M961fZML1G5vIQa5DxBgThNYg5GyQxXnyzCFHWJIDhqKwHtWgiWQgbA63qMK2IHNicOSw8JhrpaWlWgEUX8NiaiF7ICzNxFh2pcdL-hnazO1StB1anJtiTo-RHgeLji4E9qYFpT3DYcw6ptUAxjLUql3d1M0aByMRS0EhoZCoUfER_8iiUicTNGUi4w85O5mm55B4vRheg5XGSlby26I0_H9zOtK-eQ3PmKHB4DyPvd-Ch24hp4FBEFJM4pI_sCZJc8_p8JuYOonUk_M3aqNLQKGznrL_xu2
```{r}
# start with matrix where each row is an individual, and each column is a behavior
# transform the data so that all values sum to 1

# rename and split out early and late timepoints
alldol <- count_data 
earlydol <- count_data[count_data$timepoint == "early", ]
latedol <- count_data[count_data$timepoint == "late", ]

# CALCULATE FOR ALL DATA

# remove bees without behaviors
alldol <- alldol[alldol$nBehavs > 0, ]
# reformat to sum to 1
totBehavs <- alldol$nBehavs[nrow(alldol)]
alldol$feedsbrood <- alldol$feedsbrood / totBehavs
alldol$nectarforaging <- alldol$nectarforaging / totBehavs
alldol$pollenforaging <- alldol$pollenforaging / totBehavs
alldol$egglaying <- alldol$egglaying / totBehavs
# reformat as matrix with only behavior info
alldol_M <- as.matrix(alldol[,c("feedsbrood", "nectarforaging", "pollenforaging", "egglaying")])

# calculate shannon's index for distributions of individuals across tasks
shannon <- diversity(alldol_M, index = "shannon")
hist(shannon)
# add shannon index into dataframe with bee info
alldol <- cbind(alldol, shannon)

###################### DON'T YET KNOW HOW TO CALCLUATE MUTUAL ENTROPY OF MATRIX - THIS IS INCORRECT ######################

# calculate mutal entropy for entire matrix
# this function returns an estimate of the Shannon entropy -- cannot find "mutual entropy"
# https://cran.r-project.org/web/packages/entropy/entropy.pdf
library(entropy)
# using maximum likelihood method here, there are many other options
mutEntropy <- entropy(alldol_M, method = "ML")
mutEntropy
# calcluate dol index (mutual entropy / H) for each bee and add it to the dataframe -- should be an index between 0-1
alldol$dol <- mutEntropy / alldol$shannon
alldol 
```

# glmm on H across time, nestTYPE, and caste
```{r}
# add a small value to data so that values > 0
alldol$H1 <- alldol$H + 0.01

library(car)
library(MASS)

######################### CAN'T FIGURE OUT DISTRIBUTION. ANALYSES ARE INVALID UNTIL THIS IS RESOLVED ########################

# normal distribution
qqp(alldol$H1, "norm")

# lnorm means lognormal
qqp(alldol$H1, "lnorm")

# gamma must be positive numbers
gamma <- fitdistr(alldol$H1, "gamma")
qqp(alldol$H1, "gamma", shape = gamma$estimate[[1]], rate = gamma$estimate[[2]])

# run model
library(lme4)
dol1 <- glmer(H ~ nestTYPE + caste + timepoint + (1|beeID),
              data = alldol)

# p values
library(sjPlot)
tab_model(dol1)
```








































