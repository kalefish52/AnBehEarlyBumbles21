---
title: "Kaleigh Fisher Project Code - Task Analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# load packages 
library(tidyverse)
library(vegan)
library(scatterplot3d)
library(ggplot2)
library(scatterplot3d)

```

Read in count_data from CleanData.Rmd and make it into a matrix that can be used in clusetering analyses 
```{r}
count_data<-read.csv("/Users/kaleighfisher/Dropbox/SarroFisher/Manuscript_analyses/count_data.csv")
head(count_data)

count_data<- count_data %>% arrange(nestID) ## See if any observations are mislabelled 

count_data<- count_data[-c(1:12),] ## Remove observations that are mislabelled 

## Change beeID so that it just says worker number and make each worker unique so that it can be used as a row name in the matrix 

#Changes worker and queen labels to Worker## or Queen## using regular expressions
count_data$beeID<-gsub("\\(", "", as.character(count_data$beeID)) #Removes first (
count_data$beeID<-gsub("\\)", "", count_data$beeID) #Removes last )
count_data$beeID<-gsub("[ ][0-9][ ]", "", count_data$beeID) #Removes Boris number/spaces for workers
count_data$beeID<-gsub("[ ]", "", count_data$beeID) # Removes space between Queen and number 

#Add a unique number and paste into beeID; 
#can then be row names (addresses non-unique elements "unknown")
count_data$beeID<-paste(count_data$beeID, 1:length(count_data$beeID), sep="_")


##Need to make element into a character in order for strsplit to work 
count_data$nestID<- as.character(count_data$nestID)

## Add colony type column ## Make a new column for nest type ie. NT or QT 
Queencharacter<-sapply(strsplit(count_data$nestID, ""), 
                          function(x){
                            x[1]
                          })
Numbercharacter<-sapply(strsplit(count_data$nestID, ""),
                        function(x){
                          x[2]
                        })    
count_data$nestTYPE<-paste0(Queencharacter, Numbercharacter)


## Make matrices for each colony type for behaviors of interest 
#Separates pollen and nectar foraging and does not include egg laying 

NF.matrix <- count_data %>% filter(nestTYPE == "NF") %>% select(beeID, feedsbrood, pollenforaging, nectarforaging) %>% remove_rownames %>% column_to_rownames(var="beeID")
NT.matrix <- count_data %>% filter(nestTYPE == "NT") %>% select(beeID, feedsbrood, pollenforaging, nectarforaging) %>% remove_rownames %>% column_to_rownames(var="beeID")
QF.matrix <- count_data %>% filter(nestTYPE == "QF") %>% select(beeID, feedsbrood, pollenforaging, nectarforaging) %>% remove_rownames %>% column_to_rownames(var="beeID")
QT.matrix <- count_data %>% filter(nestTYPE == "QT") %>% select(beeID, feedsbrood, pollenforaging, nectarforaging) %>% remove_rownames %>% column_to_rownames(var="beeID")
```

Now try to compare different ordination analyses: PCoA, NMDS and K means 

```{r} 
#PCoA Analysis 

##Step One: Create a distance matrix 

#Samples should be rows and each gene should be a column (t=transpose) 
distance.matrix<-dist(scale((NF.matrix), center=TRUE, scale=TRUE), method="euclidean")


##Step Two: Perform multi-dimensional scaling on the distance matrix using the cmdscale() funciton 
mds.stuff<-cmdscale(distance.matrix, eig=TRUE, x.ret=TRUE)
# returns eigen values to calculate how much variation in the distance matrix 
# each axis in the final MDS plot accounts for. 

##Step Three: Calculate amount of variation each axis accounts for using eigen values
mds.var.per<-round(mds.stuff$eig/sum(mds.stuff$eig)*100, 1)
mds.var.per
## Can make a graph here 
barplot(mds.var.per, xlab="Variation Axes", ylab="Percentage of Variation")


##Step Four: Format data for ggplot
mds.values<-mds.stuff$points
mds.data<-data.frame(Sample=rownames(mds.values), 
                     x=mds.values[,1],
                     y=mds.values[,2])

ggplot(data=mds.data, aes(x=x, y=y, label=Sample))+ 
  geom_text()+
  theme_bw()
  


##Step Five: make graph 

###plot mds.data using 


```

