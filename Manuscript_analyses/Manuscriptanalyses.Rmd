---
title: "Manuscript Analyses for DOL Paper" 
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Load Packages
```{r}
library(tidyverse)
library(dplyr)
library(ggplot2)
library(cluster) # clustering algorithms
library(factoextra)
library(vegan) 
library(lme4)
library(plotly)
```

# Manuscript Analyses
## Data manipulation
Add a column for group type (NT, QT, NF, QF) and a column with total foraging (pollen + nectar foraging)
```{r}
# Combine pollen and nectar foraging (don't have that many for each) and then remove columns other than egg laying, brood feeding and foraging 

dataSTATS <- read.csv("../Data/countsanalysis.csv")
dataSTATS

##add column with total foraging 
allforaging<-dataSTATS %>% select(!X)  %>% pivot_wider(names_from=behav, values_from=totCount) %>% replace(is.na(.), 0) %>% select(!c(fillshoneypot, other, end, broodmanipulate, offbrood, incubate, waxmanipulate, laysegg, eatsbrood))


forage_polnec<-allforaging %>% pivot_longer(cols=c(feedsbrood, nectarforaging, pollenforaging, egglaying), names_to="behav", values_to="Count") 

combforaging<-allforaging %>% mutate(combfor=nectarforaging+pollenforaging) %>% select(!c(nectarforaging, pollenforaging))

forag_comb<-combforaging %>% pivot_longer(cols=c(feedsbrood, combfor, egglaying), names_to="behav", values_to="Count")

forag_comb
#test

#Make a nest type column for separate pollen and nectar foraging 
Letteronep<-sapply(strsplit(forage_polnec$nestID, ""), 
                          function(x){
                            x[1]
                          })
Lettertwop<-sapply(strsplit(forage_polnec$nestID, ""),
                        function(x){
                          x[2]
                        })   
forage_polnec$nestTYPE<-paste0(Letteronep, Lettertwop)



#Make a nest type column for combined foraging
Letterone<-sapply(strsplit(forag_comb$nestID, ""), 
                          function(x){
                            x[1]
                          })
Lettertwo<-sapply(strsplit(forag_comb$nestID, ""),
                        function(x){
                          x[2]
                        })   
forag_comb$nestTYPE<-paste0(Letterone, Lettertwo)

#Use forage_polnect to analyze pollen and nectar foraging separately 
#Use forage_comb to analyze all foraging - may have to do this so we have enough 


```

## Question 2: Are there patterns of division of labor? NMDS Analysis
```{r}
# Convert dataframes into matrices - two sets one with combined foraging and one with separated foraging 
# Convert dataframe so that each worker is a row 
# Need to add a unique number to each worker in case there are repeats 

forag_comb$rowID<-paste(forag_comb$beeID, 1:length(forag_comb$beeID), sep="_")
head(forag_comb)

#modify dataframe so that behaviors are columns 
nmdsALL<-forag_comb %>% select(!beeID) %>% pivot_wider(names_from=behav, values_from=Count) %>% replace(is.na(.), 0)
head(nmdsALL)

#Choose only behavior columns to run nmds
ALL=nmdsALL[,6:ncol(nmdsALL)]
#Make dataframe into a matrix
m_ALL=as.matrix(ALL)

#Set seed so that random number draw is the same
set.seed(123)

#Run NMDS with euclidean distance
ALL.mds<-metaMDS(m_ALL, distance="euclidean", k=3, trymax=50, autotransform=FALSE, wassccores=TRUE, noshare=FALSE)
plot(ALL.mds)
##Get coordinates to graph it 
#Gets NMDS info for each individual
data.scores<-as.data.frame(scores(QT.mds))
data.scores$behav<-rownames(data.scores)
data.scores$timepoint<-nmdsQT$timepoint
head(data.scores)

#Gets NMDS info for each behavior
behav.scores<-as.data.frame(scores(QT.mds, "species"))
behav.scores$behav<-rownames(behav.scores)
head(behav.scores)

## Plot it using ggplot
ggplot() + geom_text(data=behav.scores, aes(x=NMDS1, y=NMDS2, label=behav)) +
  geom_point(data=data.scores, aes(x=NMDS1, y=NMDS2, colour=timepoint)) + 
  coord_cartesian(xlim=c(-1, 1)) + geom_jitter(width=0.1, height=0.1)

```


```{r}

# Matrices total for - Combined foraging, egg laying, brood feeding
NF.matrix <- forag_comb %>% filter(nestTYPE == "NF") %>% column_to_rownames(var="rowID") %>% as.matrix()

NT.matrix <- forag_comb %>% filter(nestTYPE == "NT") %>% column_to_rownames(var="rowID") %>% as.matrix()

QF.matrix <- forag_comb %>% filter(nestTYPE == "QF") %>% column_to_rownames(var="rowID") %>% as.matrix()

QT.matrix <- forag_comb %>% filter(nestTYPE == "QT") %>% column_to_rownames(var="rowID") %>% as.matrix()

All.matrix<-forag_comb %>% column_to_rownames(var="rowID") %>% as.matrix()

#Make a list of matrices so we can use a loop or fancy lapply to do stats 
Matrices_Totalfor<- list()
Matrices_Totalfor[[1]]<-NF.matrix
Matrices_Totalfor[[2]]<-NT.matrix
Matrices_Totalfor[[3]]<-QF.matrix
Matrices_Totalfor[[4]]<-QT.matrix
Matrices_Totalfor[[5]]<-All.matrix

head(NF.matrix)
```


```{r}
# Clustering analysis one - Kmeans 
# K Means Cluster Analyses -- determine whether points cluster into two or more groups






# Clustering analysis two - NMDS 
## Need to remove rows (row=individual) that has 0 for all observations - maybe we want to change this someway so we can see clustering of individuals doing nothing 


NF.matrix <- NF.matrix[rowSums(NF.matrix)!=0, ] 
NMDS_NF<-metaMDS(NF.matrix, k=2)
stressplot(NMDS_NF)
ordiplot(NMDS_NF, display="species")

plot(NMDS_NF)
ordiplot(NMDS_NF, type="n")
orditorp(NMDS_NF,display="sites", col="red", air=0.001)
orditorp(NMDS_NF, display="species", cex=1.25, air=0.01)


# Clustering analysis three - Principle coordinate analysis (MDS)
#samples should be rows in the matrix - center and scale the measurements for each behavior
distance.matrixNF<-dist(scale((NF.matrix), center=TRUE, scale=TRUE), method="euclidean")
# use eigen values to calculate variation in the distance matrix is from each axis in the final plot
mds.stuffNF<-cmdscale(distance.matrixNF, eig=TRUE, x.ret=TRUE) 
#Calculate the amount of variation each axis in the MDS plot accounts for using eigen values
mds.var.per <- round(mds.stuffNF$eig/sum(mds.stuffNF$eig)*100, 1)
mds.var.per
mds.values<-mds.stuffNF$points
mds.data<-data.frame(Sample=rownames(mds.values), 
                     x=mds.values[,1],
                     y=mds.values[,2])
mds.data

#Plot it
ggplot(data=mds.data, aes(x=x, y=y, label=Sample)) +
  geom_text()+
  theme_bw()+
  xlab(paste("MDS1-", mds.var.per[1], "%", sep="")) +
  ylab(paste("MDS2-", mds.var.per[2], "%", sep="")) +
  ggtitle("MDS plot using Euclidean Distance")




```


