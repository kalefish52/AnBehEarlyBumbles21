---
title: "beeSpecialization"
author: "ES"
date: "7/16/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# load packages
```{r}
library(tidyverse)
library(dplyr)
library(ggplot2)
library(cluster) # clustering algorithms
library(factoextra)
library(vegan) 
library(lme4)
library(plotly)
```

# load data
```{r}
bee_data <- read.csv("../Data/beeProp_data.csv")
bee_data
```

# NMDS on pooled beeProp data -- overall individual specialization
```{r}
# Convert dataframes into matrices - two sets: one with combined foraging and one with separated foraging 
# Need to add a unique number to each worker in case there are repeats 

# rename initial count data frame
nmds_data <- beeProp_data
# make NA values 0
nmds_data[is.na(nmds_data)] <- 0

numBees <- nrow(nmds_data)
# remove bees lacking any behaviors
nmds_data <-nmds_data[rowSums(nmds_data[(8:(ncol(nmds_data) - 1))]) > 0, ]
numDatapoints <- nrow(nmds_data)
print(paste( (numBees - numDatapoints), "bees were removed from the nmds data because they had 0 recorded behaviors", sep = " "))

# # add dummy variable to include lazy workers
# nmds_data$nothing <- 0.01

# remove bees with NA beeID
nmds_data <- nmds_data[!is.na(nmds_data$beeID),]
# remane beeID to combine nestID and beeID to account for duplicates
nmds_data$beeID <- paste0(nmds_data$nestID, nmds_data$beeID)
nmds_data

# make matrix of only behavior counts for all timepoints
nmds_all <- as.matrix(nmds_data[,c("feedsbrood", "nectarforaging", "pollenforaging", "egglaying")])

nmds_all

# Run NMDS with euclidean distance
nmds_all <- metaMDS(nmds_all)
plot(nmds_all)

# Get coordinates to graph it 
# Gets NMDS info for each individual
data.scores <- as.data.frame(scores(nmds_all))
data.scores$caste <- nmds_data$caste
data.scores$nestTYPE <-nmds_data$nestTYPE
data.scores$timepoint <-nmds_data$timepoint
data.scores$beeID <-nmds_data$beeID
data.scores$nestID <- nmds_data$nestID
data.scores$nBees <- nmds_data$nBees
data.scores$nWork <- nmds_data$nWork
data.scores$queen <- nmds_data$queen
data.scores

# Gets NMDS info for each behavior
behav.scores<-as.data.frame(scores(nmds_all, "species"))
behav.scores$behav<-rownames(behav.scores)
behav.scores

# Plot it using ggplot
ggplot() + 
  geom_text(data=behav.scores, aes(x=NMDS1, y=NMDS2, label=behav)) +
  geom_point(data=data.scores, aes(x=NMDS1, y=NMDS2, shape=caste), size = 2, position = position_jitter(width=0.08, height=0.08)) + 
  scale_shape_manual(values = c(21, 16)) +
  geom_line(data=data.scores, aes(x=NMDS1, NMDS2, fill = beeID), size = 0.15, position = position_jitter(width = 0, height = 0),
           arrow = arrow(length=unit(0.25,"cm"), type = "open")) +
  coord_cartesian(xlim=c(-1.5, 1.5), ylim=c(-1.5, 2))

# plot it split out by nestID
p <- ggplot() + 
  geom_text(data=behav.scores, aes(x=NMDS1, y=NMDS2, label=behav), size = 2) +
  geom_point(data=data.scores, aes(x=NMDS1, y=NMDS2, shape=caste), position = position_jitter(width=0.05, height=0.05)) + 
  scale_color_manual(values = c("red", "blue")) +
  # geom_line(data=data.scores, aes(x=NMDS1, NMDS2, fill = beeID), size = 0.15,
  #          arrow = arrow(length=unit(0.15,"cm"), type = "open")) +
  coord_cartesian(xlim=c(-2, 2), ylim=c(-2, 2))
plots = data.scores %>%
    do(plots = p %+% . + facet_wrap(~nestID))
plots$plots

# plot split out by nestTYPE
p <- ggplot() + 
  geom_text(data=behav.scores, aes(x=NMDS1, y=NMDS2, label=behav), size = 3) +
  geom_point(data=data.scores, aes(x=NMDS1, y=NMDS2, shape=caste), size = 2, position = position_jitter(width=0.05, height=0.05)) + 
  scale_color_manual(values = c("red", "blue")) +
  # geom_line(data=data.scores, aes(x=NMDS1, NMDS2, fill = beeID), size = 0.15,
  #          arrow = arrow(length=unit(0.15,"cm"), type = "open")) +
  coord_cartesian(xlim=c(-2, 2), ylim=c(-2, 2))
plots = data.scores %>%
    do(plots = p %+% . + facet_wrap(~nestTYPE))
plots$plots
```
```{r}
queen.scores <- data.scores[data.scores$caste == "queen", ]
worker.scores <- data.scores[data.scores$caste == "worker", ]

ggplot(data.scores, aes(NMDS1, fill = nestTYPE)) + geom_density(alpha = 0.3)
ggplot(data.scores, aes(NMDS2, fill = nestTYPE)) + geom_density(alpha = 0.3)

ggplot(queen.scores, aes(NMDS1, fill = nestTYPE)) + geom_density(alpha = 0.3)
ggplot(queen.scores, aes(NMDS2, fill = nestTYPE)) + geom_density(alpha = 0.3)

ggplot(worker.scores, aes(NMDS1, fill = nestTYPE)) + geom_density(alpha = 0.3)
ggplot(worker.scores, aes(NMDS2, fill = nestTYPE)) + geom_density(alpha = 0.3)
```

# glmm on NMDS coordinates in response to nestTYPE, number of bees, and caste
```{r}

# rename for analyses
nmdsData <- data.scores

library(car)
library(MASS)
library(sjPlot)
library(lme4)

nmdsData

############ CAN'T FIGURE OUT CORRECT DISTRIBUTION. ANALYSES ARE INVALID UNTIL THIS IS RESOLVED ############
# normal distribution
qqp(nmdsData$NMDS1, "norm")

# lnorm means lognormal
qqp(nmdsData$NMDS1, "lnorm")

# gamma must be positive numbers
# gamma <- fitdistr(nmdsData$NMDS1, "gamma")
# qqp(nmdsData$NMDS1, "gamma", shape = gamma$estimate[[1]], rate = gamma$estimate[[2]])

# run model on NMDS1: egg laying VS foraging (brood feeding in between)
nmds1 <- glmer(NMDS1 ~ nBees + queen + (1|nestID),
              data = nmdsData)
# p values
tab_model(nmds1)

# run model on NMDS2: brood feeding VS egg laying + foraging
nmds2 <- glmer(NMDS2 ~ nBees + queen + (1|nestID),
              data = nmdsData)
# p values
tab_model(nmds2)
```

# division of labor index

this yeilds a DOL index between 0 (no division) and 1 (complete division) for each bee
issues = does not describe which behavior a bee is specializing on. eg specializing entirely on nectar foraging and specializing entirely on egg laying both yield same number

https://www.journals.uchicago.edu/doi/pdfplus/10.1086/424968

https://watermark.silverchair.com/arn018.pdf?token=AQECAHi208BE49Ooan9kkhW_Ercy7Dm3ZL_9Cf3qfKAc485ysgAAArAwggKsBgkqhkiG9w0BBwagggKdMIICmQIBADCCApIGCSqGSIb3DQEHATAeBglghkgBZQMEAS4wEQQM0mGmfTsnhsoK-Y_uAgEQgIICY-aMO-F9oEaBklacEnjaMSJCFsghtzm6jKWajfSFUi1WmnoBV8zpdiY0ztkvgG8k3Vi7Vaby0gWJGaGto13hllldFKZg-C-TNDdv7yJt81TrpV3M_ooNiYcjJq92Y6ObRoYrlxUJfi77RK3_cDBJ9Ag8JjhA03UWwerFU5FE71P3-7ptplP8rI8QYpXNZdtZbyoYrEN80JYxjgt1o2zAFGvRF3r-_1ExlhdpKr5k0OxGqlCa11kFUpBAjFpMun5qR6JL-8bkcbRIAmNnBBduCg1CSXoUBpx18ouZnNJu_v9OQodZ7hBYPfu62SRjQ9TNEZqadgMAt0mMreuH60st2TagmvXlqLPPyoIu7-0ZBvdD6nvcmJ-miBhUw7Z6vCia1KhrvpvKvhZem2N3zsGsNSp_UFSvVSwtNeHdguMtId5zSe70mWdbDBfTJAsag1sf5YAeCd0XwDSRsfarD2aAYlmQ0ARCd8qC8yxdUlKqohn3Xsh70IBQL1jc_l32k1Q7fiplJiD6hQ69Yge2M961fZML1G5vIQa5DxBgThNYg5GyQxXnyzCFHWJIDhqKwHtWgiWQgbA63qMK2IHNicOSw8JhrpaWlWgEUX8NiaiF7ICzNxFh2pcdL-hnazO1StB1anJtiTo-RHgeLji4E9qYFpT3DYcw6ptUAxjLUql3d1M0aByMRS0EhoZCoUfER_8iiUicTNGUi4w85O5mm55B4vRheg5XGSlby26I0_H9zOtK-eQ3PmKHB4DyPvd-Ch24hp4FBEFJM4pI_sCZJc8_p8JuYOonUk_M3aqNLQKGznrL_xu2
```{r}
# start with matrix where each row is an individual, and each column is a behavior
# transform the data so that all values sum to 1

# rename 
alldol <- count_data 

# CALCULATE FOR ALL DATA

# remove bees without behaviors
alldol <- alldol[alldol$nBehavs > 0, ]
# reformat to sum to 1
totBehavs <- alldol$nBehavs[nrow(alldol)]
alldol$feedsbrood <- alldol$feedsbrood / totBehavs
alldol$nectarforaging <- alldol$nectarforaging / totBehavs
alldol$pollenforaging <- alldol$pollenforaging / totBehavs
alldol$egglaying <- alldol$egglaying / totBehavs
# reformat as matrix with only behavior info
alldol_M <- as.matrix(alldol[,c("feedsbrood", "nectarforaging", "pollenforaging", "egglaying")])

# calculate shannon's index for distributions of individuals across tasks
shannon <- diversity(alldol_M, index = "shannon")
hist(shannon)
# add shannon index into dataframe with bee info
alldol <- cbind(alldol, shannon)

###################### DON'T YET KNOW HOW TO CALCLUATE MUTUAL ENTROPY OF MATRIX - THIS IS INCORRECT ######################

# calculate mutal entropy for entire matrix
# this function returns an estimate of the Shannon entropy -- cannot find "mutual entropy"
# https://cran.r-project.org/web/packages/entropy/entropy.pdf
library(entropy)
# using maximum likelihood method here, there are many other options
mutEntropy <- entropy(alldol_M, method = "ML")
mutEntropy
# calcluate dol index (mutual entropy / H) for each bee and add it to the dataframe -- should be an index between 0-1
alldol$dol <- mutEntropy / alldol$shannon
alldol 
```

# glmm on H across time, nestTYPE, and caste
```{r}
# add a small value to data so that values > 0
alldol$H1 <- alldol$H + 0.01

library(car)
library(MASS)

######################### CAN'T FIGURE OUT DISTRIBUTION. ANALYSES ARE INVALID UNTIL THIS IS RESOLVED ########################

# normal distribution
qqp(alldol$H1, "norm")

# lnorm means lognormal
qqp(alldol$H1, "lnorm")

# gamma must be positive numbers
gamma <- fitdistr(alldol$H1, "gamma")
qqp(alldol$H1, "gamma", shape = gamma$estimate[[1]], rate = gamma$estimate[[2]])

# run model
library(lme4)
dol1 <- glmer(H ~ nestTYPE + caste + timepoint + (1|beeID),
              data = alldol)

# p values
library(sjPlot)
tab_model(dol1)
```
