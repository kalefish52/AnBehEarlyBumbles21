---
title: "Bumble Bee Queen Time Budgeting and Task Repertoire"
output: html_notebook
---

# Proposed Topic
How does the social environment affect bumble bee queen task repertoire and time budget?


# Background
Bumble bees have an annual life cycle
-contains both a solitary phase and a social phase

Solitary Phase: queens exhibit broad task repertoire, carry out brood care, nest maintenance, and foraging tasks independently

Social Phase: queens transition to focusing almost exclusively on reproduction. workers take over brood care and foraging tasks


# Data Collection Methods
-Q0 queens (solitary)
-Q3 queens (with 3 workers)
-Q5 queens (with 5 workers)

-2 time points per colony (early + late)

-score behavioral data in videos


# Video Data
Data includes several spreadsheets (each spreadsheet corresponding to a single colony) with the following variables:
-Observation ID
-Observaton date
-Subject
-Behavior
-Modifiers
-Behavior Type
-Start 
-Stop 
-Comments


# Questions to answer

1-Do solitary queens perform different behaviors than social queens?

2-Do social queens spend proportionately more/less time on certain tasks than solitary queens?

3-Do social queens spend absolutely more/less time on certain tasks than solitary queens?


# Data Analyses

### Load Packages
```{r}
library(tidyverse)
library(dplyr)
library(plyr)
if(!require(ggplot2)){install.packages("ggplot2")}
```





### Load Data
```{r}

## create a list of all the files in the BORISfiles directory. these are all the files we want to import
#borisfiles <- list.files("/Users/ericasarro/Google\ Drive\ File\ Stream/My\ Drive/WoodardLab.shared/Projects/2018.Awesome.Summer.Experiments/Raw\ Data/BORISfiles")

## loop over the files and import all of them. rename column names to remove "." and make shorter
#lapply(borisfiles, read.csv, header = TRUE, col.names = c("obsID", "obsDate", "filename", "totalLen", "fps", "beeID", "behav", "mod", "behavType", "start", "stop", "dur", "comStart", "comStop"))

## do this to all the things 
#do.call(rbind(filename))
```

```{r}
## load a subset of data to test
all_data <- read.csv("/Users/ericasarro/Google\ Drive\ File\ Stream/My\ Drive/MasterProjects/18Su_AwesomeSummer/MockData/AggEvents.csv", header = TRUE, col.names = c("obsID", "obsDate", "filename", "totalLen", "fps", "beeID", "behav", "mod", "behavType", "start", "stop", "dur", "comStart", "comStop" ))
head(all_data)

```





### Clean Data
split obsID column into its component parts to enable manipulation by camera/colony/time/date
```{r}
## convert columns to character to enable manipulation with strsplit() and subset(startsWith())
all_data$beeID <- as.character(all_data$beeID)
all_data$obsID <- as.character(all_data$obsID)

## split out obsID into camID, nestID, dateID and hourID (split based on the tab (\t) between elements)
## element 1 is camID
all_data$camID <- sapply(strsplit(all_data$obsID, "\t"), 
                          function(x){
                            x[1]
                            } )
## element 2 is nestID
all_data$nestID <- sapply(strsplit(all_data$obsID, "\t"), 
                          function(x){
                            x[2]
                            } )
## element 3 is dateID
all_data$dateID <- sapply(strsplit(all_data$obsID, "\t"), 
                          function(x){ 
                            x[3]
                            } )
## element 4 is hourID
all_data$hourID <- sapply(strsplit(all_data$obsID, "\t"), 
                          function(x){ 
                            x[4]
                            } )
```
## Frequency count
output df with each bee as a single row, behaviors as columns, count of frequency of each behavior per bee as values
```{r}
## collapse the dataframe to count the number of instances doing each behavior
## this outputs a new dataframe with columns nestID, beeID, nectarforaging, feedsbrood, pollenforaging 
#  (and any other behaviors recorded), with counts for each behavior in as values
## assumes that no two behaviors stopped at the exact same time. cannot handle duplicate stop times. 
#  not sure how to fix that...
count_data <- all_data
count_data$count <- 1
count_data <- count_data %>%
  pivot_wider(id_cols = c("nestID", "beeID", "behav"), 
              names_from = stop, 
              values_from = count)

## add column for sum of counts for each behav
count_data$totCount <- rowSums(count_data[4:ncol(count_data)], na.rm = TRUE)

## subset dataframe so that all is left is nestID, beeID, behav, and totDur
count_data <- count_data %>%
  select(nestID, beeID, behav, totCount)

## collapse dataframe so that each bee has one single row. cols = nestID, beeID, nectarforaging, *other behaviors
count_data <- count_data %>%
  pivot_wider(id_cols = c("nestID", "beeID"), 
              names_from = behav, 
              values_from = totCount)

count_data

```
output df with total count of behaviors per individual per colony
```{r}
## sum rows excluding first two (nestID and beeID)
totFreq <- count_data
totFreq$nBehavs <- rowSums(count_data[, 3:ncol(count_data)], na.rm = TRUE)

```
## Duration
output df with each bee as a single row, behaviors as columns, total duration of each behavior per bee as values
```{r}
## make duration of all brood feeding events 1 second duration to enable duration comparisons
time_data <- all_data
for (i in 1:nrow(time_data)) {
  if (time_data$behav[i] == "feedsbrood") {
    time_data$dur[i] <- 1
  }
}

## collapse dataframe so that columns = nestID, beeID, behav, and stop times for each behavior. 
## values = duration of each behav
dur_data <- time_data %>%
  pivot_wider(id_cols = c("nestID", "beeID", "behav"), 
              names_from = stop, 
              values_from = dur, 
              names_repair = "minimal")

## add column for sum of duration for each behav
dur_data$totDur <- rowSums(dur_data[4:ncol(dur_data)], na.rm = TRUE)

## subset dataframe so that all is left is nestID, beeID, behav, and totDur
dur_data <- dur_data %>%
  select(nestID, beeID, behav, totDur)

## collapse dataframe so that each bee has one single row. cols = nestID, beeID, nectarforaging, *other behaviors
dur_data <- dur_data %>%
  pivot_wider(id_cols = c("nestID", "beeID"), 
              names_from = behav, 
              values_from = totDur)

dur_data
```
output df with total duration of video watched per colony. columns = nestID and totalLen
```{r}
## select only the obsID, nestID, and totalLen columns
## subset to only the unique combinations (ie. remove duplicates so we don't count more time than we watched)
totalLen_data <- all_data %>%
  select(obsID, nestID, totalLen) %>%
  unique()
totalLen_data

## split out obsID into camID, dateID and hourID (split based on the tab (\t) between elements)
## element 1 is camID
totalLen_data$camID <- sapply(strsplit(totalLen_data$obsID, "\t"), 
                          function(x){
                            x[1]
                            } )
## element 3 is dateID
totalLen_data$dateID <- sapply(strsplit(totalLen_data$obsID, "\t"), 
                          function(x){ 
                            x[3]
                            } )
## element 4 is hourID
totalLen_data$hourID <- sapply(strsplit(totalLen_data$obsID, "\t"), 
                          function(x){ 
                            x[4]
                            } )
## combine date and hour into a single column called timeID
totalLen_data$timeID <- paste(totalLen_data$dateID, totalLen_data$hourID)
## subset the df to remove the obs, hour, and date columns
totalLen_data <- totalLen_data %>%
  select(camID, timeID, nestID, totalLen)

totalLen_data

## for each nestID, remove nest videos that have a matching foraging video (i.e. watched twice)
#  sum totalLen for all the for videos + nest videos that do not have a matching for video
camDur <- data.frame(nestID = NA,
                     totalLen = NA)
for (i in 1:length(unique(totalLen_data$nestID))) {
  sub_data <- subset(totalLen_data, nestID == unique(totalLen_data$nestID)[i])
  for_data <- subset(sub_data, sub_data$camID == "for")
  nest_data <- subset(sub_data, sub_data$camID == "nest")
  subNest_data <- nest_data %>%
      filter(! timeID %in% for_data$timeID)
  forSum <- sum(for_data$totalLen)
  nestSum <- sum(subNest_data$totalLen)
  camSum <- forSum + nestSum
  camDur <- rbind(camDur, c(sub_data$nestID[1], camSum))
}
## remove NA row initially created
camDur <- camDur[2:nrow(camDur),]
camDur
```





### Visualize Data

## Frequency
```{r}
## NxN df with nestID, beeID, behaviors x y z, and totalBehavs // individual bees as rows // total number of behaviors
totFreq

## subset only queen data ******(do this earlier when i run it for real)******
queen_freq <- totFreq[grep("Queen", totFreq$beeID), ]

## replace NA values with 0
queen_freq[is.na(queen_freq)] <- 0

## add column for treatment (separate treatment from colID in nestID column)
queen_freq$treat <- substr(queen_freq$nestID, start = 1, stop = 2)

## make social treatment a factor so it creates 2 distinct groups (rather than scale from 0-1)
queen_freq$treat <- factor(queen_freq$treat, levels = c("QA", "QT", "QF"))

queen_freq
```
gather data so it's one row per individual-behavior combo
```{r}
## gather the data so it's got one row per individual-behavior combo
## ******** need to make this more inclusive of all behaviors i'm coding *********
gath_freq <- queen_freq %>%
  gather(feedsbrood, pollenforaging, nectarforaging, key = "behav", value = "count")

gath_freq
```
pie charts with propotional duration
```{r}
## call it prop_freq to make it distinct
prop_freq <- gath_freq

## add column called prop that calculates proportion of total time per behavior
prop_freq$prop <- NA
for (i in 1:nrow(prop_freq)) {
  prop_freq$prop[i] <- prop_freq$count[i]/prop_freq$nBehavs[i]
}
prop_freq

## subset to make pie graph of QF groups
qf_prop_freq <- subset(prop_freq, prop_freq$treat == "QF")
qf_prop_freq

## summarize over all the qf groups
dfSumm <- ddply(qf_prop_freq, 
                c("behav"), 
                summarise,
                mean = mean(prop), 
                sd = sd(prop),
                sem = sd(prop)/sqrt(length(prop)))
dfSumm

pg <- ggplot(dfSumm, aes(x="", y=mean, fill=behav)) +
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start=0)
pg
```
bar graphs with absolute time. bar height = mean, error = sem, grouped by behavior, colored by social group
```{r}
## call it abs_freq to make distinct
abs_freq <- gath_freq

## summarize the data and calculate mean, sd, sem
dfSumm <- ddply(abs_freq, 
                c("behav", "treat"), 
                summarise,
                mean = mean(count), 
                sd = sd(count),
                sem = sd(count)/sqrt(length(time)))
dfSumm

## plot the summarized data in a barplot with error bars equal to sem
## important that error bar position_dodge = geom_bar width
p <- ggplot(dfSumm, aes(x = behav, 
                   y = mean, 
                   fill = treat,
                   ymin = mean - sem,
                   ymax = mean + sem)) + 
  geom_bar(position = position_dodge(),
           stat="identity",
           width = 0.5) +
  geom_errorbar(position=position_dodge(0.5), 
                width=0.1) +
  theme(text = element_text(size=20)) +
  theme(legend.position="top") +
  labs(x = "behavior", 
       y = "count",
       legend = "queen ID")
p
```

## Duration
```{r}
## saves plot ggsave(xxxx.pdf)
## 2xN df with nestID and totalLen as columns // totalLen value is total observed time (sec)
camDur

## NxN df with nestID, beeID, behaviors x y z etc as columns // individual bees as rows // total duration of behaviors (sec)
dur_data

## subset only queen data ******(do this earlier when i run it for real)******
queen_dur <- dur_data[grep("Queen", dur_data$beeID), ]
queen_dur

## add column to queen data that includes total duration of observed time 
## first order both dataframes to make sure they are in the same order
queen_dur <- queen_dur[order(queen_dur$nestID),] 
camDur <- camDur[order(camDur$nestID),]
## then add the column
queen_dur$totalLen <- camDur$totalLen

## replace NA values with 0
queen_dur[is.na(queen_dur)] <- 0

## add column for treatment (separate treatment from colID in nestID column)
queen_dur$treat <- substr(queen_dur$nestID, start = 1, stop = 2)

## make social treatment a factor so it creates 2 distinct groups (rather than scale from 0-1)
queen_dur$treat <- factor(queen_dur$treat, levels = c("QA", "QT", "QF"))

## make new column for total time spent doing nothing
## ********make more inclusive of all behaviors************
queen_dur$totalLen <- as.numeric(queen_dur$totalLen)
queen_dur$non <- NA
for (i in 1:nrow(queen_dur)) {
  queen_dur$non[i] <- queen_dur$totalLen[i] - 
                          queen_dur$feedsbrood[i] - 
                          queen_dur$pollenforaging[i] - 
                          queen_dur$nectarforaging[i] 
}

queen_dur


```
gather data so it's one row per individual-behavior combo
```{r}
## gather the data so it's got one row per individual-behavior combo
## ******** need to make this more inclusive of all behaviors i'm coding *********
gath_dur <- queen_dur %>%
  gather(feedsbrood, pollenforaging, nectarforaging, non, key = "behav", value = "time")

gath_dur
```
pie charts with propotional duration
```{r}
## call it prop_dur to make it distinct
prop_dur <- gath_dur

## add column called prop that calculates proportion of total time per behavior
prop_dur$prop <- NA
for (i in 1:nrow(prop_dur)) {
  prop_dur$prop[i] <- prop_dur$time[i]/prop_dur$totalLen[i]
}
prop_dur

## subset to make pie graph of QF groups
qf_prop_dur <- subset(prop_dur, prop_dur$treat == "QF")
qf_prop_dur

## summarize over all the qf groups
dfSumm <- ddply(qf_prop_dur, 
                c("behav"), 
                summarise,
                mean = mean(prop), 
                sd = sd(prop),
                sem = sd(prop)/sqrt(length(prop)))
dfSumm

pg <- ggplot(dfSumm, aes(x="", y=mean, fill=behav)) +
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start=0)
pg
```
bar graphs with absolute time. bar height = mean, error = sem, grouped by behavior, colored by social group
```{r}
## call it abs_dur to make distinct
abs_dur <- gath_dur

## summarize the data and calculate mean, sd, sem
dfSumm <- ddply(abs_dur, 
                c("behav", "treat"), 
                summarise,
                mean = mean(time), 
                sd = sd(time),
                sem = sd(time)/sqrt(length(time)))
dfSumm

## plot the summarized data in a barplot with error bars equal to sem
## important that error bar position_dodge = geom_bar width
p <- ggplot(dfSumm, aes(x = behav, 
                   y = mean, 
                   fill = treat,
                   ymin = mean - sem,
                   ymax = mean + sem)) + 
  geom_bar(position = position_dodge(),
           stat="identity",
           width = 0.5) +
  geom_errorbar(position=position_dodge(0.5), 
                width=0.1) +
  theme(text = element_text(size=20)) +
  theme(legend.position="top") +
  labs(x = "behavior", 
       y = "absolute time (sec)",
       legend = "queen ID")
p
```


### Analyze Data
```{r}

```





