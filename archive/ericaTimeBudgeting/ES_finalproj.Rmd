---
title: "Queen time budgeting and task repertoire"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Proposed Topic
How does the social environment affect bumble bee queen task repertoire and time budget?


# Background
Bumble bees have an annual life cycle
-contains both a solitary phase and a social phase

Solitary Phase: queens exhibit broad task repertoire, carry out brood care, nest maintenance, and foraging tasks independently

Social Phase: queens transition to focusing almost exclusively on reproduction. workers take over brood care and foraging tasks


# Data Collection Methods
-Q0 queens (solitary)
-Q3 queens (with 3 workers)
-Q5 queens (with 5 workers)

-2 time points per colony (early + late)

-score behavioral data in videos via BORIS


# Video Data
Data includes several spreadsheets (each spreadsheet corresponding to a single colony) with the following variables:
-Observation ID
-Observaton date
-Subject
-Behavior
-Modifiers
-Behavior Type
-Start 
-Stop 
-Comments


# Questions to answer

1-Do solitary queens perform different behaviors than social queens?

2-Do social queens spend proportionately more/less time on certain tasks than solitary queens?

3-Do social queens spend absolutely more/less time on certain tasks than solitary queens?


# Data Analyses

## Load Packages
```{r}
if(!require(ggplot2)){install.packages("ggplot2")}
if(!require(ggpubr)){install.packages("ggpubr")}
if(!require(lme4)){install.packages("lme4")}
if(!require(afex)){install.packages("afex")}
library(lme4)
library(ggplot2)
library(ggpubr)
library(tidyverse)
library(dplyr)
library(plyr)

```

## Load Data
Load in the cleaned data after running the CleanData file
```{r}
## set working directory to the git folder
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # first set it to where this doc lives (SarroFisher)
```

```{r}
count_data <- read.csv(paste(wd, "/Manuscript_analyses/count_data.csv", sep = ""))
dur_data <- read.csv(paste(wd, "/Manuscript_analyses/dur_data.csv", sep = ""))
camDur <- read.csv(paste(wd, "/Manuscript_analyses/camDur.csv", sep = ""))
```

# Visualize Data
### Counts of each behavior per individual
Visualize the average number of times each behavior was carried out by queens in each of the three groups (solitary queen, social queen (3 workers), social queen (5 workers))
```{r}
## NxN df with nestID, beeID, behaviors x y z, and totalBehavs // individual bees as rows // total number of behaviors
count_data

## remove workers from the data becauase i'm only interested in queens here
count_data$beeType <- as.character(count_data$beeType)
queen_count <- count_data[count_data$beeType == "Q", ]

## replace NA values with 0s so I can count 0 instances of behaviors not observed
queen_count[is.na(queen_count)] <- 0

## add column for treatment so i can view the three treatment groups (solitary queen, queen + 3 workers, queen + 5 workers) individually
queen_count$treat <- substr(queen_count$nestID, start = 1, stop = 2)

## make social treatment a factor so it creates 2 distinct groups (rather than scale from 0-1)
queen_count$treat <- factor(queen_count$treat, levels = c("QA", "QT", "QF"))

queen_count
```
gather data so it's one row per individual-behavior combo
```{r}
## gather the data so it's got one row per individual-behavior combo
gath_count <- queen_count %>%
  gather(feedsbrood, broodmanipulate, incubate, waxmanipulate, pollenforaging, nectarforaging, offbrood, other, key = "behav", value = "count")

## remove rows with NA nest ID
gath_count <- gath_count[!is.na(gath_count$treat),]

gath_count
```
make pie charts with propotional counts of behaviors. one chart per social group
```{r}
## call it prop_count to make it distinct
prop_count <- gath_count

## add column called prop that calculates proportion of total time per behavior
prop_count$prop <- NA
for (i in 1:nrow(prop_count)) {
  prop_count$prop[i] <- prop_count$count[i]/prop_count$nBehavs[i]
}

## subset to make pie graph of QF groups
qf_prop_count <- subset(prop_count, prop_count$treat == "QF")

## summarize over all the qf groups
dfSumm <- ddply(qf_prop_count, 
                c("behav"), 
                summarise,
                mean = mean(prop), 
                sd = sd(prop),
                sem = sd(prop)/sqrt(length(prop)))
## standardize the means back to proportions so they add up to 1
dfSumm$tot <- sum(dfSumm$mean)
dfSumm$mean <- dfSumm$mean/dfSumm$tot
## graph
QF <- ggplot(dfSumm, aes(x="", y=mean, fill=behav)) +
  geom_bar(width = 1, stat = "identity") +
  labs(x = "QF",
       y = "QF") +
  coord_polar("y", start=0)

## subset to make pie graph of QT groups
qt_prop_count <- subset(prop_count, prop_count$treat == "QT")
## summarize over all the qf groups
dfSumm <- ddply(qt_prop_count, 
                c("behav"), 
                summarise,
                mean = mean(prop), 
                sd = sd(prop),
                sem = sd(prop)/sqrt(length(prop)))
## standardize the means back to proportions so they add up to 1
dfSumm$tot <- sum(dfSumm$mean)
dfSumm$mean <- dfSumm$mean/dfSumm$tot
## graph
QT <- ggplot(dfSumm, aes(x="", y=mean, fill=behav)) +
  geom_bar(width = 1, stat = "identity") +
  labs(x = "QT",
       y = "QT") +
  coord_polar("y", start=0)

## subset to make pie graph of QA groups
qa_prop_count <- subset(prop_count, prop_count$treat == "QA")
## summarize over all the qf groups
dfSumm <- ddply(qa_prop_count, 
                c("behav"), 
                summarise,
                mean = mean(prop), 
                sd = sd(prop),
                sem = sd(prop)/sqrt(length(prop)))
## standardize the means back to proportions so they add up to 1
dfSumm$tot <- sum(dfSumm$mean)
dfSumm$mean <- dfSumm$mean/dfSumm$tot
## graph
QA <- ggplot(dfSumm, aes(x="", y=mean, fill=behav)) +
  geom_bar(width = 1, stat = "identity") +
  labs(x = "QA",
       y = "QA") +
  coord_polar("y", start=0)

## plot them all on one graph
figure <- ggarrange(QA, QT, QF,
                    labels = c("A", "B", "C"),
                    ncol = 1, nrow = 1)
figure
```
make bar graphs with counts of each behavior. bar height = mean, error = sem, grouped by behavior, colored by social group
```{r}
## call it abs_count to make distinct
abs_count <- gath_count

## summarize the data and calculate mean, sd, sem
dfSumm <- ddply(abs_count, 
                c("behav", "treat"), 
                summarise,
                mean = mean(count), 
                sd = sd(count),
                sem = sd(count)/sqrt(length(time)))
dfSumm

## plot the summarized data in a barplot with error bars equal to sem
## important that error bar position_dodge = geom_bar width to center error bars on the graph
p <- ggplot(dfSumm, aes(x = behav, 
                   y = mean, 
                   fill = treat,
                   ymin = mean - sem,
                   ymax = mean + sem)) + 
  geom_bar(position = position_dodge(),
           stat="identity",
           width = 0.5) +
  geom_errorbar(position = position_dodge(0.5), 
                width = 0.1) +
  theme(text = element_text(size = 20)) +
  theme(axis.text.x = element_text(angle = 90)) +
  theme(legend.position = "top") +
  labs(x = "behavior", 
       y = "count",
       legend = "queen ID")
p
```

## Duration of each behavior per individual
```{r}
## saves plot ggsave(xxxx.pdf)
## 2xN df with nestID and totalLen as columns // totalLen value is total observed time (sec)
camDur

## NxN df with nestID, beeID, behaviors x y z etc as columns // individual bees as rows // total duration of behaviors (sec)
dur_data

## subset only queen data because i'm only interested in queens
queen_dur <- dur_data[grep("Queen", dur_data$beeID), ]
queen_dur

## add column to queen data that includes total duration of observed time 
## first subset camDur to only include nests that we have queens for
camDur <- camDur %>%
      filter(nestID %in% queen_dur$nestID)
camDur
## then order both dataframes to make sure they are in the same order
queen_dur <- queen_dur[order(queen_dur$nestID),] 
camDur <- camDur[order(camDur$nestID),]
## then add the legth column to the queen_dur data
queen_dur$totalLen <- camDur$totalLen

## replace NA values with 0
queen_dur[is.na(queen_dur)] <- 0

## add column for treatment (separate treatment from colID in nestID column)
queen_dur$treat <- substr(queen_dur$nestID, start = 1, stop = 2)

## make social treatment a factor so it creates 2 distinct groups (rather than scale from 0-1)
queen_dur$treat <- factor(queen_dur$treat, levels = c("QA", "QT", "QF"))

## make new column for total time spent doing nothing
## make totalLen a number so we can do math on it
queen_dur$totalLen <- as.numeric(queen_dur$totalLen)
## add column called non for time doing nothing
queen_dur$non <- NA
## subtract time doing stuff from total time to calculate time doing nothing
for (i in 1:nrow(queen_dur)) {
  queen_dur$non[i] <- queen_dur$totalLen[i] - 
                          queen_dur$fillshoneypot[i] -
                          queen_dur$laysegg[i] -
                          queen_dur$eatsbrood[i] -
                          queen_dur$fillshoneypot[i] -
                          queen_dur$broodmanipulate[i] -
                          queen_dur$incubate[i] -
                          queen_dur$waxmanipulate[i] -
                          queen_dur$offbrood[i] -
                          queen_dur$feedsbrood[i] -
                          queen_dur$pollenforaging[i] - 
                          queen_dur$nectarforaging[i] 
}

queen_dur

## gather the data so it's got one row per individual-behavior combo
gath_dur <- queen_dur %>%
  gather(feedsbrood, broodmanipulate, incubate, waxmanipulate, pollenforaging, nectarforaging, offbrood, other, non, key = "behav", value = "time")

gath_dur

```
pie charts with propotional duration of time spent on each behavior for each social group
```{r}
## call it prop_dur to make it distinct
prop_dur <- gath_dur

## add column called prop that calculates proportion of total time per behavior
prop_dur$prop <- NA
for (i in 1:nrow(prop_dur)) {
  prop_dur$prop[i] <- prop_dur$time[i]/prop_dur$totalLen[i]
}
prop_dur

## subset to make pie graph of QF groups
qf_prop_dur <- subset(prop_dur, prop_dur$treat == "QF")
qf_prop_dur

## summarize over all the qf groups
dfSumm <- ddply(qf_prop_dur, 
                c("behav"), 
                summarise,
                mean = mean(prop), 
                sd = sd(prop),
                sem = sd(prop)/sqrt(length(prop)))
## standardize the means back to proportions so they add up to 1
dfSumm$tot <- sum(dfSumm$mean)
dfSumm$mean <- dfSumm$mean/dfSumm$tot
## graph
QF <- ggplot(dfSumm, aes(x="", y=mean, fill=behav)) +
  geom_bar(width = 1, stat = "identity") +
  labs(x = "QF",
       y = "QF") +
  coord_polar("y", start=0)

## subset to make pie graph of QT groups
qt_prop_dur <- subset(prop_dur, prop_dur$treat == "QT")
qt_prop_dur

## summarize over all the qf groups
dfSumm <- ddply(qt_prop_dur, 
                c("behav"), 
                summarise,
                mean = mean(prop), 
                sd = sd(prop),
                sem = sd(prop)/sqrt(length(prop)))
## standardize the means back to proportions so they add up to 1
dfSumm$tot <- sum(dfSumm$mean)
dfSumm$mean <- dfSumm$mean/dfSumm$tot
## graph
QT <- ggplot(dfSumm, aes(x="", y=mean, fill=behav)) +
  geom_bar(width = 1, stat = "identity") +
  labs(x = "QT",
       y = "QT") +
  coord_polar("y", start=0)

## subset to make pie graph of QF groups
qa_prop_dur <- subset(prop_dur, prop_dur$treat == "QA")
qa_prop_dur

## summarize over all the qa groups
dfSumm <- ddply(qa_prop_dur, 
                c("behav"), 
                summarise,
                mean = mean(prop), 
                sd = sd(prop),
                sem = sd(prop)/sqrt(length(prop)))
## standardize the means back to proportions so they add up to 1
dfSumm$tot <- sum(dfSumm$mean)
dfSumm$mean <- dfSumm$mean/dfSumm$tot
## graph
QA <- ggplot(dfSumm, aes(x="", y=mean, fill=behav)) +
  geom_bar(width = 1, stat = "identity") +
  labs(x = "QA",
       y = "QA") +
  coord_polar("y", start=0)

## plot them all on one graph
figure <- ggarrange(QA, QT, QF,
                    labels = c("QA", "QT", "QF"),
                    ncol = 1, nrow = 1)
figure
```
bar graphs with absolute duration of each behavior. bar height = mean, error = sem, grouped by behavior, colored by social group
```{r}
## call it abs_dur to make distinct
abs_dur <- gath_dur[!gath_dur$behav=="non",]

## summarize the data and calculate mean, sd, sem
dfSumm <- ddply(abs_dur, 
                c("behav", "treat"), 
                summarise,
                mean = mean(time), 
                sd = sd(time),
                sem = sd(time)/sqrt(length(time)))
dfSumm

## plot the summarized data in a barplot with error bars equal to sem
## important that error bar position_dodge = geom_bar width
p <- ggplot(dfSumm, aes(x = behav, 
                   y = mean, 
                   fill = treat,
                   ymin = mean - sem,
                   ymax = mean + sem)) + 
  geom_bar(position = position_dodge(),
           stat="identity",
           width = 0.5) +
  geom_errorbar(position=position_dodge(0.5), 
                width=0.1) +
  theme(text = element_text(size = 20)) +
  theme(axis.text.x = element_text(angle = 90)) +
  theme(legend.position="top") +
  labs(x = "behavior", 
       y = "absolute time (sec)",
       legend = "queen ID")
p
```


